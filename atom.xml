<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Japan Azure IaaS Core Support Blog</title>
  
  <subtitle>日本マイクロソフトの Azure IaaS テクニカル サポート チームより、情報をお届けします！</subtitle>
  <link href="https://jpaztech.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://jpaztech.github.io/blog/"/>
  <updated>2023-12-29T07:45:21.855Z</updated>
  <id>https://jpaztech.github.io/blog/</id>
  
  <author>
    <name>Japan Azure IaaS Core Support Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Azure VM の「再起動を必要としないメンテナンス」を事前に検知する方法</title>
    <link href="https://jpaztech.github.io/blog/vm/get-scheduled-events-from-imds/"/>
    <id>https://jpaztech.github.io/blog/vm/get-scheduled-events-from-imds/</id>
    <published>2023-12-29T07:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.855Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>今回は表題の通り、Azure VM の再起動を必要としないメンテナンスを事前に検知する方法をご紹介させていただきます。<br>IMDS を用いて Scheduled Events を監視することで、再起動を必要としないメンテナンスを事前に検知することが可能です。  </p><hr><h2 id="Azure-VM-のメンテナンスについて"><a href="#Azure-VM-のメンテナンスについて" class="headerlink" title="Azure VM のメンテナンスについて"></a>Azure VM のメンテナンスについて</h2><p>Azure VM はお客様に安心してご利用いただくためにセキュリティ向上の対応や機能改善等を目的として定期的に Azure 基盤側のメンテナンスを行っております。<br>お客様の VM に影響の発生する可能性のあるメンテナンスとして、大きく以下の 2 種類に分けられます。  </p><ul><li>再起動を<strong>必要とする</strong>メンテナンス</li><li>再起動を必要としないメンテナンス（ライブマイグレーションを含む）</li></ul><blockquote><p>■ご参考：Azure での仮想マシンのメンテナンス<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates</a></p></blockquote><p>再起動を<strong>必要とする</strong>メンテナンスについては、以下の通り Azure Portal の [サービスの正常性] で事前に確認が可能です。</p><blockquote><p>■ご参考：計画メンテナンスの通知の処理<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications</a></p></blockquote><p>再起動を必要としないメンテナンスについては、恐縮ながら Azure Portal での事前の確認をすることや、既定でメールの通知がされるものではございません。<br>そのため、「何とかして事前に再起動を必要としないメンテナンスが発生することを事前に確認することができないか？」というお問い合わせをいただくこともございます。<br>後述の通り、IMDS を用いて Scheduled Events を監視することで再起動を必要としないメンテナンスを事前に確認する事が可能です。  </p><hr><h2 id="IMDS-を用いて-Scheduled-Events-を確認する"><a href="#IMDS-を用いて-Scheduled-Events-を確認する" class="headerlink" title="IMDS を用いて Scheduled Events を確認する"></a>IMDS を用いて Scheduled Events を確認する</h2><p>まずは IMDS について簡単に解説させていただきます。<br>IMDS（Instance Metadata Service）は、現在実行中の VM に関する情報を取得できるものとなっております。<br>実行中の VM 内から IMDS に HTTP アクセスを行うことで、情報を取得することが可能です。<br>なお、同一の可用性セット内の VM もしくは同じ VMSS 内のインスタンスについても合わせて情報を取得できます。</p><blockquote><p>■ご参考：Azure Instance Metadata Service<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/instance-metadata-service">https://learn.microsoft.com/ja-jp/azure/virtual-machines/instance-metadata-service</a></p></blockquote><p>この IMDS のエンドポイントの 1 つとして、Scheduled Events というものがございます。<br>これは VM の近い将来にスケジュールされている VM の再起動やメンテナンスのイベントを確認できるものとなっております。  </p><blockquote><p>■ご参考：Azure Metadata Service: Windows VM のScheduled Events<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/scheduled-events">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/scheduled-events</a></p></blockquote><blockquote><p>■ご参考：Azure Metadata Service: Linux VM の Scheduled Events<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/scheduled-events">https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/scheduled-events</a></p></blockquote><p>それでは、Scheduled Eventsの確認を実際にやってましょう。<br>以下のコマンドを Azure VM 上のゲスト OS 内にて実行します。  </p><p><strong>Windows</strong> の場合は PowerShell より以下のコマンドで、IMDS の Scheduled Events のエンドポイントに HTTP でアクセスします。  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-RestMethod -Headers @&#123;&quot;Metadata&quot;=&quot;true&quot;&#125; -Method GET -Uri &quot;http://169.254.169.254/metadata/scheduledevents?api-version=2020-07-01&quot; | ConvertTo-Json -Depth 64</span><br></pre></td></tr></table></figure><p><strong>Linux</strong> の場合は以下の通り Bash で curl コマンドで、IMDS の Scheduled Events のエンドポイントに HTTP でアクセスします。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H Metadata:<span class="literal">true</span> http://169.254.169.254/metadata/scheduledevents?api-version=2020-07-01</span><br></pre></td></tr></table></figure><p>実行結果として、以下の例のように直近のスケジュールされたイベントがレスポンスとして確認できます。</p><h3 id="特に何もスケジュールされたイベントが無い場合"><a href="#特に何もスケジュールされたイベントが無い場合" class="headerlink" title="特に何もスケジュールされたイベントが無い場合"></a>特に何もスケジュールされたイベントが無い場合</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;DocumentIncarnation&quot;</span>:  <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;Events&quot;</span>:  [</span><br><span class="line"></span><br><span class="line">               ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="起動を必要としないメンテナンスがスケジュールされている場合"><a href="#起動を必要としないメンテナンスがスケジュールされている場合" class="headerlink" title="起動を必要としないメンテナンスがスケジュールされている場合"></a>起動を必要としないメンテナンスがスケジュールされている場合</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;DocumentIncarnation&quot;</span>:  <span class="number">28</span>,</span><br><span class="line">    <span class="attr">&quot;Events&quot;</span>:  [</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="attr">&quot;EventId&quot;</span>:  <span class="string">&quot;E92E64F9-XXXX-XXXX-XXXX-FF3EBA4C0090&quot;</span>,</span><br><span class="line">                       <span class="attr">&quot;EventStatus&quot;</span>:  <span class="string">&quot;Scheduled&quot;</span>, → スケジュールされたイベントがある。★★★</span><br><span class="line">                       <span class="attr">&quot;EventType&quot;</span>:  <span class="string">&quot;Freeze&quot;</span>, → 再起動を伴わないメンテナンスである。★★★</span><br><span class="line">                       <span class="attr">&quot;ResourceType&quot;</span>:  <span class="string">&quot;VirtualMachine&quot;</span>,</span><br><span class="line">                       <span class="attr">&quot;Resources&quot;</span>:  [</span><br><span class="line">                                         <span class="string">&quot;VMName&quot;</span> → 対象の VM 名。★★★</span><br><span class="line">                                     ],</span><br><span class="line">                       <span class="attr">&quot;NotBefore&quot;</span>:  <span class="string">&quot;Mon, 19 Sep 2023 18:00:00 GMT&quot;</span>, → この時刻以降にメンテナンスが実行される。★★★</span><br><span class="line">                       <span class="attr">&quot;Description&quot;</span>:  <span class="string">&quot;This is sample Description&quot;</span>,</span><br><span class="line">                       <span class="attr">&quot;EventSource&quot;</span>:  <span class="string">&quot;Platform&quot;</span>,</span><br><span class="line">                       <span class="attr">&quot;DurationInSeconds&quot;</span>:  <span class="number">2</span> → 想定される影響時間は <span class="number">2</span> 秒である。★★★</span><br><span class="line">                   &#125;</span><br><span class="line">               ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>イベントによって何分前までには通知されるといった NotBefore の時間が違いますが、再起動を必要としないメンテナンスについては、実行される約 15 分前までにはスケジュールが設定されます。<br>つまり 20 分前といった場合はまだスケジュールが設定されていないために、確認が叶わない場合もございます点、ご留意ください。  </p><p>すなわち、定期的に IMDS の Scheduled Events をアクセスすることで、再起動を必要としないメンテナンス実行の約 15 分前には事前にメンテナンスが発生する予定を確認することが可能です。<br>次のセクションではこの Scheduled Events を定期的に確認する方法についてご案内させていただきます。  </p><hr><h2 id="Windows-環境で定期的に-Scheduled-Events-を監視し、再起動を必要としないメンテナンスがあった際にアラート通知を行うサンプル"><a href="#Windows-環境で定期的に-Scheduled-Events-を監視し、再起動を必要としないメンテナンスがあった際にアラート通知を行うサンプル" class="headerlink" title="Windows 環境で定期的に Scheduled Events を監視し、再起動を必要としないメンテナンスがあった際にアラート通知を行うサンプル"></a>Windows 環境で定期的に Scheduled Events を監視し、再起動を必要としないメンテナンスがあった際にアラート通知を行うサンプル</h2><p>Windows 環境においては、以下の通り公開ドキュメントとして、定期的に Scheduled Events を監視し、再起動を必要としないメンテナンスがスケジュールされた際にアラート通知を行うサンプルがございます。  </p><blockquote><p>■ご参考：Azure VM のスケジュールされたイベントを監視する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/scheduled-event-service">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/scheduled-event-service</a></p></blockquote><p>具体的な内容は実際のドキュメントをご確認いただきたく存じますが、簡単に内容を解説すると以下の通りとなります。  </p><ul><li>同一の可用性セットに VM を 2 つ作成する。</li><li>片方の VM にて SchService.ps1 という定期的な Scheduled Events のアクセスを行うスクリプトを実行する。</li><li>SchService.ps1 は同一の可用性セット内 VM に対する Scheduled Events を検知すると、その内容をイベントログに記録する。</li><li>Azure Monitor の Log Analytics を用いて、その記録されたイベントログを監視する。</li><li>Scheduled Events が記録されたイベントログを発見すると、アラート（メール通知等）を発報する。</li></ul><p>なお、恐縮ながら再起動を必要としないメンテナンスを疑似的に発生させて “EventType”:”Freeze” の Scheduled Events を発生させることは叶いません。<br>そのため、このサンプルの動作確認としては代替として再起動イベントを検知する形となっております。  </p><p>上記のサンプルによって、同一の可用性セット内の VM で再起動を必要としないメンテナンスがスケジュールされた際に、自動的にメール通知を行うといったことが可能となります。<br>また、SchService.ps1 をご自身で拡張いただくことで、Scheduled Events を検知したら自動的に何かを実行するといったスクリプトにしていただくことも可能です。</p><hr><h2 id="Linux-環境で定期的に-Scheduled-Events-を監視するサンプル"><a href="#Linux-環境で定期的に-Scheduled-Events-を監視するサンプル" class="headerlink" title="Linux 環境で定期的に Scheduled Events を監視するサンプル"></a>Linux 環境で定期的に Scheduled Events を監視するサンプル</h2><p>Linux 環境においては、上記の Windows のようにアラート通知を行うといったサンプルのご用意がございませんが、定期的な Scheduled Events の監視をするサンプルが以下の通りご用意されております。  </p><blockquote><p>■ご参考：Azure Metadata Service: Scheduled Events Samples<br><a href="https://github.com/Azure-Samples/virtual-machines-scheduled-events-discover-endpoint-for-non-vnet-vm">https://github.com/Azure-Samples/virtual-machines-scheduled-events-discover-endpoint-for-non-vnet-vm</a></p></blockquote><p>勿論、上記サンプル以外にも Scheduled Events へ定期的なアクセスを試みる方法を実行頂いても構いません。  </p><hr><p>以上の通り、Azure VM の再起動を必要としないメンテナンスを事前に検知する方法をご紹介させていただきました。<br>なお、再起動を必要としないメンテナンスを実行するタイミングをコントロールしたいといった場合は、Dedicated Host もしくは分離された仮想マシンをご利用の上、メンテナンス構成を設定いただくことで実現可能でございます。<br>この点については以下の公式ドキュメント等をご参照ください。  </p><blockquote><p>■ご参考：メンテナンス構成による VM の更新の管理<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-configurations">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-configurations</a></p></blockquote><p>定期的なメンテナンスは安心してお客様に Azure をご利用いただく上で必要不可欠でございます点、ご理解賜りますと幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;今回は表題の通り、Azure VM の再起動を必要としないメンテナンスを事前に検知する方法をご紹介させていただきます。&lt;br&gt;IMDS を用いて Scheduled Events を監視することで、再起</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>Azure Network 製品について TLS 1.2 以降に移行するアナウンスの補足 (Tracking ID:7_8G-D8Z)</title>
    <link href="https://jpaztech.github.io/blog/network/tls1.2_migration/"/>
    <id>https://jpaztech.github.io/blog/network/tls1.2_migration/</id>
    <published>2023-12-28T05:30:00.000Z</published>
    <updated>2023-12-29T07:45:21.699Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームです。<br>「2024 年 10 月 31 日までに、各種 Azure サービスとの通信に TLS 1.2 を使用していることを確認してください。」（Ensure your resources that interact with Azure services are using TLS 1.2 by 31 October 2024）の通知について、Azure Network 製品の対応状況、及びお客様に推奨なアクションをご紹介致します。 </p><div class="alert is-warning"><p class="alert-title">警告</p><p>以下各製品の部分に案内する対処目処はあくまで目途であり、実際には日程が多少前後する可能性があります。予めご了承ください。</p></div><span id="more"></span><h2 id="Application-Gateway"><a href="#Application-Gateway" class="headerlink" title="Application Gateway"></a>Application Gateway</h2><h3 id="クライアントから-Application-Gateway-への接続について"><a href="#クライアントから-Application-Gateway-への接続について" class="headerlink" title="クライアントから Application Gateway への接続について"></a>クライアントから Application Gateway への接続について</h3><p>Application Gateway では、SSL ポリシーを選択することで、クライアントが Application Gateway へ接続する際の最小 TLS バージョン（1.0 から 1.3 まで）を設定できます。 </p><p>現時点では、Application Gateway は2024 年 10 月 31 日以降にも引き続き TLS1.0 から TLS1.3 をサポートしており、TLS1.2 以下のバージョンをサポートしなくなる予定はございません。 </p><p>ただし、<a href="https://learn.microsoft.com/ja-jp/azure/application-gateway/application-gateway-configure-ssl-policy-powershell">こちらの公開ドキュメント</a>の記載通り、セキュリティ強化のためには TLS1.2 のご利用を推奨いたします。 </p><blockquote><p>注意<br>Application Gateway でのセキュリティを強化するために、TLS プロトコルの最小バージョンとして TLS 1.2 を使用することをお勧めします。</p></blockquote><h4 id="最小TLS-バージョンの設定方法"><a href="#最小TLS-バージョンの設定方法" class="headerlink" title="最小TLS バージョンの設定方法"></a>最小TLS バージョンの設定方法</h4><p>下図の通り、Azure ポータル → 対象 Application Gateway → 「リスナー」のタブにて、 「選択した SSL ポリシー」の「変更」ボタンをクリックし、「 SSL ポリシーの変更」より設定できます。<br><img src="./appgw_tls_setting.png"></p><p>また、Application Gateway SKU v2 の場合は、<a href="https://learn.microsoft.com/ja-jp/azure/application-gateway/application-gateway-configure-listener-specific-ssl-policy">こちらの手順通り</a>、リスナー毎に異なる TLS バージョンを設定することも可能です。 </p><h3 id="Application-Gateway-からバックエンド-サーバーへの接続について"><a href="#Application-Gateway-からバックエンド-サーバーへの接続について" class="headerlink" title="Application Gateway からバックエンド サーバーへの接続について"></a>Application Gateway からバックエンド サーバーへの接続について</h3><p><a href="https://learn.microsoft.com/ja-jp/azure/application-gateway/application-gateway-ssl-policy-overview#limitations">こちらの公開ドキュメント</a>の記載通り、Application Gateway がバックエンド サーバーへ通信する際に TLS 1.0, 1.1, 1.2 をサポートしております。 </p><blockquote><p>バックエンド サーバーへの接続は、常に最小でプロトコル TLS v1.0、最大で TLS v1.2 までです。 そのため、バックエンド サーバーとのセキュリティで保護された接続を確立するには、TLS バージョン 1.0、1.1、1.2 のみがサポートされます。</p></blockquote><p>具体的な TLS バージョンの選定は接続先のバックエンド サーバーに依存するため、もし最小 TLS バージョンを 1.2 に指定したい場合は、Application Gateway ではなく、バックエンド サーバー側の TLS 設定に対応して頂く必要があります。 </p><h2 id="Azure-Firewall"><a href="#Azure-Firewall" class="headerlink" title="Azure Firewall"></a>Azure Firewall</h2><p>Azure Firewall では、TLS バージョンが関わる部分は TLS インスペクションのみとなります。アプリケーション ルール、ネットワーク ルール、及び DNAT ルールで通信を許可する場合は本通知の対象外となります。</p><p>TLS インスペクション機能を使用する場合は、<a href="https://learn.microsoft.com/ja-jp/azure/firewall/premium-features#tls-inspection">こちらの公開ドキュメント</a>の記載通り、現状及び 2024 年 10 月 31 日以降にも TLS1.0 及び TLS1.1 は互換性のために引き続き動作する予定ですが、早めに TLS 1.2 に移行することを強く推奨します。</p><blockquote><p>ヒント<br>TLS 1.0 と 1.1 は非推奨になっていて、サポートされません。 TLS 1.0 と 1.1 のバージョンの TLS/SSL (Secure Sockets Layer) は脆弱であることが確認されています。現在、これらは下位互換性を維持するために使用可能ですが、推奨されていません。 できるだけ早く TLS 1.2 に移行してください。</p></blockquote><p>また、現状の TLS インスペクション機能では TLS1.3 をサポートしておりませんが、2024 年 3 月頃にサポートする予定です。</p><h2 id="Front-Door"><a href="#Front-Door" class="headerlink" title="Front Door"></a>Front Door</h2><p><a href="https://learn.microsoft.com/ja-jp/azure/frontdoor/end-to-end-tls?pivots=front-door-standard-premium#supported-tls-versions">こちらの公開ドキュメント</a>の記載通り、 Front Door ではカスタム ドメインを利用する場合は、最小 TLS バージョンを 1.0 または 1.2 を選択できます。 </p><blockquote><p>Azure Front Door では、TLS プロトコルの 3 つのバージョン (TLS バージョン 1.0、1.1、1.2) がサポートされています。 2019 年 9 月以降に作成されたすべての Azure Front Door プロファイルでは、既定の最小バージョンとして TLS 1.2 が使用されますが、下位互換性を確保するために TLS1.0 と TLS1.1 も引き続きサポートされています。</p></blockquote><p>Front Door では 2024 年 10 月 31 日以降も引き続き TLS1.0 から TLS1.2 まで利用できますが、セキュリティ強化のためには TLS1.2 のご利用を推奨いたします。<br>また、TLS1.3 のサポートに関しましては、2024 年 2 月 12 日より Front Door の全 SKU 及びAzure CDN Standard from Microsoft (classic) に順次サポートする予定です。</p><h2 id="Bastion"><a href="#Bastion" class="headerlink" title="Bastion"></a>Bastion</h2><p>Bastion はお客様側で証明書の管理運用を意識する必要のないサービスとして、<a href="https://learn.microsoft.com/ja-jp/azure/bastion/bastion-overview#key">以下の公開ドキュメント</a>の記載通り、 TLS 1.2 のみをサポートしておりますので、お客様側の対処が不要です。 </p><blockquote><p>Bastion では、TLS 1.2 以降がサポートされています。 以前の TLS バージョンはサポートされません。</p></blockquote><h2 id="Traffic-Manager"><a href="#Traffic-Manager" class="headerlink" title="Traffic Manager"></a>Traffic Manager</h2><p><a href="https://learn.microsoft.com/ja-jp/azure/traffic-manager/traffic-manager-how-it-works#how-clients-connect-using-traffic-manager">こちらの公開ドキュメント</a>の説明通り、TrafficManager は DNS レベルで動作する負荷分散サービスとして、クライアントからの通信は TrafficManager を経由しませんので、本通知の対象外となります。 </p><h2 id="Load-Balancer"><a href="#Load-Balancer" class="headerlink" title="Load Balancer"></a>Load Balancer</h2><p><a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-faqs#azure-load-balancer---tls-ssl---------------">こちらの公開ドキュメント</a>記載通り、Azure Load Balancer では、TLS 接続を終端せずにバックエンド サーバーへ転送する動作となりますので、本通知の対象外となります。 </p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームです。&lt;br&gt;「2024 年 10 月 31 日までに、各種 Azure サービスとの通信に TLS 1.2 を使用していることを確認してください。」（Ensure your resources that interact with Azure services are using TLS 1.2 by 31 October 2024）の通知について、Azure Network 製品の対応状況、及びお客様に推奨なアクションをご紹介致します。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!WARNING]&lt;br&gt;以下各製品の部分に案内する対処目処はあくまで目途であり、実際には日程が多少前後する可能性があります。予めご了承ください。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>サービスタグに必要なアクセス制御 (RBAC) について</title>
    <link href="https://jpaztech.github.io/blog/network/azure-service-tag-authority/"/>
    <id>https://jpaztech.github.io/blog/network/azure-service-tag-authority/</id>
    <published>2023-12-25T06:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.683Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームです。</p><p>Azure サービスをご利用いただく中で、Azure ロールベースのアクセス制御 (RBAC) を利用し、必要な権限をユーザーに付与し、運用いただいているお客様も多いかと存じます。その中で、Azure Portal 上の NSG のサービスタグが一部しか表示されない事象があるというお問い合わせを多くいただいておりますので、その原因および回避策について本ブログでご説明いたします。</p><h2 id="NSG-のサービスタグが一部しか表示されない原因"><a href="#NSG-のサービスタグが一部しか表示されない原因" class="headerlink" title="NSG のサービスタグが一部しか表示されない原因"></a>NSG のサービスタグが一部しか表示されない原因</h2><p>以下のように、一部のサービスタグのみしか表示されないというお問い合わせをいただいております。</p><p><img src="/blog/network/azure-service-tag-authority/service-tag-rbac-ng.png"></p><p>結論から申し上げると、サービスタグを表示させるための、RBAC 権限が付与されていない、不足している場合、上記のような事象が発生いたします。上記のように一部のサービスタグのみしか表示されない場合、サービスタグを表示させるための、読み取りアクセス許可をユーザーに対して付与いただく必要がございます。具体的には、すべてのサービスタグを表示させるために、<span style="color: red; "><strong>サブスクリプション</strong></span>のスコープに対して、以下の 2 つの読み取り権限を付与いただく必要がございます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Microsoft.Network/locations/serviceTags/read&quot;</span><br><span class="line">&quot;Microsoft.Network/locations/serviceTagDetails/read&quot;</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/service-tags-overview">仮想ネットワーク サービス タグ - Virtual Network | Microsoft Learn</a></p><blockquote><p>現在のサブスクリプションに対して、認証され、読み取りアクセス許可を持つロールを持っている必要があります。</p></blockquote><h2 id="全てのサービスタグを表示させる方法"><a href="#全てのサービスタグを表示させる方法" class="headerlink" title="全てのサービスタグを表示させる方法"></a>全てのサービスタグを表示させる方法</h2><p>一部のサービスタグのみしか表示されない場合、以下の手順をご確認下さい。</p><h3 id="1-読み取りアクセス許可権限が付与されているか"><a href="#1-読み取りアクセス許可権限が付与されているか" class="headerlink" title="1. 読み取りアクセス許可権限が付与されているか"></a>1. 読み取りアクセス許可権限が付与されているか</h3><p>Azure Portal からサブスクリプションへ遷移いただき、[アクセス制御 (IAM)] &gt; アクセスの確認 &gt; 対象のユーザーを検索 &gt; 割り当てられているロールを選択 &gt; JSON から、上述の 2 つの権限、または 2 つの権限を含む権限 (e.g. “Microsoft.Network/*/read”, “*“) が付与されているかご確認下さい。</p><h3 id="2-読み取りアクセス許可権限を付与する"><a href="#2-読み取りアクセス許可権限を付与する" class="headerlink" title="2. 読み取りアクセス許可権限を付与する"></a>2. 読み取りアクセス許可権限を付与する</h3><ol><li>の手順において、サービスタグの読み取りアクセス許可が無かった場合、サブスクリプションのスコープに対して、閲覧者ロールを付与する、または、カスタムロールで最小限の権限を付与したい場合、以下の 2 つの権限をカスタムロールに追加ください。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Microsoft.Network/locations/serviceTags/read&quot;</span><br><span class="line">&quot;Microsoft.Network/locations/serviceTagDetails/read&quot;</span><br></pre></td></tr></table></figure><p>サブスクリプションのスコープに対して、閲覧者権限を付与したい場合、Azure Portal からサブスクリプションへ遷移いただき、[アクセス制御 (IAM)] &gt; [+追加] &gt; [ロールの割り当ての追加] &gt; [閲覧者]を指定し、任意のユーザー、グループに権限を付与いただけます。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/quickstart-assign-role-user-portal#grant-access">アクセス権の付与 - ロールベースのアクセス制御 | Microsoft Learn</a></p><p>カスタムロールをご利用いただいている場合、Azure Portal からサブスクリプションへ遷移いただき、[アクセス制御 (IAM)] &gt; ユーザーに付与しているカスタムロールから [編集] を押下 &gt; JSON から上記 2 つの権限を追加ください。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/custom-roles-portal#update-a-custom-role">カスタム ロールの更新 - ロールベースのアクセス制御 | Microsoft Learn</a></p><p>上記設定適用後、ロールの更新には少々お時間を要しますので、一度 Azure Portal からログアウトいただき、再ログインいただいた後、サービスタグが表示されるようになるかご確認いただければと存じます。</p><h2 id="カスタムロールのご利用について"><a href="#カスタムロールのご利用について" class="headerlink" title="カスタムロールのご利用について"></a>カスタムロールのご利用について</h2><p>Azure Portal の UI はサービスタグに関わらず、高頻度で改善/改修が行われているため、それに伴い、必要な権限が追加・変更になる場合がございます。そのため、カスタムロールで細かく権限を制御されている場合、Azure Portal の UI 変更にともなって、権限修正が必要になる可能性もございます。カスタムロールをご利用の場合には、お客様側でも十分に検証いただくと共に、修正が必要になる点も予めご認識いただきますようお願い申し上げます。</p><p>以上、ご参考になりましたら幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームです。&lt;/p&gt;
&lt;p&gt;Azure サービスをご利用いただく中で、Azure ロールベースのアクセス制御 (RBAC) を利用し、必要な権限をユーザーに付与し、運用いただいているお客様も多いかと存じます。その中で、Azure</summary>
      
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="Network Security Group" scheme="https://jpaztech.github.io/blog/tags/Network-Security-Group/"/>
    
    <category term="Service Tag" scheme="https://jpaztech.github.io/blog/tags/Service-Tag/"/>
    
    <category term="RBAC" scheme="https://jpaztech.github.io/blog/tags/RBAC/"/>
    
  </entry>
  
  <entry>
    <title>Artifact Streaming とは？ ACR のイメージを AKS にデプロイして試してみた</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-artifact-streaming/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-artifact-streaming/</id>
    <published>2023-12-24T03:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.631Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は <a href="https://qiita.com/advent-calendar/2023/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2023</a> の 24 日目の記事になります🎅</p><p>こんにちは。Azure テクニカル サポートチームの桐井です。</p><p><a href="https://techcommunity.microsoft.com/t5/apps-on-azure-blog/aks-welcomes-you-to-ignite-2023/ba-p/3983317">Ignite 2023</a> で、ACR/AKS 関連の機能としてArtifact Streaming が発表されました。<br>本記事では、Artifact Streaming を使って ACR にあるコンテナー イメージを AKS クラスターにデプロイする様子を紹介します。</p><p>Artifact Streaming は 2023/12 現在、プレビュー機能として提供されております。<br>今後のアップデートにより、将来この記事で紹介した内容から変更される可能性があることを何卒ご了承ください！</p><span id="more"></span><h2 id="Artifact-Streaming-とは"><a href="#Artifact-Streaming-とは" class="headerlink" title="Artifact Streaming とは"></a>Artifact Streaming とは</h2><blockquote><p>ご参考) Public preview: Artifact streaming support in Azure Kubernetes Service (AKS)<br><a href="https://azure.microsoft.com/ja-jp/updates/public-review-artifact-streaming-support-in-azure-kubernetes-service-aks/">https://azure.microsoft.com/ja-jp/updates/public-review-artifact-streaming-support-in-azure-kubernetes-service-aks/</a></p></blockquote><p>コンテナー イメージは、データの実体を表す複数の<code>レイヤー</code>と、イメージに含まれるレイヤーの情報をまとめた<code>マニフェスト</code>によって構成されています。</p><p>通常、コンテナー化されたアプリケーションを起動するには、コンテナー イメージの Pull (ダウンロードと展開) が必要になります。<br>イメージの Pull では次のような処理が行われます:</p><ol><li>コンテナー レジストリにアクセスし、マニフェストからレイヤーの情報を取得する</li><li>レイヤーのダウンロードが必要か確認する (ローカル キャッシュが利用できるか確認する)</li><li>各レイヤーをダウンロードする</li><li>ダウンロード済みのレイヤーを展開する</li><li>コンテナーを起動する</li></ol><p>このように、コンテナーの起動に至るまでには、イメージを構成するレイヤーのダウンロードと展開の処理が必要となります。<br>そのため、レイヤーのデータ サイズが大きい場合や、レイヤー数が多いコンテナー イメージの場合は、コンテナーが起動するまでに時間を要すことがあります。</p><p>特に、Pod のオートスケールをするシナリオでは、Pod の起動時間がオートスケールの速度に影響を与えます。</p><p>また、クラスター オートスケーラーによってノードが削減され、その後新規ノードが追加された場合には、ノード内のコンテナー イメージのキャッシュが利用できません (AKS ではノードプールの <a href="https://learn.microsoft.com/ja-jp/azure/aks/scale-down-mode">スケールダウン モード</a>が <code>Delete</code> の場合)。<br>新規ノードでは、コンテナー イメージのダウンロードと展開が再び必要となってしまうため、Pod の起動完了までに時間を要する要因となってしまいます。</p><p>これらの問題は、Artifact Streaming を利用することで、解決を図ることができます。<br>Artifact Streaming を利用すると、コンテナー イメージ全体のダウンロードと展開を待つことなく、コンテナーを開始できます。</p><h2 id="Artifact-Streaming-を試してみよう"><a href="#Artifact-Streaming-を試してみよう" class="headerlink" title="Artifact Streaming を試してみよう"></a>Artifact Streaming を試してみよう</h2><p>実際に AKS クラスターへコンテナー イメージをデプロイして、Artifact Streaming によってイメージの Pull 時間が変化するかを試してみましょう。</p><p>今回の検証では、コンテナー イメージとして <code>docker.io/jupyter/all-spark-notebook:latest</code> を使用します。<br>AKS にデプロイをする前に、まずは手元の PC でイメージの Pull を試してみます。<br>次のように、多数のレイヤーによって構成されているコンテナー イメージであることがわかります。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull docker.io/jupyter/all-spark-notebook:latest</span></span><br><span class="line">latest: Pulling from jupyter/all-spark-notebook</span><br><span class="line">aece8493d397: Pull complete</span><br><span class="line">fd92c719666c: Pull complete</span><br><span class="line">088f11eb1e74: Pull complete</span><br><span class="line">4f4fb700ef54: Pull complete</span><br><span class="line">ef8373d600b0: Pull complete</span><br><span class="line">77e45ee945dc: Pull complete</span><br><span class="line">a30f89a0af6c: Download complete</span><br><span class="line">dc42adc7eb73: Download complete</span><br><span class="line">abaa8376a650: Downloading [==&gt;                                                ]  4.314MB/104.8MB</span><br><span class="line">aa099bb9e49a: Download complete</span><br><span class="line">822c4cbcf6a6: Download complete</span><br><span class="line">d25166dcdc7b: Downloading [====&gt;                                              ]  2.494MB/30.5MB</span><br><span class="line">964fc3e4ff9f: Waiting</span><br><span class="line">2c4c69587ee4: Waiting</span><br><span class="line">de2cdd875fa8: Waiting</span><br><span class="line">75d33599f5f2: Waiting</span><br><span class="line">31973ea82470: Waiting</span><br><span class="line">96ee7e4439c7: Waiting</span><br><span class="line">1f9ad23c07ac: Waiting</span><br><span class="line">d19266e0cb17: Waiting</span><br><span class="line">9a165b6e9dc7: Pulling fs layer</span><br><span class="line">5689442fd4e1: Pulling fs layer</span><br><span class="line">9a6a202f62a6: Waiting</span><br><span class="line">734ea0c3d94e: Waiting</span><br><span class="line">a21a167f7127: Waiting</span><br><span class="line">467e20fcd668: Waiting</span><br><span class="line">7024bb03412a: Waiting</span><br><span class="line">7c128e9d2ddd: Waiting</span><br><span class="line">80782ae10995: Waiting</span><br><span class="line">691924032e73: Waiting</span><br><span class="line">05c5a5d9ae5f: Waiting</span><br><span class="line">15a3d66e1b80: Waiting</span><br><span class="line">688c0dcd61fc: Waiting</span><br><span class="line">ed7d16094f4e: Waiting</span><br></pre></td></tr></table></figure><h3 id="Artifact-Streaming-を使用する準備"><a href="#Artifact-Streaming-を使用する準備" class="headerlink" title="Artifact Streaming を使用する準備"></a>Artifact Streaming を使用する準備</h3><p>本記事の手順は、次のドキュメントに記載されている手順に沿っています。<br>ドキュメントをあわせてご参照ください。</p><blockquote><p>Azure Kubernetes Service (AKS) の成果物ストリーミングを使用してイメージのプル時間を短縮する (プレビュー)<br><a href="https://learn.microsoft.com/ja-jp/azure/aks/artifact-streaming">https://learn.microsoft.com/ja-jp/azure/aks/artifact-streaming</a></p></blockquote><p>Artifact Streaming を利用するために、Azure Container Registry (ACR) のリポジトリを設定していきます。</p><p>はじめに、今回利用するコンテナーイメージを ACR にインポートします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr import -n &#123;ACR_NAME&#125; \</span></span><br><span class="line"><span class="bash">    --<span class="built_in">source</span> docker.io/jupyter/all-spark-notebook:latest \</span></span><br><span class="line"><span class="bash">    -t jupyter/all-spark-notebook:latest</span></span><br></pre></td></tr></table></figure><p>イメージのインポートが完了したら、Artifact Streaming を作成します。<br>作成にはしばらく時間がかかります。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr artifact-streaming create -n &#123;ACR_NAME&#125; \</span></span><br><span class="line"><span class="bash">    --image jupyter/all-spark-notebook:latest</span></span><br></pre></td></tr></table></figure><p><code>az acr artifact-streaming create</code> コマンドを実行すると、作成の進捗を確認するためのコマンド例が表示されます。<br><code>az acr artifact-streaming operation show</code> コマンドで進捗が確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr artifact-streaming operation show -n &#123;ACR_NAME&#125; \</span></span><br><span class="line"><span class="bash">    --repository jupyter/all-spark-notebook \</span></span><br><span class="line"><span class="bash">    --id d7ea8de0-1810-48a1-b9b8-ed7f667ae1f6</span></span><br><span class="line"></span><br><span class="line">Command group &#x27;acr artifact-streaming&#x27; is in preview and under development. Reference and support levels: https://aka.ms/CLI_refstatus</span><br><span class="line">&#123;</span><br><span class="line">  &quot;details&quot;: &quot;Conversion ongoing for resource jupyter/all-spark-notebook@sha256:b63bae2d9d34779ac969deeb4834efd838991f77269ca9a76bf6b0d1f8678d29&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;ArtifactStreamingConversion&quot;,</span><br><span class="line">  &quot;progress&quot;: &quot;8%&quot;,</span><br><span class="line">  &quot;resource&quot;: &quot;jupyter/all-spark-notebook@sha256:b63bae2d9d34779ac969deeb4834efd838991f77269ca9a76bf6b0d1f8678d29&quot;,</span><br><span class="line">  &quot;startTime&quot;: &quot;2023-12-07T07:27:12Z&quot;,</span><br><span class="line">  &quot;status&quot;: &quot;Running&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Artifact Streaming の作成が完了したら、レジストリに存在する Artifact Streaming の一覧を確認してみましょう。<br><code>az acr manifest list-referrers</code> コマンドに、レジストリ名とイメージ名を指定して実行します。<br><code>&quot;artifactType&quot;</code> が <code>&quot;application/vnd.azure.artifact.streaming.v1&quot;</code> となっていますね。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr manifest list-referrers -r &#123;ACR_NAME&#125; \</span></span><br><span class="line"><span class="bash">    -n jupyter/all-spark-notebook:latest</span></span><br><span class="line"></span><br><span class="line">Command group &#x27;acr manifest&#x27; is in preview and under development. Reference and support levels: https://aka.ms/CLI_refstatus</span><br><span class="line">&#123;</span><br><span class="line">  &quot;manifests&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;annotations&quot;: &#123;</span><br><span class="line">        &quot;streaming.format&quot;: &quot;overlaybd&quot;,</span><br><span class="line">        &quot;streaming.platform.arch&quot;: &quot;amd64&quot;,</span><br><span class="line">        &quot;streaming.platform.os&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;streaming.version&quot;: &quot;v1&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;artifactType&quot;: &quot;application/vnd.azure.artifact.streaming.v1&quot;,</span><br><span class="line">      &quot;digest&quot;: &quot;sha256:2cba83dae18f99b6c958e9e34421dadaeee0db1cde4adc0241180de80efd4f34&quot;,</span><br><span class="line">      &quot;mediaType&quot;: &quot;application/vnd.oci.image.manifest.v1+json&quot;,</span><br><span class="line">      &quot;size&quot;: 17266</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>続いて AKS 側の設定をします。<br>Artifact Streaming を利用するには、Artifact Streaming オプションを有効化した AKS ノードプールが必要になります。</p><p><code>az aks nodepool add</code> コマンドに <code>--enable-artifact-streaming</code> オプションを付与して、新しいノードプールを追加します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az aks nodepool add \</span></span><br><span class="line"><span class="bash">    --resource-group myResourceGroup \</span></span><br><span class="line"><span class="bash">    --cluster-name myAKSCluster \</span></span><br><span class="line"><span class="bash">    --name acrtest \</span></span><br><span class="line"><span class="bash">    --node-count 1 \</span></span><br><span class="line"><span class="bash">    --enable-artifact-streaming</span></span><br></pre></td></tr></table></figure><p>ここでは <code>acrtest</code> という名前でノードプールを追加しました。<br><code>kubectl get nodes</code> コマンドでノードの一覧を表示すると、新しいノードが追加されていることが確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">NAME                                STATUS   ROLES   AGE     VERSION</span><br><span class="line">aks-acrtest-29138108-vmss000000     Ready    agent   4h15m   v1.27.3</span><br><span class="line">aks-nodepool2-20356098-vmss00001d   Ready    agent   27h     v1.27.3</span><br></pre></td></tr></table></figure><p>これで ACR と AKS の準備は完了です！</p><h3 id="AKS-へのデプロイを試してみる"><a href="#AKS-へのデプロイを試してみる" class="headerlink" title="AKS へのデプロイを試してみる"></a>AKS へのデプロイを試してみる</h3><p>準備したコンテナー イメージを AKS クラスターにデプロイして、Artifact Streaming によってイメージの Pull 時間が短縮されているか確かめてみましょう。</p><p>検証では、Artifact Streaming が無効のノードプールと、有効のノードプールのそれぞれに、同じコンテナー イメージを使用する Deployment をデプロイします。</p><h4 id="Artifact-Streaming-が無効の場合"><a href="#Artifact-Streaming-が無効の場合" class="headerlink" title="Artifact Streaming が無効の場合"></a>Artifact Streaming が無効の場合</h4><p><code>nodeSelector</code> を使用して、Artifact Streaming が無効のノードプールに Pod をデプロイします。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jupyter</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">jupyter</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">jupyter</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">jupyter</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">&quot;agentpool&quot;:</span> <span class="string">nodepool2</span>  <span class="comment"># Artifact Streaming が無効のノードプール</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jupyter</span></span><br><span class="line">        <span class="attr">image:</span> &#123;<span class="string">ACR_NAME</span>&#125;<span class="string">.azurecr.io/jupyter/all-spark-notebook:latest</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>YAML マニフェストをクラスターにデプロイします。<br><code>jupyter-79c4469c65-5cfpf</code> Pod が生成されました。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                                          READY   STATUS    RESTARTS   AGE     IP            NODE                                NOMINATED NODE   READINESS GATES</span><br><span class="line">jupyter-79c4469c65-5cfpf                      1/1     Running   0          3m16s   10.244.0.19   aks-nodepool2-20356098-vmss00001i   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p><code>kubectl describe pod</code> コマンドの結果から、Events フィールドのメッセージを確認します。</p><p><code>Pulled</code> イベントでは、<code>Successfully pulled image &quot;&#123;イメージ名&#125;&quot; in 1m25.27926119s</code> のようにメッセージが表示されています。<br>イメージの Pull に 1分25秒 ほど要したようです。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod jupyter-79c4469c65-5cfpf</span></span><br><span class="line">Name:             jupyter-79c4469c65-5cfpf</span><br><span class="line">  ...</span><br><span class="line">Node:             aks-nodepool2-20356098-vmss00001i/10.240.0.4</span><br><span class="line">  ...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age    From               Message</span><br><span class="line">  ----    ------     ----   ----               -------</span><br><span class="line">  Normal  Scheduled  3m25s  default-scheduler  Successfully assigned default/jupyter-79c4469c65-5cfpf to aks-nodepool2-20356098-vmss00001i</span><br><span class="line">  Normal  Pulling    3m25s  kubelet            Pulling image &quot;&#123;ACR_NAME&#125;.azurecr.io/jupyter/all-spark-notebook:latest&quot;</span><br><span class="line">  Normal  Pulled     2m     kubelet            Successfully pulled image &quot;&#123;ACR_NAME&#125;.azurecr.io/jupyter/all-spark-notebook:latest&quot; in 1m25.27926119s (1m25.279277391s including waiting)</span><br><span class="line">  Normal  Created    2m     kubelet            Created container jupyter</span><br><span class="line">  Normal  Started    119s   kubelet            Started container jupyter</span><br></pre></td></tr></table></figure><h4 id="Artifact-Streaming-が有効の場合"><a href="#Artifact-Streaming-が有効の場合" class="headerlink" title="Artifact Streaming が有効の場合"></a>Artifact Streaming が有効の場合</h4><p>続いて Artifact Streaming を利用した場合の動作を確認してみましょう。</p><p><code>nodeSelector</code> を使用して、Artifact Streaming が有効のノードプールに Pod をデプロイします。<br>Pod 名やコンテナー名を変更していますが、使用するコンテナー イメージは先ほどと同じ <code>&#123;ACR_NAME&#125;.azurecr.io/jupyter/all-spark-notebook:latest</code> です。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jupyter-artifact-streaming</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">jupyter-artifact-streaming</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">jupyter-artifact-streaming</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">jupyter-artifact-streaming</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">&quot;agentpool&quot;:</span> <span class="string">acrtest</span>  <span class="comment"># Artifact Streaming が有効のノードプール</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jupyter</span></span><br><span class="line">        <span class="attr">image:</span> &#123;<span class="string">ACR_NAME</span>&#125;<span class="string">.azurecr.io/jupyter/all-spark-notebook:latest</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>YAML マニフェストをクラスターにデプロイします。<br><code>jupyter-artifact-streaming-5b58c9c797-pxs4l</code> Pod が生成されました。デプロイ先を指定したので、<code>acrtest</code>ノードプールのノードにデプロイされていますね。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                                          READY   STATUS    RESTARTS   AGE     IP            NODE                                NOMINATED NODE   READINESS GATES</span><br><span class="line">jupyter-79c4469c65-c8hm6                      1/1     Running   0          2m10s   10.244.1.24   aks-nodepool2-20356098-vmss00001d   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">jupyter-artifact-streaming-5b58c9c797-pxs4l   1/1     Running   0          6s      10.244.2.5    aks-acrtest-29138108-vmss000000     &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p><code>kubectl describe pod</code> コマンドの結果から、Events フィールドのメッセージを確認します。</p><p><code>Pulling</code> イベントでは、<code>Streaming enabled for &quot;&#123;イメージ名&#125;&quot;</code> のようにメッセージが表示されており、Artifact Streaming が利用されていることが確認できます。</p><p>また、<code>Pulled</code> イベントでは、<code>Successfully pulled image &quot;&#123;イメージ名&#125;&quot; in 3.442267417s</code> のようにメッセージが表示されています。<br>およそ 3.44 秒ほどでイメージ Pull が完了しました！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod jupyter-artifact-streaming-5b58c9c797-pxs4l</span></span><br><span class="line">Name:             jupyter-artifact-streaming-5b58c9c797-pxs4l</span><br><span class="line">  ...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age        From                                                   Message</span><br><span class="line">  ----    ------     ----       ----                                                   -------</span><br><span class="line">  Normal  Pulling    &lt;unknown&gt;  acr-nodemon, kubelet, aks-acrtest-29138108-vmss000000  Streaming enabled for &quot;&#123;ACR_NAME&#125;.azurecr.io/jupyter/all-spark-notebook:latest&quot;, upgraded to streaming artifact with digest &quot;sha256:2cba83dae18f99b6c958e9e34421dadaeee0db1cde4adc0241180de80efd4f34&quot;, container started in 5s</span><br><span class="line">  Normal  Scheduled  19s        default-scheduler                                      Successfully assigned default/jupyter-artifact-streaming-5b58c9c797-pxs4l to aks-acrtest-29138108-vmss000000</span><br><span class="line">  Normal  Pulling    19s        kubelet                                                Pulling image &quot;&#123;ACR_NAME&#125;.azurecr.io/jupyter/all-spark-notebook:latest&quot;</span><br><span class="line">  Normal  Pulled     15s        kubelet                                                Successfully pulled image &quot;&#123;ACR_NAME&#125;.azurecr.io/jupyter/all-spark-notebook:latest&quot; in 3.442267417s (3.442273818s including waiting)</span><br><span class="line">  Normal  Created    14s        kubelet                                                Created container jupyter</span><br><span class="line">  Normal  Started    14s        kubelet                                                Started container jupyter</span><br></pre></td></tr></table></figure><p>Artifact Streaming を使わない場合では 1分25秒 ほど要したため、大幅に短縮されていますね！</p><h3 id="Artifact-Streaming-を削除するには？"><a href="#Artifact-Streaming-を削除するには？" class="headerlink" title="Artifact Streaming を削除するには？"></a>Artifact Streaming を削除するには？</h3><p><code>az acr artifact-streaming delete</code> というコマンドは存在しないようです。</p><p>作成した Artifact Streaming を削除したい場合には、リポジトリに存在するイメージ自体を削除します。<br>イメージの削除にともない Artifact Streaming も一緒に削除されます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr repository delete -n &#123;ACR_NAME&#125; --repository jupyter/all-spark-notebook</span></span><br></pre></td></tr></table></figure><h3 id="どのようなしくみなのか？"><a href="#どのようなしくみなのか？" class="headerlink" title="どのようなしくみなのか？"></a>どのようなしくみなのか？</h3><p>Artifact Streaming を使うと、なぜイメージ Pull の時間が短縮されるのでしょうか？</p><p>Artifact Streaming では、OverlayBD イメージ フォーマットというオープンソースのソリューションを利用しています。</p><blockquote><p>ご参考) containerd/overlaybd<br><a href="https://github.com/containerd/overlaybd">https://github.com/containerd/overlaybd</a></p></blockquote><blockquote><p>ご参考) containerd/accelerated-container-image<br><a href="https://github.com/containerd/accelerated-container-image">https://github.com/containerd/accelerated-container-image</a></p></blockquote><p>OverlayBD は、アリババクラウドのコンテナーイメージ加速技術プロジェクト DADI で開発されました。</p><blockquote><p>DADI: Alibaba Cloud’s Open-Source Accelerated Container Image Technology<br><a href="https://www.alibabacloud.com/blog/dadi-alibaba-clouds-open-source-accelerated-container-image-technology_597956">https://www.alibabacloud.com/blog/dadi-alibaba-clouds-open-source-accelerated-container-image-technology_597956</a></p></blockquote><p>OverlayBD は、コンテナー イメージのレイヤーを仮想ブロック デバイスとして提供し、オーバーレイ ファイルシステムとしてマウントします。<br>コンテナーは、オーバーレイ ファイルシステムを通してイメージのデータにアクセスをします。<br>コンテナーの起動前にイメージ全体をダウンロードや展開することなく、必要なデータのみをネットワーク経由でオンデマンドに読み込むことができます。</p><p>ネットワーク ドライブに保存されたファイルを、手元のマシンに一度ダウンロードしてから開くのではなく、SMB/CIFS でマウントして直接開く様子に似ていますね。</p><p>Pod がデプロイされたノードにログインし、<code>df</code> コマンドを実行すると、出力結果の中に <code>io.containerd.snapshotter.v1.overlaybd</code> の文字列が含まれていることが確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@aks-acrtest-29138108-vmss000000:/# df -h | grep overlaybd</span><br><span class="line">/dev/sdc        252G  5.6G  234G   3% /var/lib/containerd/io.containerd.snapshotter.v1.overlaybd/snapshots/239/block/mountpoint</span><br></pre></td></tr></table></figure><hr><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>本記事では、Artifact Streaming の概要と、実際に AKS クラスターへコンテナーをデプロイした様子を紹介しました。<br>サイズの大きいコンテナー イメージを使用する Pod で起動時間を短縮したい場合に、利用を検討してみると良さそうです。</p><p>今回紹介しました Artifact Streaming が、今後の技術選定や AKS をよりご活用いただくうえでのご参考になりましたら幸いです。</p><p>Artifact Streaming は2023年12月現在、パブリック プレビューとして提供されております。ご利用いただきました際にお気づきの点やご要望などがございました際は、お気兼ねなくフィードバックいただけましたら幸いでございます。<br>また、AKS のご利用において、お困りの点やご不明点がありました際は、いつでも Azure サポートまでお気兼ねなくご相談ください。</p><hr><p>最後まで読んでいただきありがとうございました！<br><a href="https://qiita.com/advent-calendar/2023/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2023</a> は明日が最終日となります。是非ご覧くださいー！</p><p>本年は多くのお客様にお世話になりました。ありがとうございました。<br>来年もみなさまにとって素晴らしい年でありますように、心よりお祈り申し上げます。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;この記事は &lt;a href=&quot;https://qiita.com/advent-calendar/2023/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2023&lt;/a&gt; の 24 日目の記事になります🎅&lt;/p&gt;
&lt;p&gt;こんにちは。Azure テクニカル サポートチームの桐井です。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://techcommunity.microsoft.com/t5/apps-on-azure-blog/aks-welcomes-you-to-ignite-2023/ba-p/3983317&quot;&gt;Ignite 2023&lt;/a&gt; で、ACR/AKS 関連の機能としてArtifact Streaming が発表されました。&lt;br&gt;本記事では、Artifact Streaming を使って ACR にあるコンテナー イメージを AKS クラスターにデプロイする様子を紹介します。&lt;/p&gt;
&lt;p&gt;Artifact Streaming は 2023/12 現在、プレビュー機能として提供されております。&lt;br&gt;今後のアップデートにより、将来この記事で紹介した内容から変更される可能性があることを何卒ご了承ください！&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
    <category term="Azure Container Registry (ACR)" scheme="https://jpaztech.github.io/blog/tags/Azure-Container-Registry-ACR/"/>
    
  </entry>
  
  <entry>
    <title>ACR の Firewall 機能を有効にした状態で ACR の機能を用いてコンテナー イメージをビルドする方法について</title>
    <link href="https://jpaztech.github.io/blog/containers/acr-how-to-build-image-with-firewall/"/>
    <id>https://jpaztech.github.io/blog/containers/acr-how-to-build-image-with-firewall/</id>
    <published>2023-12-22T03:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.619Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は<a href="https://qiita.com/advent-calendar/2023/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2023</a> の 22 日目の記事になります。</p><p>こんにちは！ Azure テクニカル サポート チームの川畑です。<br>az acr buildコマンドを用いてコンテナー イメージをビルドする際に、ACR の Firewall 機能によって失敗するお問い合わせを頂きます。<br>この記事では、ACR のFirewall 機能を有効にした状態で ACR の機能を用いてコンテナー イメージをビルドする方法についてご紹介します。</p><span id="more"></span><hr><h2 id="ACR-のパブリック-ネットワーク-アクセス機能とは"><a href="#ACR-のパブリック-ネットワーク-アクセス機能とは" class="headerlink" title="ACR のパブリック ネットワーク アクセス機能とは"></a>ACR のパブリック ネットワーク アクセス機能とは</h2><p>ACR では、お客様のコンテナー イメージなど OCI アーティファクトをより安全に管理いただくために、ACR にアクセス可能な端末を制限するためのパブリック ネットワーク アクセス機能を提供しております。<br>パブリック ネットワーク アクセスの設定には、次の3 種類があります。</p><ul><li><p>「すべてのネットワーク」<br>名前の通りネットワーク レベルでの制限を実施いたしません。<br>そのため、インターネット経由でのアクセスを受け付けることが可能となります。</p></li><li><p>「選択されたネットワーク」<br>ACR の Firewall 機能を用いて、IP アドレス ベースでのアクセス制限を設けることが可能となります。<br>なお、ここで許可可能な IP アドレスの形式は CIDR 形式となっているため、IP アドレス レンジを許可することなども可能となります。</p><div class="alert is-warning"><p class="alert-title">警告</p><p>許可可能な IP 規則は最大 100 個までとなります。</br></p><p>　ご参考情報：パブリック IP ネットワーク ルールを構成する </br></p><p>　<a href="https://learn.microsoft.com/ja-jp/azure/container-registry/container-registry-access-selected-networks">https://learn.microsoft.com/ja-jp/azure/container-registry/container-registry-access-selected-networks</a> </br></p></div><div class="alert is-warning"><p class="alert-title">警告</p><p>この設定を入れることによって、Azure Portal からリポジトリの情報を参照できなくなる 場合があります。</br></p><p>これは、Azure Portal を用いて ACR へアクセスしているクライアント端末の IP アドレスが許可されていないためとなります。</br></p><p>そのため、Azure Portal より ACR 内の情報を参照する必要がある場合には、クライアント端末のパブリック IP アドレスを許可してください。</p></div></li><li><p>「無効」<br>名前の通りパブリック IP アドレス経由でのアクセスを全て防ぐことが可能となります。<br>この設定だけでは、ACR にアクセス可能な端末が存在しなくなるため、あわせてプライベート エンドポイントを経由したアクセスを可能なように構成いただく必要があります。<br>下記ドキュメントに設定方法がまとまっておりますので、あわせてご参照ください。<br>　ご参考情報：Azure Private Link を使用して Azure Container Registry にプライベートで接続する<br>　<a href="https://learn.microsoft.com/ja-jp/azure/container-registry/container-registry-private-link">https://learn.microsoft.com/ja-jp/azure/container-registry/container-registry-private-link</a></p></li></ul><h2 id="ACR-ビルドとは"><a href="#ACR-ビルドとは" class="headerlink" title="ACR ビルドとは"></a>ACR ビルドとは</h2><p>ACR ビルドとは、お客様のクライアント端末上ではなく、Azure が管理している各リージョンに存在する ACR 用のエージェントを用いてコンテナー イメージを作成する機能となります。</p><p>この機能を用いることで、お客様のクライアント端末にて Docker などのコンテナー ランタイムをインストールすることなく、Azure が用意しているエージェントを用いてコンテナー イメージを作成、ACR へプッシュすることが出来ます。</p><p>下記 は ACR ビルドの実行結果の一例となります。<br>今回の例では、 外部のコンテナー レジストリー (mcr.microsoft.com) より hello-world というコンテナー イメージを取得し、起動する Docker イメージを作成、ACR へプッシュします。</p><p>まずは、Docker イメージを作成するために Dockerfile を用意します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;FROM mcr.microsoft.com/hello-world&quot;</span> &gt; Dockerfile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat Dockerfile</span> </span><br><span class="line">FROM mcr.microsoft.com/hello-world</span><br></pre></td></tr></table></figure><p>それでは、この Dockerfile を基に ACR ビルドを使って Docker イメージの作成、ACR へプッシュを行います。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr build --registry blogbuildtest --image buildtest/hello-world:v1 --file Dockerfile .</span></span><br><span class="line">Packing source code into tar to upload...</span><br><span class="line">Uploading archived source code from &#x27;/tmp/build_archive_6d41a3f0c1e24e1cbac736d1b271ad6c.tar.gz&#x27;...</span><br><span class="line">Sending context (345.000 Bytes) to registry: blogbuildtest...</span><br><span class="line">Queued a build with ID: ca1</span><br><span class="line">Waiting for an agent...</span><br><span class="line">2023/12/11 05:16:49 Downloading source code...</span><br><span class="line">2023/12/11 05:16:49 Finished downloading source code</span><br><span class="line">2023/12/11 05:16:50 Using acb_vol_4cfc16ec-0963-4b43-8581-f87207679198 as the home volume</span><br><span class="line">2023/12/11 05:16:50 Setting up Docker configuration...</span><br><span class="line">2023/12/11 05:16:50 Successfully set up Docker configuration</span><br><span class="line">2023/12/11 05:16:50 Logging in to registry: blogbuildtest.azurecr.io</span><br><span class="line">2023/12/11 05:16:51 Successfully logged into blogbuildtest.azurecr.io</span><br><span class="line">2023/12/11 05:16:51 Executing step ID: build. Timeout(sec): 28800, Working directory: &#x27;&#x27;, Network: &#x27;&#x27;</span><br><span class="line">2023/12/11 05:16:51 Scanning for dependencies...</span><br><span class="line">2023/12/11 05:16:51 Successfully scanned dependencies</span><br><span class="line">2023/12/11 05:16:51 Launching container with name: build</span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line">Step 1/1 : FROM mcr.microsoft.com/hello-world</span><br><span class="line">latest: Pulling from hello-world</span><br><span class="line">1b930d010525: Pulling fs layer</span><br><span class="line">1b930d010525: Verifying Checksum</span><br><span class="line">1b930d010525: Download complete</span><br><span class="line">1b930d010525: Pull complete</span><br><span class="line">Digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">Status: Downloaded newer image for mcr.microsoft.com/hello-world:latest</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> fce289e99eb9</span></span><br><span class="line">Successfully built fce289e99eb9</span><br><span class="line">Successfully tagged blogbuildtest.azurecr.io/buildtest/hello-world:v1</span><br><span class="line">2023/12/11 05:16:52 Successfully executed container: build</span><br><span class="line">2023/12/11 05:16:52 Executing step ID: push. Timeout(sec): 3600, Working directory: &#x27;&#x27;, Network: &#x27;&#x27;</span><br><span class="line">2023/12/11 05:16:52 Pushing image: blogbuildtest.azurecr.io/buildtest/hello-world:v1, attempt 1</span><br><span class="line">The push refers to repository [blogbuildtest.azurecr.io/buildtest/hello-world]</span><br><span class="line">af0b15c8625b: Preparing</span><br><span class="line">af0b15c8625b: Pushed</span><br><span class="line">v1: digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a size: 524</span><br><span class="line">2023/12/11 05:16:54 Successfully pushed image: blogbuildtest.azurecr.io/buildtest/hello-world:v1</span><br><span class="line">2023/12/11 05:16:54 Step ID: build marked as successful (elapsed time in seconds: 1.093391)</span><br><span class="line">2023/12/11 05:16:54 Populating digests for step ID: build...</span><br><span class="line">2023/12/11 05:16:54 Successfully populated digests for step ID: build</span><br><span class="line">2023/12/11 05:16:54 Step ID: push marked as successful (elapsed time in seconds: 1.829038)</span><br><span class="line">2023/12/11 05:16:54 The following dependencies were found:</span><br><span class="line">2023/12/11 05:16:54 </span><br><span class="line">- image:</span><br><span class="line">    registry: blogbuildtest.azurecr.io</span><br><span class="line">    repository: buildtest/hello-world</span><br><span class="line">    tag: v1</span><br><span class="line">    digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">  runtime-dependency:</span><br><span class="line">    registry: mcr.microsoft.com</span><br><span class="line">    repository: hello-world</span><br><span class="line">    tag: latest</span><br><span class="line">    digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">  git: &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Run ID: ca1 was successful after 6s</span><br></pre></td></tr></table></figure><p>しかしながら、上述の通り、ACR ビルドは Azure にて管理している各リージョンに存在する ACR 用のエージェントによってコンテナー イメージの作成、ACR へのプッシュをする機能であるため、<strong>ACR 用のエージェントからお客様の ACR へのアクセス</strong>が行われます。</p><p>このアクセスには、パブリック IP アドレスが使われているため、ACR の Firewall 機能を用いてパブリック アクセスを防がれている ACR へのアクセスが失敗することが予想されます。</p><p>試しに Azure VM を用意し、この Azure VM が利用しているパブリック IP アドレスを ACR の Firewall 機能によって許可します。</p><p>この設定の場合、Azure VM から ACR への通信は成功するため、ACR からコンテナー イメージの取得等は実行できますが、ACR ビルドは失敗します。</p><p>作成した Azure VM は以下の通りであり、割り当てられたパブリック IP アドレスは 4.xxx.xxx.xxx となります。</p><p><img src="/blog/containers/acr-how-to-build-image-with-firewall/vm_information.png"><br>それでは、この IP アドレスを ACR の Firewall 機能で許可します。</p><p><img src="/blog/containers/acr-how-to-build-image-with-firewall/acr_information.png"><br>では、Azure VM に SSH をして、Docker イメージを ACR から取得してみます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull blogbuildtest.azurecr.io/buildtest/hello-world:v1</span></span><br><span class="line">v1: Pulling from buildtest/hello-world</span><br><span class="line">1b930d010525: Pull complete</span><br><span class="line">Digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">Status: Downloaded newer image for blogbuildtest.azurecr.io/buildtest/hello-world:v1</span><br><span class="line">blogbuildtest.azurecr.io/buildtest/hello-world:v1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker images</span></span><br><span class="line">REPOSITORY                                       TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">blogbuildtest.azurecr.io/buildtest/hello-world   v1        fce289e99eb9   4 years ago   1.84kB</span><br></pre></td></tr></table></figure><p>docker pull コマンドによってコンテナー イメージを ACR から取得出来ました。<br>次に ACR ビルドを使ってコンテナー イメージの作成をしてみます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr build --registry blogbuildtest --image buildtestfromvm/hello-world:v1 --file Dockerfile .</span></span><br><span class="line">Packing source code into tar to upload...</span><br><span class="line">Uploading archived source code from &#x27;/tmp/build_archive_ba9f4b643e5b4b79b251d6213e8abd99.tar.gz&#x27;...</span><br><span class="line">Sending context (26.336 KiB) to registry: blogbuildtest...</span><br><span class="line">Queued a build with ID: ca2</span><br><span class="line">Waiting for an agent...</span><br><span class="line">2023/12/11 06:06:48 Downloading source code...</span><br><span class="line">2023/12/11 06:06:48 Finished downloading source code</span><br><span class="line">2023/12/11 06:06:48 Using acb_vol_f6e0b320-1247-4584-b5c3-c620a4d138e5 as the home volume</span><br><span class="line">2023/12/11 06:06:48 Setting up Docker configuration...</span><br><span class="line">2023/12/11 06:06:49 Successfully set up Docker configuration</span><br><span class="line">2023/12/11 06:06:49 Logging in to registry: blogbuildtest.azurecr.io</span><br><span class="line">failed to login, ran out of retries: failed to set docker credentials: Error response from daemon: Get &quot;https://blogbuildtest.azurecr.io/v2/&quot;: denied: client with IP &#x27;52.xxx. xxx.  xxx &#x27; is not allowed access. Refer https://aka.ms/acr/firewall to grant access.</span><br><span class="line">: exit status 1</span><br><span class="line">Run ID: ca2 failed after 5s. Error: failed during run, err: exit status 1</span><br><span class="line">Run failed</span><br></pre></td></tr></table></figure><p>予想通り Failed となることが確認できました。<br>なお、この IP アドレス 52.xxx.xxx.xxx が ACR のエージェントが利用しているパブリック IP アドレスとなり、このパブリック IP アドレスが許可されていないことから処理が失敗したことが確認できました。</p><h2 id="ACR-ビルドの代替策"><a href="#ACR-ビルドの代替策" class="headerlink" title="ACR ビルドの代替策"></a>ACR ビルドの代替策</h2><p>前置きが長くなってしまいましたが、上述のように ACR ビルドを用いてコンテナー イメージを作成する場合、ACR の Firewall 機能によってアクセスが防がれてしまう場合があります。<br>この回避策としては、以下の方法が挙げられます。</p><ol><li><p>パブリック ネットワーク アクセスの設定を「すべてのネットワーク」に変更する<br>ACR のエージェントが ACR へアクセスする際に使用しているパブリック IP アドレスが許可されていないことで本事象は発生するため、インターネットからのアクセスを全て受け付けるよう変更いただくことで事象が改善します。</p></li><li><p>ACR のエージェントが利用するパブリック IP アドレスを許可する<br>ACR のエージェントが利用するパブリック IP アドレスを「選択されたネットワーク」の IP 規則に追加する方法が挙げられます。<br>Azure では、下記サイトにて  Azure の各サービスが利用する IP アドレスを公開しているため、こちらの AzureContainerRegistry.<region> の IP アドレスを追加いただくことで事象が改善することが想定されます。<br>　ご参考情報：Download Azure IP Ranges and Service Tags – Public Cloud from Official Microsoft Download Center<br>　<a href="https://www.microsoft.com/en-us/download/confirmation.aspx?id=56519">https://www.microsoft.com/en-us/download/confirmation.aspx?id=56519</a></p><div class="alert is-warning"><p class="alert-title">警告</p><p>ACR 含め Azure が利用するパブリック IP アドレスは動的なものであり、今後変更される可能性があります。</p><p>そのため、定期的もしくはアクセスが失敗するようになりましたら、最新の ACR のパブリック IP アドレスをご確認・更新いただく必要があります。</p></div></li><li><p>ACR タスクを利用する<br>ACR の Firewall 機能では、「信頼されたサービス」のアクセスについては別途 IP 規則を追加いただくことなく、アクセスを許可することが可能となります。<br>そして、この 「信頼されたサービス」に、下記ドキュメントに記載の通り ACR タスクが登録されています。<br>　ご参考情報：信頼できるサービス<br>　<a href="https://learn.microsoft.com/ja-jp/azure/container-registry/allow-access-trusted-services#trusted-services">https://learn.microsoft.com/ja-jp/azure/container-registry/allow-access-trusted-services#trusted-services</a> </p><p>ACR タスクは、ACR ビルドの制御等を行うことができ、ACR ビルド同様にコンテナー イメージの作成を行うことが可能となります。<br>そのため、ACR ビルドの代替方法として ACR タスクをご利用いただくことで ACR の Firewall 機能でパブリック アクセスを防いだまま ACR の機能によってコンテナー イメージを作成することが可能となります。<br>次のセクションにて ACR タスクを使ったコンテナー イメージの作成方法について紹介します。</p></li></ol><h2 id="ACR-タスクのご紹介"><a href="#ACR-タスクのご紹介" class="headerlink" title="ACR タスクのご紹介"></a>ACR タスクのご紹介</h2><p>上述の通り、ACR タスクでは、ACR ビルドと同様に ACR の機能を使ってコンテナー イメージを作成することが可能となります。<br>それでは、早速 ACR タスクを使って Firewall 機能を有効化した ACR に対してコンテナー イメージの作成、プッシュをしてみます。</p><p>なお、おおまかな手順につきましては、下記ドキュメントにて記載されています。<br>こちらを参考に実施してみます。<br>　ご参考情報：例:ACR タスク<br>　<a href="https://learn.microsoft.com/ja-jp/azure/container-registry/allow-access-trusted-services#example-acr-tasks">https://learn.microsoft.com/ja-jp/azure/container-registry/allow-access-trusted-services#example-acr-tasks</a></p><p>ACR タスクを作成する前に事前準備が必要となります。</p><p>ACR ビルドでは、コンテナー イメージの作成に使用していた Dockerfile を az acr build コマンドを実行したクライアント端末に存在していましたが、ACR タスクでは ACR のエージェントにてアクセスが可能な場所に配置する必要があります。<br>ここでは、Dockerfile を ACR 上に配置し、ACR 上に配置した Dockerfile を ACR タスクより使用してコンテナー イメージを作成してみます。</p><p>ACR に Dockerfile を配置するにあたり、オープン ソースにて開発がされている ORAS を使用します。<br>簡単な使用方法につきましては、下記ドキュメントでも紹介されておりますので、ご参考ください。<br>　ご参考情報：Azure コンテナー レジストリを使って OCI 成果物をプッシュおよびプルする<br>　<a href="https://learn.microsoft.com/ja-jp/azure/container-registry/container-registry-oci-artifact">https://learn.microsoft.com/ja-jp/azure/container-registry/container-registry-oci-artifact</a></p><p>それでは、ORAS を使って Dockerfile を ACR にプッシュします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> oras push blogbuildtest.azurecr.io/hello-world.dockerfile:1.0 Dockerfile</span></span><br></pre></td></tr></table></figure><p>今回は hello-world.dockerfile というリポジトリとしてプッシュしました。<br>では、この hello-world.dockerfile を用いるよう ACR タスクを作成してみます。<br>コマンドは下記のような形式となります。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr task create -t &lt;イメージ名&gt; --registry &lt;ACR 名&gt; --name &lt;タスク名&gt; --context oci://&lt;ACR 名&gt;.azurecr.io/&lt;Dockerfile の OCI アーティファクト名&gt;:&lt;Tag&gt;  --file &lt;Dockerfile名&gt; --assign-identity &lt;[system] | マネージド ID のリソース ID&gt; -g &lt;リソース グループ名&gt;</span></span><br></pre></td></tr></table></figure><p>今回の環境では、下記のコマンドとなります。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr task create -t helloworld --registry blogbuildtest --name helloworldtask  --context oci://blogbuildtest.azurecr.io/hello-world.dockerfile:1.0  --file hello-world.dockerfile --assign-identity [system]</span></span><br></pre></td></tr></table></figure><p>なお、「信頼されたサービス」を利用してアクセスを行う場合には、ACR タスクにマネージド ID を利用する必要があります。</p><p>先ほど実行したコマンドにて、今回作成した ACR タスクにはシステム割り当てマネージド ID を利用するよう設定しているため、このシステム割り当てマネージド ID に必要な権限 (ACRPUSH) を割り当てます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> principalID=$(az acr task show --name helloworldtask --registry tasktest --query identity.principalId --output tsv -g blog</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> baseregID=$(az acr show --name blogbuildtest --query id --output tsv -g blog )</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> az role assignment create --assignee <span class="variable">$principalID</span> --scope <span class="variable">$baseregID</span> --role acrpush</span></span><br></pre></td></tr></table></figure><p>次に、ACR タスク “helloworldtask” に対して  ACR “blogbuildtest” へのアクセスにマネージド ID を利用するよう設定を行います。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr task credential add --name helloworldtask --registry blogbuildtest --login-server blogbuildtest.azurecr.io --use-identity [system] -g blog</span></span><br></pre></td></tr></table></figure><p>これで準備は完了です。それでは、ACR タスクを実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr task run --name helloworldtask --registry blogbuildtest -g blog                                                                                              Queued a run with ID: cad</span></span><br><span class="line">Waiting for an agent...</span><br><span class="line">2023/12/14 19:29:42 Downloading source code...</span><br><span class="line">2023/12/14 19:29:45 Finished downloading source code</span><br><span class="line">2023/12/14 19:29:45 Using acb_vol_efd7cb79-502a-47b0-8e44-9689138ae1cb as the home volume</span><br><span class="line">2023/12/14 19:29:46 Setting up Docker configuration...</span><br><span class="line">2023/12/14 19:29:46 Successfully set up Docker configuration</span><br><span class="line">2023/12/14 19:29:46 Logging in to registry: blogbuildtest.azurecr.io</span><br><span class="line">2023/12/14 19:29:47 Successfully logged into blogbuildtest.azurecr.io</span><br><span class="line">2023/12/14 19:29:47 Executing step ID: build. Timeout(sec): 28800, Working directory: &#x27;&#x27;, Network: &#x27;&#x27;</span><br><span class="line">2023/12/14 19:29:47 Scanning for dependencies...</span><br><span class="line">2023/12/14 19:29:47 Successfully scanned dependencies</span><br><span class="line">2023/12/14 19:29:47 Launching container with name: build</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/1 : FROM mcr.microsoft.com/hello-world</span><br><span class="line">latest: Pulling from hello-world</span><br><span class="line">1b930d010525: Pulling fs layer</span><br><span class="line">1b930d010525: Verifying Checksum</span><br><span class="line">1b930d010525: Download complete</span><br><span class="line">1b930d010525: Pull complete</span><br><span class="line">Digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">Status: Downloaded newer image for mcr.microsoft.com/hello-world:latest</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> fce289e99eb9</span></span><br><span class="line">Successfully built fce289e99eb9</span><br><span class="line">Successfully tagged blogbuildtest.azurecr.io/helloworld:latest</span><br><span class="line">2023/12/14 19:29:48 Successfully executed container: build</span><br><span class="line">2023/12/14 19:29:48 Executing step ID: push. Timeout(sec): 3600, Working directory: &#x27;&#x27;, Network: &#x27;&#x27;</span><br><span class="line">2023/12/14 19:29:48 Pushing image: blogbuildtest.azurecr.io/helloworld:latest, attempt 1</span><br><span class="line">The push refers to repository [blogbuildtest.azurecr.io/helloworld]</span><br><span class="line">af0b15c8625b: Preparing</span><br><span class="line">af0b15c8625b: Layer already exists</span><br><span class="line">latest: digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a size: 524</span><br><span class="line">2023/12/14 19:29:49 Successfully pushed image: blogbuildtest.azurecr.io/helloworld:latest</span><br><span class="line">2023/12/14 19:29:49 Step ID: build marked as successful (elapsed time in seconds: 1.140930)</span><br><span class="line">2023/12/14 19:29:49 Populating digests for step ID: build...</span><br><span class="line">2023/12/14 19:29:49 Successfully populated digests for step ID: build</span><br><span class="line">2023/12/14 19:29:49 Step ID: push marked as successful (elapsed time in seconds: 0.898327)</span><br><span class="line">2023/12/14 19:29:49 The following dependencies were found:</span><br><span class="line">2023/12/14 19:29:49</span><br><span class="line">- image:</span><br><span class="line">    registry: blogbuildtest.azurecr.io</span><br><span class="line">    repository: helloworld</span><br><span class="line">    tag: latest</span><br><span class="line">    digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">  runtime-dependency:</span><br><span class="line">    registry: mcr.microsoft.com</span><br><span class="line">    repository: hello-world</span><br><span class="line">    tag: latest</span><br><span class="line">    digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">  git: &#123;&#125;</span><br><span class="line"></span><br><span class="line">Run ID: cad was successful after 8s</span><br></pre></td></tr></table></figure><p>これで、Firewall を有効化している ACR に対して、ACR タスクを用いてコンテナー イメージを作成することが出来ました。</p><h3 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h3><p>この記事では、ACR のFirewall 機能を有効にした状態で ACR の機能を用いてコンテナー イメージをビルドする方法をご紹介しました。<br>ご参考にいただけますと幸いです。</p><p>本稿が皆様のお役に立ちましたら幸いです。</p><p>最後まで読んでいただきありがとうございました！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;この記事は&lt;a href=&quot;https://qiita.com/advent-calendar/2023/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2023&lt;/a&gt; の 22 日目の記事になります。&lt;/p&gt;
&lt;p&gt;こんにちは！ Azure テクニカル サポート チームの川畑です。&lt;br&gt;az acr buildコマンドを用いてコンテナー イメージをビルドする際に、ACR の Firewall 機能によって失敗するお問い合わせを頂きます。&lt;br&gt;この記事では、ACR のFirewall 機能を有効にした状態で ACR の機能を用いてコンテナー イメージをビルドする方法についてご紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Container Registry (ACR)" scheme="https://jpaztech.github.io/blog/tags/Azure-Container-Registry-ACR/"/>
    
  </entry>
  
  <entry>
    <title>マネージドディスクとスナップショットのネットワーク設定について</title>
    <link href="https://jpaztech.github.io/blog/vm/network-setting-of-disk-and-snapshot/"/>
    <id>https://jpaztech.github.io/blog/vm/network-setting-of-disk-and-snapshot/</id>
    <published>2023-12-18T08:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.955Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>マネージドディスクとスナップショットのネットワーク設定について、どういったものであるかといった点をお問い合わせいただくことがございますので、この点を解説させていただきます。</p><hr><h2 id="マネージドディスクとスナップショットのネットワーク設定"><a href="#マネージドディスクとスナップショットのネットワーク設定" class="headerlink" title="マネージドディスクとスナップショットのネットワーク設定"></a>マネージドディスクとスナップショットのネットワーク設定</h2><p>マネージドディスクやスナップショットを新規作成する際に、作成画面にて以下のように「ネットワーク」というタブで、ネットワーク設定をすることができます。<br>（作成後に、後から編集することも可能です。）  </p><p><img src="/blog/vm/network-setting-of-disk-and-snapshot/2023-12-12-14-03-30.png"></p><p>既定では、「すべてのネットワークからのパブリック アクセスを有効にする」となっておりますため、「ディスクに対し外部から不正アクセスされてしまうのでは？」というお問い合わせをいただくこともございます。<br>このネットワークの設定は<strong>マネージドディスクとスナップショットのエクスポート/インポートをする際に、アクセス許可をするネットワークを設定する</strong>ものとなっております。<br>すなわち、明示的にエクスポート URL の生成を行わない場合は、パブリック上の不特定多数からディスクにアクセスされるといったことはございませんのでご安心ください。<br>また Azure VM から接続されているマネージドディスクへの通信に影響を及ぼす設定でもございません。  </p><blockquote><p>■ご参考：マネージド ディスクがインポートまたはエクスポートされる操作を制限する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-restrict-import-export-overview">https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-restrict-import-export-overview</a></p></blockquote><hr><h2 id="マネージドディスク-スナップショットのエクスポートについて"><a href="#マネージドディスク-スナップショットのエクスポートについて" class="headerlink" title="マネージドディスク / スナップショットのエクスポートについて"></a>マネージドディスク / スナップショットのエクスポートについて</h2><p>マネージドディスクとスナップショットは以下の通り、ポータル等でエクスポート URL を発行し、VHD ファイルとしてダウンロードを行うといったことが可能です。<br>セキュリティ上の観点より、明示的にエクスポート URL を発行しない場合はエクスポートはできず、URL も有効期限を設ける必要がございます。  </p><p><img src="/blog/vm/network-setting-of-disk-and-snapshot/2023-12-12-14-05-35.png"></p><blockquote><p>■ご参考：Azure から Windows VHD をダウンロードする<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/download-vhd">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/download-vhd</a></p></blockquote><blockquote><p>■ご参考：Azure から Linux VHD をダウンロードする<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/download-vhd">https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/download-vhd</a></p></blockquote><p>この際、マネージドディスクおよびスナップショットのネットワーク設定にて既定の「すべてのネットワークからのパブリック アクセスを有効にする」という設定にしている場合、エクスポート URL があればどのパブリックネットワークからも VHD のダウンロード等が可能となります。<br>しかしながら、万が一悪意のあるユーザーにエクスポート URL が入手されてしまった場合にも VHD ダウンロードを不可とさせるための設定として、  </p><ul><li>パブリック アクセスを無効にし、プライベート アクセスを有効にする</li><li>パブリック アクセスとプライベート アクセスを無効にする</li></ul><p>というオプションもご用意しているといったこととなります。  </p><p>「パブリック アクセスを無効にし、プライベート アクセスを有効にする」の設定とした場合は、エクスポート URL があったとしてもパブリックネットワークからのアクセスはできず、Azure 仮想ネットワーク上のクライアントからプライベート リンクを介してでないとアクセスできないといった、よりセキュリティの高い設定となります。<br>この点詳細については以下の公開ドキュメントをご参照ください。  </p><blockquote><p>■ご参考：Azure Private Link を使用してマネージド ディスクに対するインポートおよびエクスポートのアクセスを制限する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-enable-private-links-for-import-export-portal">https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-enable-private-links-for-import-export-portal</a></p></blockquote><p>「パブリック アクセスとプライベート アクセスを無効にする」の設定にした場合は、エクスポート URL の発行自体が不可になります。  </p><p>上記、エクスポートを例として記載しましたが以下のマネージドディスクに対する VHD インポートについても同じようにネットワークの制限の設定か可能です。</p><blockquote><p>■ご参考：お使いの VHD をアップロードする<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/managed-disks-overview#upload-your-vhd">https://learn.microsoft.com/ja-jp/azure/virtual-machines/managed-disks-overview#upload-your-vhd</a></p></blockquote><hr><p>上述の通り、こちらのネットワーク設定はあくまでエクスポート/インポート時のネットワーク制限の設定を行うものである点、ご理解賜りますと幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;マネージドディスクとスナップショットのネットワーク設定について、どういったものであるかといった点をお問い合わせいただくことがございますので、この点を解説させていただきます。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 i</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Disk" scheme="https://jpaztech.github.io/blog/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title>AKSノード上でのOOMKillの挙動と調査方法</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-oom-202312/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-oom-202312/</id>
    <published>2023-12-17T03:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.663Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は<a href="https://qiita.com/advent-calendar/2023/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2023</a> の 17 日目の記事になります。</p><p>こんにちは、 Azure テクニカル サポート チームの高田です。<br>AKS(に限らず、Kubernetes全般)を利用する際に難しいことの一つとして、メモリの割り当てや制限の管理があります。<br>ノードやその上のメモリ(を確保するための予算)にも限りがあるので<br>必要十分で済ませようとしたものの、思わぬときにOOMKillでワークロードに<br>影響が発生した、という経験をされた方も多いかと思います。</p><p>この記事では、OOMKillが発生したときにせめて速やかに対処できるよう、<br>OOMKillの際の挙動やこれに基づく原因調査方法について<br>いくつかのトピックを紹介させて頂きます。</p><h2 id="扱うトピック、扱わないトピック"><a href="#扱うトピック、扱わないトピック" class="headerlink" title="扱うトピック、扱わないトピック"></a>扱うトピック、扱わないトピック</h2><p>本記事では、AKSノード上に配置されたPodのメモリ利用に起因してOOMKillが発生した場合の<br>挙動や、原因の調査方法を紹介します。</p><p>そもそもノードのリソース不足でPodがスケジューリングされない(Pendingのままとなる)場合につきましては<br>スコープ外とさせて頂きますのでご了承下さい。</p><h2 id="2種類のメモリ利用制限"><a href="#2種類のメモリ利用制限" class="headerlink" title="2種類のメモリ利用制限"></a>2種類のメモリ利用制限</h2><p>AKSノード上でPodがメモリを確保・利用する際、Pod・コンテナーレベル、<br>ノードレベルの2つの観点にて利用量が制限されます。OOMKillは各レベルで発生し得ます。</p><h3 id="Pod・コンテナーレベルでの制限・OOMKill"><a href="#Pod・コンテナーレベルでの制限・OOMKill" class="headerlink" title="Pod・コンテナーレベルでの制限・OOMKill"></a>Pod・コンテナーレベルでの制限・OOMKill</h3><p>Pod内のコンテナーが確保・利用可能なメモリの上限は、Podのmanifest(YAML)中の<br><code>spec.containers[].resources.limits.memory</code>にて指定できます。<br>コンテナーがこの制限を超えてメモリを確保・利用しようとした場合に、OOMKillが発生します。</p><p>(設定方法や考え方については下記のドキュメント等をご参照下さい)</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/developer-best-practices-resource-management">Azure Kubernetes Service (AKS) でリソースを管理するアプリケーション開発者のベスト プラクティス</a></p><p><a href="https://kubernetes.io/ja/docs/tasks/configure-pod-container/assign-memory-resource/">コンテナおよびPodへのメモリーリソースの割り当て</a></p><p><a href="https://kubernetes.io/ja/docs/concepts/configuration/manage-resources-containers/">コンテナのリソース管理</a></p><h3 id="ノードレベルでの制限・OOMKill"><a href="#ノードレベルでの制限・OOMKill" class="headerlink" title="ノードレベルでの制限・OOMKill"></a>ノードレベルでの制限・OOMKill</h3><p>Podがノードにスケジュールされる際、ノードが提供可能なメモリが<br>Pod・コンテナーに対して十分か否かの判定は、<code>spec.containers[].resources.limits.memory</code><br>(制限)ではなく、<code>spec.containers[].resources.limits.memory</code>(要求)に基づいて<br>行われます。このため、あるノード上にスケジュールされたPod・コンテナーの<br>制限値の合計が、実際にそのノード上で利用可能なメモリ量よりはるかに多い、ということが<br>起こり得ます。</p><p>この場合、まず、 Pod・コンテナーによるメモリ使用量の合計が割り当て可能(Allocatable)な<br>メモリ量を超えた時点で、evict(退去)によるメモリ逼迫の解消が試みられます。<br>ただ、evict(退去)が間に合わず、メモリ使用量が割り当て可能なメモリ量 + eviction-threshold<br>の値を超過した場合に、ノードレベルでのOOMKillが発生します。</p><p>割り当て可能なメモリ量は、ノードに搭載されている(=VMサイズにて提供される)<br>メモリ量から、 kube-reserved, system-reserved, 前述のeviction-thresholdの値を<br>引いた値となっています。</p><p><a href="https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable">Reserve Compute Resources for System Daemons: Node Allocatable</a></p><p>AKS(Kubernetes バージョン1.28以下)の場合、eviction-thresholdは750MiB、kube-reservedは<br>ノードに搭載されているメモリ量に基づき一定の法則にて算出された値の量となります。<br>(system-reservedは定義されていません)</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/concepts-clusters-workloads#memory">Azure Kubernetes Services (AKS) における Kubernetes の中心概念:<br>メモリ</a></p><p>ノードに搭載されているメモリ量、割り当て可能な量は各々、<code>kubectl describe node</code>コマンドの出力中の<br>Capacityの項、Allocatableの項などにて確認できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe node &lt;ノード名&gt;</span><br><span class="line">(略)</span><br><span class="line">Capacity:</span><br><span class="line">  cpu:                2</span><br><span class="line">  ephemeral-storage:  129886128Ki</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             4007948Ki</span><br><span class="line">  pods:               110</span><br><span class="line">Allocatable:</span><br><span class="line">  cpu:                1900m</span><br><span class="line">  ephemeral-storage:  119703055367</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             2191372Ki</span><br><span class="line">  pods:               110</span><br><span class="line">(略)</span><br></pre></td></tr></table></figure><h2 id="Pod・コンテナーの情報でわかること、わからないこと"><a href="#Pod・コンテナーの情報でわかること、わからないこと" class="headerlink" title="Pod・コンテナーの情報でわかること、わからないこと"></a>Pod・コンテナーの情報でわかること、わからないこと</h2><p>あるコンテナーに関してOOMKillによるコンテナーの再起動が発生した場合、<br>コンテナーの過去の状態としてそのことが記録されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe pod &lt;Pod名&gt;</span><br><span class="line">(略)</span><br><span class="line">  &lt;コンテナー名&gt;:</span><br><span class="line">    Last State:     Terminated</span><br><span class="line">      Reason:       OOMKilled</span><br><span class="line">      Exit Code:    0</span><br><span class="line">      Started:      Wed, 13 Dec 2023 06:23:20 +0000</span><br><span class="line">      Finished:     Wed, 13 Dec 2023 06:23:21 +0000</span><br></pre></td></tr></table></figure><p>ただ、これのみでは、OOMKillが発生した原因<br>(Pod・コンテナーレベルかノードレベルか)はわかりません。<br>また、コンテナー内の子プロセスが大量にメモリを使用していた場合、<br>その子プロセスがOOMkillの対象となることがありますが、<br>このとき他のプロセスが動作を継続していた場合は、<br>そもそもコンテナーの再起動とならず、<code>kubectl describe pod</code>コマンドなどでは<br>確認できません。<br>(このときの挙動については後述します)</p><h2 id="ノードの情報にてわかること、わからないこと"><a href="#ノードの情報にてわかること、わからないこと" class="headerlink" title="ノードの情報にてわかること、わからないこと"></a>ノードの情報にてわかること、わからないこと</h2><p>ノードレベルでメモリの逼迫が発生していた場合、<br>ノードの情報(<code>kubectl describe node</code>)やイベントとして、<br><code>NodeHasInsufficientMemory</code> を確認できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe node &lt;ノード名&gt;</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason                     Age                   From            Message</span><br><span class="line">  ----     ------                     ----                  ----            -------</span><br><span class="line">  Normal   NodeHasInsufficientMemory  9m33s (x2 over 18m)   kubelet         Node &lt;ノード名&gt; status is now: NodeHasInsufficientMemory</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get events</span><br><span class="line">LAST SEEN   TYPE      REASON                      OBJECT               MESSAGE</span><br><span class="line">(略)</span><br><span class="line">8m21s       Warning   EvictionThresholdMet        node/&lt;ノード名&gt;       Attempting to reclaim memory</span><br><span class="line">10m         Normal    NodeHasInsufficientMemory   node/&lt;ノード名&gt;       Node &lt;ノード名&gt; status is now: NodeHasInsufficientMemory</span><br></pre></td></tr></table></figure><p>これらの情報は、あくまでもこのタイミングでメモリの逼迫が発生していた、ということを示すものであり、<br>同時期にOOMKillが発生していた場合にも、それがPod・コンテナーレベルのものである可能性は<br>否定できません。ただ、いずれにせよメモリの逼迫が発生していたことには違いないので、<br>要求(requests)の見直しや、これとあわせてのノードの増強などを検討すべき、という<br>判断は可能です。</p><h2 id="ノードのログからわかること"><a href="#ノードのログからわかること" class="headerlink" title="ノードのログからわかること"></a>ノードのログからわかること</h2><p>とはいえ、関係者への説明のためなど、確実に原因を特定したい場合もあるかと思います。<br>そのような場合は、ノードのログを見ることでPod・コンテナーレベルか<br>ノードレベルか確認・判断することができます。</p><p>OOMKillはLinuxカーネルの機能により実行されるため、OOMKillが発生した際には<br>ノードのログ(/var/log/syslog, /var/log/kern.log など)にメッセージが出力されます。<br>下記の例のように、OOMKillが発生した際には<code>&lt;プロセス名&gt;　invoked oom-killer</code><br>から始まり、ハードウェア情報、発生時のスタック情報、メモリ利用状況など、<br>様々な情報が出力されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036951] stress-ng-vm invoked oom-killer: gfp_mask=0xcc0(GFP_KERNEL), order=0, oom_score_adj=1000</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036958] CPU: 1 PID: 716580 Comm: stress-ng-vm Not tainted 5.15.0-1051-azure #59-Ubuntu</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036961] Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS 090008  12/07/2018</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036962] Call Trace:</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036964]  &lt;TASK&gt;</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036967]  show_stack+0x52/0x5c</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036973]  dump_stack_lvl+0x38/0x4d</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036978]  dump_stack+0x10/0x16</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036980]  dump_header+0x53/0x228</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036984]  oom_kill_process.cold+0xb/0x10</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036986]  out_of_memory+0x106/0x2e0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036989]  mem_cgroup_out_of_memory+0x13f/0x160</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036992]  try_charge_memcg+0x6cd/0x790</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036995]  charge_memcg+0x45/0xa0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036997]  __mem_cgroup_charge+0x2d/0x90</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037000]  do_anonymous_page+0x104/0x4c0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037003]  handle_pte_fault+0x21b/0x260</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037006]  __handle_mm_fault+0x409/0x760</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037009]  ? sched_clock+0x9/0x10</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037014]  handle_mm_fault+0xc8/0x2a0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037017]  do_user_addr_fault+0x1bc/0x660</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037020]  exc_page_fault+0x71/0x160</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037024]  asm_exc_page_fault+0x27/0x30</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037027] RIP: 0033:0x55fbbb223b65</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037031] Code: 98 00 41 54 49 89 fa 55 48 89 cd 48 01 fa 53 4c 8b 59 10 4c 39 ca 0f 83 01 01 00 00 31 c9 0f 1f 80 00 00 00 00 89 cf 83 c1 01 &lt;40&gt; 88 3a 48 8b 3d 99 f7 98 00 48 01 fa 4c 39 ca 72 e9 48 89 f0 31</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037033] RSP: 002b:00007ffd1b287520 EFLAGS: 00010206</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037035] RAX: 0000000000000010 RBX: 00007f1d90825000 RCX: 0000000000734f41</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037036] RDX: 00007f1dad562000 RSI: 0000000040000000 RDI: 0000000000734f40</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037038] RBP: 00007f1dd2c1e398 R08: 0000000000000000 R09: 00007f1dd0825000</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037039] R10: 00007f1d90825000 R11: 0000000000000000 R12: 0000000040000000</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037040] R13: 0000000000000000 R14: 00007ffd1b287670 R15: 000055fbbb2224b0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037044]  &lt;/TASK&gt;</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037045] memory: usage 512000kB, limit 512000kB, failcnt 37</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037046] swap: usage 0kB, limit 9007199254740988kB, failcnt 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037047] Memory cgroup stats for /kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod479f327f_a27b_4eda_8523_90bdabcf0a27.slice:</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] anon 484630528</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] file 37752832</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] kernel_stack 65536</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] pagetables 1212416</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] percpu 11752</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] sock 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] shmem 37720064</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] file_mapped 37720064</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] file_dirty 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] file_writeback 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] swapcached 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] anon_thp 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] file_thp 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] shmem_thp 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] inactive_anon 522346496</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] active_anon 4096</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] inactive_file 16384</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] active_file 16384</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] unevictable 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] slab_reclaimable 303008</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] slab_unreclaimable 210008</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] slab 513016</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] workingset_refault_anon 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] workingset_refault_file 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] workingset_activate_anon 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] workingset_activate_file 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] workingset_restore_anon 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] workingset_restore_file 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037071] Tasks state (memory values in pages):</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037072] [  pid  ]   uid  tgid total_vm      rss pgtables_bytes swapents oom_score_adj name</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037073] [ 716518] 65535 716518      243        1    28672        0          -998 pause</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037077] [ 716566]     0 716566    13966    10178   139264        0           975 stress-ng</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037079] [ 716579]     0 716579    13967      424    73728        0          1000 stress-ng-vm</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037082] [ 716580]     0 716580   276111   118439  1015808        0          1000 stress-ng-vm</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037084] oom-kill:constraint=CONSTRAINT_MEMCG,nodemask=(null),cpuset=cri-containerd-679f9845995b4ae4812789eb3c3d1df88040a1bc3f0c046a05c9aa9b5b5f93be.scope,mems_allowed=0,oom_memcg=/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod479f327f_a27b_4eda_8523_90bdabcf0a27.slice,task_memcg=/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod479f327f_a27b_4eda_8523_90bdabcf0a27.slice/cri-containerd-679f9845995b4ae4812789eb3c3d1df88040a1bc3f0c046a05c9aa9b5b5f93be.scope,task=stress-ng-vm,pid=716580,uid=0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037095] Memory cgroup out of memory: Killed process 716580 (stress-ng-vm) total-vm:1104444kB, anon-rss:473048kB, file-rss:644kB, shmem-rss:64kB, UID:0 pgtables:992kB oom_score_adj:1000</span><br></pre></td></tr></table></figure><p>このメッセージから、いくつかのことがわかります。</p><h3 id="コンテナーレベル-ノードレベルの判断"><a href="#コンテナーレベル-ノードレベルの判断" class="headerlink" title="コンテナーレベル/ノードレベルの判断"></a>コンテナーレベル/ノードレベルの判断</h3><p><code>spec.containers[].resources.limits.memory</code>にて指定した制限は、<br>memcg(cgroupsのメモリコントローラ)により適用されます。</p><p>cgroupsはLinux上でコンテナーを実現するための主要な機能の一つであり、<br>control group(cgroup)に分類されたプロセス群について、グループごとに<br>メモリやCPU等のリソースの使用量を制限するものです。</p><p><a href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html#memory">Control Group v2: Memory</a></p><p>メモリ制限(limits)は、Pod・コンテナーに対応するcgroupに関して<br>確保・利用可能なメモリ量の上限が設定され、上限を超過したときに<br>memcgがOOMKillを発生させることで実現されています。</p><p>下記の行からは、<code>oom_memcg</code>として、OOMの発生要因となったcgroupが<br><code>/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod479f327f_a27b_4eda_8523_90bdabcf0a27.slice</code><br>(特定のPodに対応するcgroup)であることがわかります。すなわち、Pod・コンテナーレベルのOOMKillであると判断できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oom-kill:constraint=CONSTRAINT_MEMCG,nodemask=(null),cpuset=cri-containerd-679f9845995b4ae4812789eb3c3d1df88040a1bc3f0c046a05c9aa9b5b5f93be.scope,mems_allowed=0,oom_memcg=/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod479f327f_a27b_4eda_8523_90bdabcf0a27.slice,task_memcg=/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod479f327f_a27b_4eda_8523_90bdabcf0a27.slice/cri-containerd-679f9845995b4ae4812789eb3c3d1df88040a1bc3f0c046a05c9aa9b5b5f93be.scope,task=stress-ng-vm,pid=716580,uid=0</span><br></pre></td></tr></table></figure><p>一方、ノードレベルの場合は、例えば下記のように、 <code>oom_memcg</code>が<code>/kubepods.slice</code>となっている(個々のPod等に対応する<br>cgroupではなく、その上位のcgroupとなっている)ことから、そのOOMKillがノードレベルのものであると判断できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oom-kill:constraint=CONSTRAINT_MEMCG,nodemask=(null),cpuset=cri-containerd-4d2af8acef61505159dd1fb6e232eacd1b724e1d629f043fcaa47809544f6d92.scope,mems_allowed=0,oom_memcg=/kubepods.slice,task_memcg=/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-poda9d4b3f1_0189_4f5e_a8ee_94f0a3f53ab0.slice/cri-containerd-4d2af8acef61505159dd1fb6e232eacd1b724e1d629f043fcaa47809544f6d92.scope,task=stress-ng-vm,pid=728241,uid=0</span><br></pre></td></tr></table></figure><h3 id="他にわかること"><a href="#他にわかること" class="headerlink" title="他にわかること"></a>他にわかること</h3><p>この他、OOMKillメッセージには発生時のcgroup内のメモリ使用量の内訳、プロセス毎のメモリ使用状況などの情報が含まれます。<br>もし、Pod・コンテナーが意図せず大量のメモリを確保・利用していた場合、これらの情報を参照することで<br>原因の絞り込みに役立つかもしれません。</p><h2 id="子プロセスがOOMKillされたときの挙動"><a href="#子プロセスがOOMKillされたときの挙動" class="headerlink" title="子プロセスがOOMKillされたときの挙動"></a>子プロセスがOOMKillされたときの挙動</h2><h3 id="Kubernetes-1-27-まで"><a href="#Kubernetes-1-27-まで" class="headerlink" title="Kubernetes 1.27 まで"></a>Kubernetes 1.27 まで</h3><p>既に解説した通り、Pod・コンテナーレベルのOOMKillは、Pod・コンテナーに対応するcgroupに関して<br>メモリ使用量が制限値を超過することで発生します。<br>ただ、このとき行われるOOMKillの対象は、あくまでもコンテナー内で(メモリ使用量等の観点で)選ばれた<br>特定のプロセスとなります。従って、例えばコンテナー内で作成された子プロセスの一つが<br>OOMKillにより終了した場合、コンテナー内のプロセスの構成次第では<br>他のプロセスが(場合によってはコンテナーとして不完全なまま)動作を継続する場合があります。</p><p>このとき、コンテナーとしての再起動は発生しないため、<br><code>kubectl describe pod</code>コマンドの結果などからは、そもそもOOMKillが発生したことすらわかりません。</p><p>このような場合にOOMKillの発生を検知するには、ノードのログ等から<br>OOMKillのメッセージの有無を確認する必要があります。<br>(memcgの統計情報を確認する、などの方法もありますが割愛させて頂きます)</p><h3 id="Kubernetes-1-28-以降"><a href="#Kubernetes-1-28-以降" class="headerlink" title="Kubernetes 1.28 以降"></a>Kubernetes 1.28 以降</h3><p>Kubernetes バージョン1.28以降では、cgroups v2のmemcgで採用された<br><code>memory.oom.group</code>という機能を、Pod・コンテナーのcgroupに関して<br>有効化するようになりました。<br>この機能は、cgroup内の任意のプロセスがOOMKillの対象となった場合に<br>同じcgroup内の全プロセスに関してOOMKillを実行する、というものです。<br>すなわち、 Kubernetes バージョンが1.28以降であり、<br>かつ、利用されているcgroupsがv2の場合、<br>任意の子プロセスがOOMKillとなった際に、(<code>restartPolicy</code>がNeverでなければ)<br>確実にコンテナーの再起動が発生するようになります。</p><p><a href="https://github.com/kubernetes/kubernetes/issues/117070">[SIG-Node] Cgroups v2 memory.oom.group support (kill all pids in a pod on oom)</a></p><p><a href="https://github.com/kubernetes/kubernetes/pull/117793">use the cgroup aware OOM killer if available</a></p><p>AKS では、Kubernetes バージョン1.25以降のAKSクラスターの<br>Ubuntuノード(Ubuntu 22.04ノード)でcgroups v2が利用されております。<br>Azure Linuxノードの場合はKubernetes バージョン1.28の時点にて<br>まだcgroups v1が利用されますが、バージョン1.29以降では<br>cgroups v2の利用に切り替わる予定です。</p><p><a href="https://github.com/Azure/AKS/releases/tag/2023-11-28">AKS Release 2023-11-28</a></p><p>まとめると、Ubuntuノードの場合は Kuberenetes バージョン1.28以降、<br>Azure Linuxノードの場合はバージョン1.29以降にて、<br>Pod・コンテナーのcgroupに対して<code>memory.oom.group</code>が有効化され、<br>OOMKillの発生時にはコンテナー内の全プロセスがOOMKill対象となります。</p><p>なお、<code>memory.oom.group</code>が有効化されているコンテナーに関してOOMKillが発生した場合、<br>下記のように、ログメッセージでもcgroup内の全プロセスがkillされる旨のメッセージが出力されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dec 13 07:54:24 aks-ubuntu-26253795-vmss000000 kernel: [41725.949137] Tasks in /kubepods.slice/kubepods-burstable.slice/kubepods-burstable-podc9658b52_5194_4250_87f2_ec380cce2915.slice/cri-containerd-6793e00dcd36f430871d321242bbd79c1c186a3fad6615a98a1cc0b24c3e7f8f.scope are going to be killed due to memory.oom.group set</span><br></pre></td></tr></table></figure><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>この記事では、AKSノードにおけるOOOMKillの際の挙動や、これに基づく原因調査方法について紹介しました。<br>OOMKill発生時には、紹介した方法にて原因を確認の上、Pod・コンテナーレベルのOOMKillの場合は<br>制限(limits)の増加、ノードレベルの場合は要求(requests)の増加やノードの増強等を<br>ご検討下さい。<br>また、<code>memory.oom.group</code>未対応の構成では、Kubernetes リソースの情報としては<br>わからない形でOOMKillが発生していた、ということもありますので、<br>プロセスがいつの間にか終了していた、といった場合には<br>OOMKillが発生していた可能性もご確認下さい。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;この記事は&lt;a href=&quot;https://qiita.com/advent-calendar/2023/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2023&lt;/a&gt; の 17 日目の記事になります。</summary>
      
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>Azure Cloud Shell を仮想ネットワークにデプロイする手順のご紹介</title>
    <link href="https://jpaztech.github.io/blog/vm/UseCloudShellinAzureVirtualNetwork/"/>
    <id>https://jpaztech.github.io/blog/vm/UseCloudShellinAzureVirtualNetwork/</id>
    <published>2023-12-13T14:09:00.000Z</published>
    <updated>2023-12-29T07:45:21.771Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカルサポートチームの小田です。<br>今回は仮想ネットワークに対して Azure Cloud Shell をデプロイする手順を紹介いたします。</p><span id="more"></span><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>通常 Azure Cloud Shell のマシンは、お客様が管理されている仮想ネットワークとは異なる Azure が管理するネットワークに対して展開されます。<br>Azure Cloud Shell が存在するネットワークは、お客様ではなくマイクロソフトが管理を行っております。 </p><p>そのため、Azure Cloud Shell のご利用において以下のような制約でお困りのお客様から、お問い合わせを頂くことがしばしばございます。</p><ul><li>Azure Cloud Shell から仮想マシンなどのリソースが持つプライベート IP アドレスに対して接続ができない</li><li>Azure Cloud Shell が使用する IP アドレスをお客様が設定 / 管理できないため、Azure Cloud Shell からの通信を NSG などによりを制御することができない</li></ul><p>このような場合にはAzure Cloud Shell を仮想ネットワークにデプロイすることで、Azure Cloud Shell が使用する IP アドレスをお客様が管理することができ、これらの制約が解消されます。<br>なお補足となりますが、この Azure Cloud Shell を仮想ネットワークに対してデプロイすることを “VNET の分離” とも呼びます。<br>必要に応じて、Azure Cloud Shell を仮想ネットワークに対してデプロイすることについてご検討をいただけますと幸いです。</p><h2 id="ご利用にあたっての注意事項"><a href="#ご利用にあたっての注意事項" class="headerlink" title="ご利用にあたっての注意事項"></a>ご利用にあたっての注意事項</h2><p>ご利用に際して以下 2 点の注意事項がございますのでご確認ください。</p><h3 id="注意事項①-Azure-Relay-リソースの利用は有償となります"><a href="#注意事項①-Azure-Relay-リソースの利用は有償となります" class="headerlink" title="注意事項① Azure Relay リソースの利用は有償となります"></a>注意事項① Azure Relay リソースの利用は有償となります</h3><p>Azure Cloud Shell を仮想ネットワークに対してデプロイする場合には、Azure Relay をご利用いただく必要がございますが、Azure Relay は有料サービスとなります。<br>この点につきましてご留意をいただけますと幸いです。</p><blockquote><p>・ご参考: <a href="https://learn.microsoft.com/ja-jp/azure/cloud-shell/private-vnet#things-to-consider-before-deploying-azure-cloud-shell-in-a-vnet">VNET に Azure Cloud Shell をデプロイする前に考慮すべき事項</a><br>—- 抜粋 —–<br>VNET の分離では、有料サービスである Azure Relay を使用する必要があります。<br>—- 抜粋 —–</p></blockquote><h3 id="注意事項②-デプロイできるリージョンが限られます"><a href="#注意事項②-デプロイできるリージョンが限られます" class="headerlink" title="注意事項② デプロイできるリージョンが限られます"></a>注意事項② デプロイできるリージョンが限られます</h3><p>また、Azure Cloud Shell を仮想ネットワークに対してデプロイする場合にも、 Azure Cloud Shell  を展開できるリージョンは限られます。東日本や西日本リージョンには Cloud Shell 端末をデプロイできない点についてご留意をください。</p><blockquote><p>・ご参考: <a href="https://learn.microsoft.com/ja-jp/azure/cloud-shell/persisting-shell-storage#supported-storage-regions">サポートされているストレージ リージョン</a><br>—- 抜粋 —–<br>Azure Cloud Shellは、次の各リージョンに存在します。</p><table><thead><tr><th>領域</th><th>リージョン</th></tr></thead><tbody><tr><td>アメリカ</td><td>米国東部、米国中南部、米国西部</td></tr><tr><td>ヨーロッパ</td><td>北ヨーロッパ、西ヨーロッパ</td></tr><tr><td>アジア太平洋</td><td>インド中部、東南アジア</td></tr><tr><td>—- 抜粋 —–</td><td></td></tr></tbody></table></blockquote><p>そのため VNET に対して Azure Cloud Shell をデプロイする場合にも、Azure Cloud Shell から東日本や西日本リージョンのリソースに対してプライベート IP アドレスを使用した接続をご希望の場合には、Azure Cloud Shell がデプロイされる VNET と東日本や西日本リージョンの VNET 間で VNET ピアリングが必要となります。</p><blockquote><p>・ご参考: <a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-network-peering-overview">Azure 仮想ネットワーク ピアリング</a></p></blockquote><h2 id="デプロイ手順"><a href="#デプロイ手順" class="headerlink" title="デプロイ手順"></a>デプロイ手順</h2><p>本稿では、Azure Cloud Shell や仮想ネットワーク、ストレージアカウントをARM テンプレートにより新規に作成し、仮想ネットワーク上に Azure Cloud Shell をデプロイする手順をご紹介いたします。<br>以下の公式ドキュメントが対応いたしますので、併せてご参考ください。</p><blockquote><p>・ご参考: <a href="https://learn.microsoft.com/ja-jp/azure/cloud-shell/quickstart-deploy-vnet">クイックスタート テンプレートを使用して VNET に Azure Cloud Shell をデプロイする</a></p></blockquote><h3 id="手順の概要"><a href="#手順の概要" class="headerlink" title="手順の概要"></a>手順の概要</h3><p>具体的な手順の説明に入る前に、まずは手順の概要を説明させて頂きます。<br>作業は以下 7 つの手順にて実施いたします。</p><p>手順① リソースグループの作成<br>手順② 仮想ネットワークの作成<br>手順③ リソースプロバイダーの登録<br>手順④ Azure Container Instance ID の確認<br>手順⑤ ARM テンプレートを使用してストレージアカウント以外のリソースを作成<br>手順⑥ ARM テンプレートを使用してストレージアカウントを作成<br>手順⑦ 仮想ネットワークを使用するように Cloud Shell を構成</p><h3 id="手順の詳細"><a href="#手順の詳細" class="headerlink" title="手順の詳細"></a>手順の詳細</h3><p>具体的なデプロイ手順を以下にご案内いたします。</p><h4 id="手順①-リソースグループを作成する"><a href="#手順①-リソースグループを作成する" class="headerlink" title="手順① リソースグループを作成する"></a>手順① リソースグループを作成する</h4><p>Cloud Shell 端末をデプロイできるリージョンを指定し（以下の画面例では ”southeastasia”を指定）リソースグループを作成いたします。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step1-1.jpg" alt="手順①"></p><h4 id="手順②-仮想ネットワークを作成する"><a href="#手順②-仮想ネットワークを作成する" class="headerlink" title="手順②　仮想ネットワークを作成する"></a>手順②　仮想ネットワークを作成する</h4><p>前項で作成したリソースグループおよび対象のリージョンを指定し、仮想ネットワークを作成いたします。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step2-1.jpg" alt="手順②"></p><p>IP アドレス タブにて、ご希望の IP アドレス レンジをご指定ください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step2-2.jpg" alt="手順②"></p><h4 id="手順③リソースプロバイダーの登録"><a href="#手順③リソースプロバイダーの登録" class="headerlink" title="手順③リソースプロバイダーの登録"></a>手順③リソースプロバイダーの登録</h4><p>Azure Cloud Shell はコンテナーを使用して実行されるため、ご利用のサブスクリプションにおいて、”Microsoft.ContainerInstances” リソースプロバイダーを登録する必要があります。<br>当該リソースプロバイダーは自動的に登録されている場合がございますので、まずは Azure PowerShell より以下のコマンドを使用して、リソースプロバイダーの登録状況を確認してください。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-AzContext</span> <span class="literal">-Subscription</span> &lt;サブスクリプション名&gt;</span><br><span class="line"><span class="built_in">Get-AzResourceProvider</span> <span class="literal">-ProviderNamespace</span> Microsoft.ContainerInstance |</span><br><span class="line">    <span class="built_in">Select-Object</span> ResourceTypes, RegistrationState</span><br></pre></td></tr></table></figure><p>登録がされていない場合は、以下の出力例のように各 RegistrationState  がNotRegistered と表示されます。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\shoheioda&gt; <span class="built_in">Get-AzResourceProvider</span> <span class="literal">-ProviderNamespace</span> Microsoft.ContainerInstance | <span class="built_in">select</span> ResourceTypes,RegistrationState</span><br><span class="line"> </span><br><span class="line">ResourceTypes                                     RegistrationState</span><br><span class="line">-------------                                     -----------------</span><br><span class="line">&#123;containerGroups&#125;                                 NotRegistered</span><br><span class="line">&#123;serviceAssociationLinks&#125;                         NotRegistered</span><br><span class="line">&#123;locations&#125;                                       NotRegistered</span><br><span class="line">&#123;locations/capabilities&#125;                          NotRegistered</span><br><span class="line">&#123;locations/usages&#125;                                NotRegistered</span><br><span class="line">&#123;locations/operations&#125;                            NotRegistered</span><br><span class="line">&#123;locations/operationresults&#125;                      NotRegistered</span><br><span class="line">&#123;operations&#125;                                      NotRegistered</span><br><span class="line">&#123;locations/cachedImages&#125;                          NotRegistered</span><br><span class="line">&#123;locations/validateDeleteVirtualNetworkOrSubnets&#125; NotRegistered</span><br><span class="line">&#123;locations/deleteVirtualNetworkOrSubnets&#125;         NotRegistered</span><br></pre></td></tr></table></figure><p>登録を行うには、以下のコマンドを実行してください。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\shoheioda&gt; <span class="built_in">Get-AzResourceProvider</span> <span class="literal">-ProviderNamespace</span> Microsoft.ContainerInstance | <span class="built_in">select</span> ResourceTypes,RegistrationState</span><br><span class="line"> </span><br><span class="line">ResourceTypes                                     RegistrationState</span><br><span class="line">-------------                                     -----------------</span><br><span class="line">&#123;containerGroups&#125;                                 Registered</span><br><span class="line">&#123;serviceAssociationLinks&#125;                         Registered</span><br><span class="line">&#123;locations&#125;                                       Registered</span><br><span class="line">&#123;locations/capabilities&#125;                          Registered</span><br><span class="line">&#123;locations/usages&#125;                                Registered</span><br><span class="line">&#123;locations/operations&#125;                            Registered</span><br><span class="line">&#123;locations/operationresults&#125;                      Registered</span><br><span class="line">&#123;operations&#125;                                      Registered</span><br><span class="line">&#123;locations/cachedImages&#125;                          Registered</span><br><span class="line">&#123;locations/validateDeleteVirtualNetworkOrSubnets&#125; Registered</span><br><span class="line">&#123;locations/deleteVirtualNetworkOrSubnets&#125;         Registered</span><br></pre></td></tr></table></figure><h4 id="手順④-Azure-Container-Instance-ID-を確認する"><a href="#手順④-Azure-Container-Instance-ID-を確認する" class="headerlink" title="手順④ Azure Container Instance ID を確認する"></a>手順④ Azure Container Instance ID を確認する</h4><p>後続の手順において必要となるサービスプリンシパル “Azure Container Instance” に割り当てられた Azure Container Instance ID を、Azure PowerShell より以下のコマンドを実行して確認してください。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-AzADServicePrincipal</span> <span class="literal">-DisplayNameBeginsWith</span> <span class="string">&#x27;Azure Container Instance&#x27;</span></span><br></pre></td></tr></table></figure><p>以下の出力例の場合には、 Azure Container Instance Id は “8fe7fd25-33fe-4f89-ade3-0e705fcf4370” となります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DisplayName                      Id                                   AppId</span><br><span class="line">-----------                      --                                   -----</span><br><span class="line">Azure Container Instance Service <span class="number">8</span>fe7fd25<span class="literal">-33fe</span><span class="literal">-4f89</span><span class="literal">-ade3</span><span class="literal">-0e705fcf4370</span> <span class="number">34</span>fbe509<span class="literal">-d6cb</span><span class="literal">-4813</span><span class="literal">-99df</span><span class="literal">-52d944bfd95a</span></span><br></pre></td></tr></table></figure><h4 id="手順⑤-ARM-テンプレートを使用してリソースをプロビジョニングする"><a href="#手順⑤-ARM-テンプレートを使用してリソースをプロビジョニングする" class="headerlink" title="手順⑤ ARM テンプレートを使用してリソースをプロビジョニングする"></a>手順⑤ ARM テンプレートを使用してリソースをプロビジョニングする</h4><p>以下のリンクへアクセスして、 ARM テンプレートを使用して仮想ネットワークに対して Cloud Shell リソースを作成いたします。</p><p><a href="https://aka.ms/cloudshell/docs/vnet/template">https://aka.ms/cloudshell/docs/vnet/template</a></p><p>上記リンクへアクセスしたら表示される画面において、の “Deploy to Azure” のリンクを選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step5-1.jpg" alt="手順⑤"></p><p>表示されたテンプレートの各項目に必要な情報を入力して、”確認と作成”を 選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step5-2.jpg" alt="手順⑤"></p><p>入力したリソースの名称など確認画面が表示されますので、問題なければ “作成” を選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step5-3.jpg" alt="手順⑤"></p><p>対象のリソースグループ内に必要なリソースが まとめて作成されます。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step5-4.jpg" alt="手順⑤"></p><h4 id="手順⑥-ストレージアカウントを作成する。"><a href="#手順⑥-ストレージアカウントを作成する。" class="headerlink" title="手順⑥ ストレージアカウントを作成する。"></a>手順⑥ ストレージアカウントを作成する。</h4><p>以下のリンクへアクセスして、 ARM テンプレートを使用してCloud Shell が使用するストレージアカウントを作成します。</p><p><a href="https://azure.microsoft.com/resources/templates/cloud-shell-vnet-storage/">https://azure.microsoft.com/resources/templates/cloud-shell-vnet-storage/</a></p><p>上記リンクへアクセスしたら表示される画面において “Deploy to Azure” のリンクを選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step6-1.jpg" alt="手順⑥"></p><p>表示されたテンプレートの各項目に必要な情報を入力して、”確認と作成”を 選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step6-2.jpg" alt="手順⑥"></p><p>入力したリソースの名称など確認画面が表示されますので、問題なければ “作成” を選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step6-3.jpg" alt="手順⑥"></p><p>対象のリソースグループ内にストレージアカウントが作成されます。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step6-4.jpg" alt="手順⑥"></p><h4 id="手順⑦-仮想ネットワークを使用するように-Cloud-Shell-を構成する"><a href="#手順⑦-仮想ネットワークを使用するように-Cloud-Shell-を構成する" class="headerlink" title="手順⑦ 仮想ネットワークを使用するように Cloud Shell を構成する"></a>手順⑦ 仮想ネットワークを使用するように Cloud Shell を構成する</h4><p>Azure ポータル画面上部のメニューより Cloud Shell のアイコンを選択いたします。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step7-1.jpg" alt="手順⑦"></p><p>初期時点では、以下のように “ストレージアカウントがマウントされていません” とCloud Shell 端末を新規に作成される画面が表示されますので、ここでリンク “詳細設定の表示” を選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step7-2.jpg" alt="手順⑦"></p><p>なお、既に既定の設定で Cloud Shell をご利用されており、上記の画面が表示されない場合には、以下のように Cloud Shell 画面より、メニューバーの歯車アイコンから “ユーザー設定のリセット” を選択して設定を初期化させてください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step7-3.jpg" alt="手順⑦"></p><p>再度 Cloud Shell を起動することで、上述の “ストレージアカウントがマウントされていません” とCloud Shell 端末を新規に作成される画面が表示されますので、“詳細設定の表示” を選択してください。</p><p>“詳細設定の表示” より以下のように必要な項目を入力して、”ストレージの作成” を選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step7-4.jpg" alt="手順⑦"></p><h4 id="補足：-仮想ネットワークにデプロイした場合の状態確認"><a href="#補足：-仮想ネットワークにデプロイした場合の状態確認" class="headerlink" title="補足： 仮想ネットワークにデプロイした場合の状態確認"></a>補足： 仮想ネットワークにデプロイした場合の状態確認</h4><p>Cloud Shell 端末を仮想ネットワークにデプロイした状況について以下のように状態を確認することが可能で</p><p>Get-CloudDrive コマンドレットにより、Cloud Shell がマウントしているファイル共有のリソース情報を確認することが可能です。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> /home/user&gt; <span class="built_in">Get-CloudDrive</span>                                                                  ter<span class="string">&#x27; -PassThru</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">FileShareName      : acsshare</span></span><br><span class="line"><span class="string">FileSharePath      : //srtrgaccctcloudshellvnet.file.core.windows.net/acsshare</span></span><br><span class="line"><span class="string">MountPoint         : /home/user/clouddrive</span></span><br><span class="line"><span class="string">Name               : srtrgaccctcloudshellvnet</span></span><br><span class="line"><span class="string">ResourceGroupName  : rg-cloudshellvnet</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">StorageAccountName : srtrgaccctcloudshellvnet</span></span><br><span class="line"><span class="string">SubscriptionId     : XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX</span></span><br></pre></td></tr></table></figure><p>以下のように対象の VNET から到達可能な プライベート IP  に対して Ping やSSH により接続が可能です。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> /home/user&gt; ping <span class="number">10.8</span>.<span class="number">0.20</span></span><br><span class="line">PING <span class="number">10.8</span>.<span class="number">0.20</span> (<span class="number">10.8</span>.<span class="number">0.20</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of <span class="keyword">data</span>.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">10.8</span>.<span class="number">0.20</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">64</span> time=<span class="number">68.7</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">10.8</span>.<span class="number">0.20</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">64</span> time=<span class="number">68.5</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">10.8</span>.<span class="number">0.20</span>: icmp_seq=<span class="number">5</span> ttl=<span class="number">64</span> time=<span class="number">68.2</span> ms</span><br><span class="line">^C</span><br><span class="line">--- <span class="number">10.8</span>.<span class="number">0.20</span> ping statistics ---</span><br><span class="line"><span class="number">5</span> packets transmitted, <span class="number">3</span> received, <span class="number">40</span>% packet loss, time <span class="number">4062</span>ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">68.233</span>/<span class="number">68.479</span>/<span class="number">68.665</span>/<span class="number">0.181</span> ms</span><br><span class="line"><span class="built_in">PS</span> /home/user&gt;</span><br><span class="line"><span class="built_in">PS</span> /home/user&gt; ssh <span class="literal">-i</span> rhel<span class="literal">-86</span><span class="literal">-02_20230912</span>.pem azureuser@<span class="number">10.8</span>.<span class="number">0.20</span></span><br><span class="line">Activate the web console with: systemctl enable -<span class="literal">-now</span> cockpit.socket</span><br><span class="line"></span><br><span class="line">Register this system with Red Hat Insights: insights<span class="literal">-client</span> -<span class="literal">-register</span></span><br><span class="line">Create an account or view all your systems at https://red.ht/insights<span class="literal">-dashboard</span></span><br><span class="line">Last login: Tue Sep <span class="number">12</span> <span class="number">04</span>:<span class="number">16</span>:<span class="number">23</span> <span class="number">2023</span> from XX.XX.XX.XX</span><br><span class="line">[<span class="type">azureuser</span>@<span class="type">rhel</span>-<span class="number">86</span>-<span class="number">02</span> ~]<span class="variable">$</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカルサポートチームの小田です。&lt;br&gt;今回は仮想ネットワークに対して Azure Cloud Shell をデプロイする手順を紹介いたします。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Azure Cloud Shell" scheme="https://jpaztech.github.io/blog/tags/Azure-Cloud-Shell/"/>
    
    <category term="Token" scheme="https://jpaztech.github.io/blog/tags/Token/"/>
    
    <category term="OAuth" scheme="https://jpaztech.github.io/blog/tags/OAuth/"/>
    
  </entry>
  
  <entry>
    <title>AKS ノードが起動しない場合のトラブルシューティング</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-vmsscse/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-vmsscse/</id>
    <published>2023-12-12T03:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.663Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポートチームの桐井です。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/intro-kubernetes">Azure Kubernetes Service (AKS)</a> クラスターで、ノードの新規作成が成功しない事象や、停止したクラスターの起動が成功しないといった事象が発生することがございます。</p><p>このような事象は、ノードの初期化が成功していない場合に発生するもので、弊社サポート事例においても多くのお客様よりご相談をいただくことがございます。</p><p>本記事では、AKS ノードの初期化を担う vmssCSE 拡張機能についての解説と、ノード初期化が成功しない代表的な要因とトラブルシューティング方法について紹介します。</p><span id="more"></span><hr><h2 id="vmssCSE-拡張機能とは"><a href="#vmssCSE-拡張機能とは" class="headerlink" title="vmssCSE 拡張機能とは"></a>vmssCSE 拡張機能とは</h2><p>AKS クラスターのノードには VMSS インスタンスが使用されています。AKS ノードを作成すると、それに応じて VMSS インスタンスが作成されます。</p><p>vmssCSE 拡張機能は、VMSS インスタンスを AKS ノードとして利用可能な状態にするために初期化する役割を担います。<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/extensions/overview">Azure 仮想マシンの拡張機能</a>を利用して、AKS ノードの初期化をするスクリプトが実行されます。<br>vmssCSE は VMSS (Virtual Machine Scale Set) Custom Script Extension の略称です。</p><p>初期化スクリプトが実行されると、はじめに、<a href="https://learn.microsoft.com/ja-jp/azure/aks/outbound-rules-control-egress#required-outbound-network-rules-and-fqdns-for-aks-clusters">AKS ノードに必要なネットワーク要件</a>が満たされているか検証されます。<br>AKS のAPI サーバーや、システム コンポーネントの取得元となるコンテナー レジストリに対してアクセス可能か検証し、必要な通信ができる状態であるかチェックされます。<br>その後、AKS ノードとして動作させるために必要なコンポーネント (kubelet や CNI プラグインなど) がダウンロードされ、VMSS インスタンスにインストールされます。<br>インストールが完了すると、AKS クラスターにノードが追加されます。</p><p>vmssCSE 拡張機能は、Azure 仮想マシンのプロビジョニング プロセスの一部として実行されます。<br>何らかの要因によって vmssCSE 拡張機能によるノードの初期化が成功しなかった場合には、新規作成された AKS ノードの起動が完了しない状態となります。</p><p>vmssCSE 拡張機能によるノードの初期化が成功しないと、次のような事象が発生します。</p><ul><li>AKS クラスターの作成失敗</li><li>AKS クラスターやノードプールのアップグレード失敗</li><li>ノードプール追加やスケールアウト失敗</li><li>停止された AKS クラスターの起動失敗</li></ul><p>ノードの初期化が成功しない理由の多くは、ネットワーク通信に関連する要因です。<br>特に、ファイアーウォールやカスタム DNS サーバーなど、ネットワーク構成をカスタマイズしている環境において、AKS クラスターの動作に必要な通信が成功しないことによって事象が発生します。</p><p><img src="/blog/containers/aks-vmsscse/aks-vmsscse01.png" alt="ノード初期化が成功しない場合に想定される要因箇所"></p><p>Azure 仮想マシンの拡張機能は、<a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/extensions/troubleshoot">実行結果をお客様にてご確認いただくことが可能です</a>。<br>また、vmssCSE 拡張機能で実行されるノードの初期化スクリプトは、成功しなかった理由に応じてエラー ステータスを出力します。</p><p>そのため、上記のような事象が発生した場合には、vmssCSE 拡張機能の実行結果をご確認いただくことで、要因箇所の特定に役立つ手がかりを得ることができます。</p><h2 id="vmssCSE-拡張機能のステータスと確認方法"><a href="#vmssCSE-拡張機能のステータスと確認方法" class="headerlink" title="vmssCSE 拡張機能のステータスと確認方法"></a>vmssCSE 拡張機能のステータスと確認方法</h2><p>vmssCSE 拡張機能のステータスから、AKS ノードの初期化が正常に実行されたかどうかを確認できます。主な確認項目は次の2つです。</p><ol><li>ステータス コード (code)<ul><li>拡張機能の実行結果を示します</li><li><code>ProvisioningState/succeeded</code> の場合は成功です</li><li><code>ProvisioningState/failed</code> の場合は失敗です</li></ul></li><li>メッセージ (message)<ul><li>初期化スクリプトの実行結果とログが出力されます</li><li>トラブルシューティングでは特に <code>ExitCode</code> の値に注目します</li><li><code>ExitCode</code> が <code>0</code> の場合は成功です</li><li><code>0</code> 以外 (<code>50</code>, <code>51</code>, など) の場合は何らかの要因で失敗しています</li></ul></li></ol><p>次に、Azure Portal と Azure CLI で確認する方法を紹介します。</p><h3 id="Azure-Portal-で確認する方法"><a href="#Azure-Portal-で確認する方法" class="headerlink" title="Azure Portal で確認する方法"></a>Azure Portal で確認する方法</h3><p>ノード リソース グループ (既定では <code>MC_</code> で始まるリソース グループ) を開き、ノードプールで使用されている VMSS リソースを開きます。<br>左メニューから [インスタンス] を選択し、状態を確認したい VMSS インスタンスをクリックします。</p><p><img src="/blog/containers/aks-vmsscse/aks-vmsscse02.png"></p><p>インスタンスの詳細画面の [状態] 項目のリンクをクリックします。</p><p><img src="/blog/containers/aks-vmsscse/aks-vmsscse03.png"></p><p>[拡張機能の状態] &gt; [vmssCSE] をクリックし、メッセージ内容を確認します。</p><p><img src="/blog/containers/aks-vmsscse/aks-vmsscse04.png"></p><h3 id="Azure-CLI-で確認する方法"><a href="#Azure-CLI-で確認する方法" class="headerlink" title="Azure CLI で確認する方法"></a>Azure CLI で確認する方法</h3><p>Azure CLI では下記コマンドで確認できます。<br>ノード リソース グループと VMSS リソース名を指定してコマンドを実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">az vmss list-instances --resource-group &lt;NODE RESOURCE GROUP&gt; --name &lt;VMSS NAME&gt; \</span><br><span class="line">    --expand instanceView --query &quot;[].&#123;name:name, extensions: instanceView.extensions&#125;&quot;</span><br></pre></td></tr></table></figure><p>下記が実行例となります。<br><code>&quot;extensions&quot;</code> の配下に<code>&quot;name&quot;: &quot;vmssCSE&quot;</code> という名前で情報が出力されます。<br><code>&quot;statuses&quot;</code> の <code>&quot;code&quot;</code> と、<code>&quot;message&quot;</code> に含まれる <code>\&quot;ExitCode\&quot;</code> の値を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss list-instances --resource-group MC_myResourceGroup_myAKSCluster_japaneast --name aks-agentpool-20329050-vmss \</span></span><br><span class="line"><span class="bash">    --expand instanceView --query <span class="string">&quot;[].&#123;name:name, extensions: instanceView.extensions&#125;&quot;</span></span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;extensions&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;vmssCSE&quot;,</span><br><span class="line">        &quot;statuses&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">            &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">            &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">            &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\n&#123; \&quot;ExitCode\&quot;: \&quot;0\&quot;, \&quot;Output\&quot;: \&quot;Wed Feb 2 10:21:47 UTC 2022,aks-agentpool-20329050-vmss000004\\n(省略)&quot;,</span><br><span class="line">            &quot;time&quot;: null</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;substatuses&quot;: null,</span><br><span class="line">        &quot;type&quot;: &quot;Microsoft.Azure.Extensions.CustomScript&quot;,</span><br><span class="line">        &quot;typeHandlerVersion&quot;: &quot;2.1.6&quot;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      (省略)</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line">    &quot;name&quot;: &quot;aks-agentpool-20329050-vmss_4&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="vmssCSE-拡張機能の代表的な-ExitCode"><a href="#vmssCSE-拡張機能の代表的な-ExitCode" class="headerlink" title="vmssCSE 拡張機能の代表的な ExitCode"></a>vmssCSE 拡張機能の代表的な ExitCode</h2><p>このセクションでは、vmssCSE 拡張機能で発生することがある代表的な ExitCode について、原因とトラブルシューティングの方法を解説します。</p><ul><li><a href="./#ExitCode-50">ExitCode: 50 (送信接続の失敗)</a></li><li><a href="./#ExitCode-51">ExitCode: 51 (AKS API サーバーへのコネクション失敗)</a></li><li><a href="./#ExitCode-52">ExitCode: 52 (AKS API サーバーの名前解決が失敗)</a></li><li><a href="./#ExitCode-53">ExitCode: 53 (Azure DNS Service による AKS API サーバーの名前解決が失敗)</a></li></ul><h3 id="ExitCode-50"><a href="#ExitCode-50" class="headerlink" title="ExitCode: 50"></a>ExitCode: 50</h3><p>ExitCode: 50 のエラーは、AKS ノードの動作に必要となる通信先へのコネクションが成功しない場合に発生します。</p><blockquote><p><strong>OutboundConnFailVMExtensionError エラー コードのトラブルシューティング (50) - Azure / Microsoft Learn</strong><br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-outboundconnfailvmextensionerror">https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-outboundconnfailvmextensionerror</a></p></blockquote><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>AKS ノードに必要なコンポーネントは、Microsoft Container Registry (MCR) のエンドポイント (mcr.microsoft.com, 443/tcp) から取得されます。</p><p>ノードの初期化スクリプトが実行されると、はじめに MCR のエンドポイントへ到達可能であるかアクセス検証を行います。<br>このとき、ノードから MCR エンドポイントへのコネクションが成功しなかった場合に、ExitCode: 50 のエラーが発生します。</p><p>MCR エンドポイントへのコネクションが成功しない要因としては、次のような理由が挙げられます。</p><ul><li>DNS による名前解決が失敗している</li><li>NSG でブロックされている</li><li>Azure Firewall / ネットワーク仮想アプライアンス (NVA) でブロックされている</li></ul><h4 id="トラブルシューティング"><a href="#トラブルシューティング" class="headerlink" title="トラブルシューティング"></a>トラブルシューティング</h4><p>AKS ノードから mcr.microsoft.com に対して、実際にアクセスできる状態であるかを確認します。<br><code>az vmss run-command</code> コマンドを利用して、VMSS インスタンス上でアクセス検証用のコマンドを実行します。</p><p>はじめに、mcr.microsoft.com の名前解決が成功するかどうかを確認します。<br>次のように、<code>az vmss run-command</code> コマンドの <code>--scripts</code> オプションに <code>nslookup</code> コマンドを指定して実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">az vmss run-command invoke -g &lt;NODE RESOURCE GROUP&gt; -n &lt;VMSS NAME&gt; \</span><br><span class="line">    --command-id RunShellScript --instance-id &lt;INSTANCE_ID&gt; \</span><br><span class="line">    --scripts &quot;nslookup mcr.microsoft.com&quot;</span><br></pre></td></tr></table></figure><p><strong>成功の例</strong></p><p><code>&quot;message&quot;</code> フィールドに <code>nslookup</code> コマンドの実行結果が出力されます。<br><code>Address: 204.79.197.219</code> のように、mcr.microsoft.com の IP アドレスが表示されていれば、名前解決は成功しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_myResourceGroup_myAKSCluster_japaneast -n aks-agentpool-20329050-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 0 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nslookup mcr.microsoft.com&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\nServer:\t\t168.63.129.16\nAddress:\t168.63.129.16#53\n\nNon-authoritative answer:\nmcr.microsoft.com\tcanonical name = global.fe.mscr.io.\nglobal.fe.mscr.io\tcanonical name = mcr-microsoft-com.a-0016.a-msedge.net.\nmcr-microsoft-com.a-0016.a-msedge.net\tcanonical name = a-0016.a-msedge.net.\nName:\ta-0016.a-msedge.net\nAddress: 204.79.197.219\n\n\n[stderr]\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>失敗の例</strong></p><p>IP アドレスが出力されておらず、<code>server can&#39;t find mcr.microsoft.com</code> のようなエラーメッセージや <code>NXDOMAIN</code> が出力されている場合は、名前解決が成功していません。</p><p>ご利用の環境において<a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-networks-name-resolution-for-vms-and-role-instances?tabs=redhat#name-resolution-that-uses-your-own-dns-server">カスタム DNS サーバーを使用している</a>場合は、AKS ノードが存在する VNet に対して、カスタム DNS サーバーが正しく構成されているかどうかをご確認ください。<br>また、カスタム DNS サーバーが mcr.microsoft.com の名前解決をできる状態であるか、動作・設定をご確認ください。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_myRG_myAKSCluster_japaneast -n aks-nodepool1-15399206-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 2 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nslookup mcr.microsoft.com&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\nServer:\t\t127.0.0.53\nAddress:\t127.0.0.53#53\n\n** server can&#x27;t find mcr.microsoft.com: SERVFAIL\n\n\n[stderr]\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>名前解決が成功したら、mcr.microsoft.com への疎通ができる状態であるかを確認します。<br>次のように、<code>nc</code> コマンドを指定して実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">az vmss run-command invoke -g &lt;NODE RESOURCE GROUP&gt; -n &lt;VMSS NAME&gt; \</span><br><span class="line">    --command-id RunShellScript --instance-id &lt;INSTANCE_ID&gt; \</span><br><span class="line">    --scripts &quot;nc -vz mcr.microsoft.com 443&quot;</span><br></pre></td></tr></table></figure><p><strong>成功の例</strong></p><p><code>Connection to mcr.microsoft.com 443 port [tcp/https] succeeded!</code> とメッセージが表示されていれば、アクセスが成功しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_myResourceGroup_myAKSCluster_japaneast -n aks-agentpool-20329050-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 1 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nc -vz mcr.microsoft.com 443&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\n\n[stderr]\nConnection to mcr.microsoft.com 443 port [tcp/https] succeeded!\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>失敗の例</strong></p><p><code>nc: connect to mcr.microsoft.com port 443 (tcp) failed</code> と表示された場合には、通信が失敗しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_myRG_myAKSCluster_japaneast -n aks-nodepool1-20916290-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 1 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nc -vz mcr.microsoft.com 443&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\n\n[stderr]\nnc: connect to mcr.microsoft.com port 443 (tcp) failed: Connection timed out\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>この場合、何らかの要因によってノードから送信された通信がブロックされている可能性が考えられます。<br>NSG やファイアーウォールで通信制御をしている場合は、AKS クラスターに必要な FQDN への通信が許可されているかご確認ください。</p><blockquote><p>ご参考) AKS クラスターに必要な送信ネットワーク規則と FQDN<br><a href="https://learn.microsoft.com/ja-jp/azure/aks/outbound-rules-control-egress#required-outbound-network-rules-and-fqdns-for-aks-clusters">https://learn.microsoft.com/ja-jp/azure/aks/outbound-rules-control-egress#required-outbound-network-rules-and-fqdns-for-aks-clusters</a></p></blockquote><div class="alert is-success"><p class="alert-title">ヒント</p><p>Azure Firewall で通信制御をする場合には、AKS 用の FQDN タグ <code>AzureKubernetesService</code> が利用可能です。</p><p>この FQDN タグには、「<a href="https://learn.microsoft.com/ja-jp/azure/aks/outbound-rules-control-egress#required-outbound-network-rules-and-fqdns-for-aks-clusters">AKS クラスターに必要な送信ネットワーク規則と FQDN</a>」に記載されているすべての FQDN が含まれており、自動的に更新されます。</p><p>以前は各 FQDN を個別に許可いただく必要がありましたが、現在は FQDN タグを利用することで一括で通信許可できるようになっておりますので、ご活用ください。</p><p>　</p><p>ご参考) Azure Kubernetes Service (AKS) で Azure Firewall を使用してエグレス トラフィックを制御する</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/limit-egress-traffic">https://learn.microsoft.com/ja-jp/azure/aks/limit-egress-traffic</a></p></div><h3 id="ExitCode-51"><a href="#ExitCode-51" class="headerlink" title="ExitCode: 51"></a>ExitCode: 51</h3><p>ExitCode: 51 のエラーは、AKS ノードがクラスターの API サーバーへ接続できない場合に発生します。</p><blockquote><p><strong>K8SAPIServerConnFailVMExtensionError エラー コードのトラブルシューティング - Azure / Microsoft Learn</strong><br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-k8sapiserverconnfailvmextensionerror">https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-k8sapiserverconnfailvmextensionerror</a></p></blockquote><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><p>ExitCode: 51 の発生状況は、上述した <a href="./#ExitCode-50">ExitCode: 50</a> と似ています。異なる点は通信先です。</p><p>ExitCode: 50 は、mcr.microsoft.com へのアクセスが成功しない場合に発生します。<br>一方 ExitCode: 51 は、AKS の API サーバーへのアクセスが成功しない場合に発生します。<br>NSG やファイアーウォールを使って通信制限をしている環境において、mcr.microsoft.com へのアクセスは許可されているものの、AKS API サーバーの FQDN や IP アドレスに対する通信が許可されていない場合に、発生が想定されます。</p><h4 id="トラブルシューティング-1"><a href="#トラブルシューティング-1" class="headerlink" title="トラブルシューティング"></a>トラブルシューティング</h4><p>AKS ノードから AKS API サーバーに対して、実際にアクセスできる状態であるかを確認します。</p><p>はじめに、対象の AKS クラスターで使用されている API サーバーの FQDN を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az aks show -g &lt;RESOURCE GROUP&gt; --name &lt;CLUSTER&gt; --query fqdn</span><br></pre></td></tr></table></figure><p><code>az vmss run-command</code> コマンドを利用して、VMSS インスタンス上でアクセス検証用のコマンドを実行します。<br>次のように、<code>nc</code> コマンドに API サーバーの FQDN を指定して実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">az vmss run-command invoke -g &lt;NODE RESOURCE GROUP&gt; -n &lt;VMSS NAME&gt; \</span><br><span class="line">    --command-id RunShellScript --instance-id &lt;INSTANCE_ID&gt; \</span><br><span class="line">    --scripts &quot;nc -vz &lt;API Server FQDN&gt; 443&quot;</span><br></pre></td></tr></table></figure><p><strong>成功の例</strong></p><p><code>Connection to &lt;API Server FQDN&gt; 443 port [tcp/https] succeeded!</code> とメッセージが表示されていれば、アクセスが成功しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_my-ResourceGroup_myAKSCluster_japaneast -n aks-nodepool1-27512147-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 2 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nc -vz myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io 443&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\n\n[stderr]\nConnection to myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io 443 port [tcp/https] succeeded!\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>失敗例</strong></p><p><code>nc: connect to &lt;API Server FQDN&gt; port 443 (tcp) failed</code> と表示された場合には、通信が失敗しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_my-ResourceGroup_myAKSCluster_japaneast -n aks-nodepool1-27512147-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 3 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nc -vz myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io 443&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\n\n[stderr]\nnc: connect to myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io port 443 (tcp) failed: No route to host\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>この場合、何らかの要因によってノードから送信された通信がブロックされている可能性が考えられます。<br>NSG やファイアーウォールで通信制御をしている場合は、AKS クラスターに必要な FQDN への通信が許可されているかご確認ください。</p><blockquote><p>ご参考) AKS クラスターに必要な送信ネットワーク規則と FQDN<br><a href="https://learn.microsoft.com/ja-jp/azure/aks/outbound-rules-control-egress#required-outbound-network-rules-and-fqdns-for-aks-clusters">https://learn.microsoft.com/ja-jp/azure/aks/outbound-rules-control-egress#required-outbound-network-rules-and-fqdns-for-aks-clusters</a></p></blockquote><p>プライベート AKS クラスターでは、API サーバーへのアクセスにプライベート エンドポイントを使用します。<br>VNet に独自のプライベート エンドポイント リソースを作成している場合は、対象の AKS クラスターのプライベート エンドポイントとして正しく構成されているかご確認ください。</p><blockquote><p>ご参考) プライベート エンドポイント接続を使用する<br><a href="https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#use-a-private-endpoint-connection">https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#use-a-private-endpoint-connection</a><br>特に、プライベート クラスターの停止・再起動をした場合には、このドキュメントの「警告」に記載の内容をご確認ください。</p></blockquote><h3 id="ExitCode-52"><a href="#ExitCode-52" class="headerlink" title="ExitCode: 52"></a>ExitCode: 52</h3><p>ExitCode: 52 のエラーは、DNS を使用して、AKS ノードが AKS API サーバーの完全修飾ドメイン名 (FQDN) を名前解決できない場合に発生します。</p><blockquote><p><strong>K8SAPIServerDNSLookupFailVMExtensionError エラー コードのトラブルシューティング (52) - Azure / Microsoft Learn</strong><br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-k8sapiserverdnslookupfailvmextensionerror">https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-k8sapiserverdnslookupfailvmextensionerror</a></p></blockquote><h4 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h4><p>AKS ノードが動作するためには、AKS の API サーバーにアクセスする必要があります。</p><p>AKS ノードが AKS API サーバーに正常にアクセスできない場合には、ノードの初期化が成功しません。<br>アクセスできない要因が、DNS を利用して AKS API サーバーの FQDN を IP アドレスへ名前解決できないことである場合に ExitCode: 52 が発生します。</p><p>ExitCode: 52 が発生した場合は、DNS による名前解決が関連しているものと要因箇所を絞り込めます。</p><h4 id="トラブルシューティング-2"><a href="#トラブルシューティング-2" class="headerlink" title="トラブルシューティング"></a>トラブルシューティング</h4><p>はじめに、対象の AKS クラスターで使用されている API サーバーの FQDN を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az aks show -g &lt;RESOURCE GROUP&gt; --name &lt;CLUSTER&gt; --query fqdn</span><br></pre></td></tr></table></figure><p><code>az vmss run-command</code> コマンドを利用して、VMSS インスタンス上で名前解決の検証コマンドを実行します。<br>次のように、<code>nslookup</code> コマンドに API サーバーの FQDN を指定して実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">az vmss run-command invoke -g &lt;NODE RESOURCE GROUP&gt; -n &lt;VMSS NAME&gt; \</span><br><span class="line">    --command-id RunShellScript --instance-id &lt;INSTANCE_ID&gt; \</span><br><span class="line">    --scripts &quot;nslookup &lt;API Server FQDN&gt;&quot;</span><br></pre></td></tr></table></figure><p><strong>成功の例</strong></p><p><code>&quot;message&quot;</code> フィールドに <code>nslookup</code> コマンドの実行結果が出力されます。<br><code>Address: 10.240.0.5</code> のように、AKS API サーバーの IP アドレスが表示されていれば、名前解決は成功しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_my-ResourceGroup_myAKSCluster_japaneast -n aks-nodepool1-27512147-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 4 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nslookup myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\nServer:\t\t168.63.129.16\nAddress:\t168.63.129.16#53\n\nNon-authoritative answer:\nName:\tmyakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io\nAddress: 10.240.0.4\n\n\n[stderr]\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記の例では、プライベート AKS クラスターの名前解決のため、IP アドレスは VNet に割り当てられているプライベート IP アドレスとなっています。</p><p><strong>失敗の例</strong></p><p>IP アドレスが出力されておらず、<code>server can&#39;t find &lt;API Server FQDN&gt;</code> のようなエラーメッセージや <code>NXDOMAIN</code> が出力されている場合は、名前解決が成功していません。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_test-RG_myAKSCluster-test_japaneast -n aks-nodepool1-73583151-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 0 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nslookup myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\nServer:\t\t192.168.1.4\nAddress:\t192.168.1.4#53\n\n** server can&#x27;t find myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io: NXDOMAIN\n\n\n[stderr]\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記の例では、DNS サーバー <code>192.168.1.4</code> が名前解決の結果を応答しています。この DNS サーバーは、Azure 既定で提供される DNS サービスではなく、VNet に設定した<a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-networks-name-resolution-for-vms-and-role-instances?tabs=redhat#name-resolution-that-uses-your-own-dns-server">カスタム DNS サーバー</a>です。</p><p>名前解決の結果が <code>NXDOMAIN</code> となっています。要求された FQDN に該当する DNS レコードがカスタム DNS サーバー内で見つからず、「そのドメイン名は存在しない」という結果を応答しています。<br>この場合、カスタム DNS サーバーの動作・設定を確認し、AKS API サーバーの IP アドレスに名前解決できる状態であるかを確認します。</p><p>カスタム DNS サーバー上に DNS レコードを作成している場合は、API サーバーの正しい IP アドレスで A レコードが作成されていることを確認します。<br>名前解決のリクエストを<a href="https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#hub-and-spoke-with-custom-dns">上位の DNS サーバーに転送</a>している場合は、DNS フォワーダーが正しく設定・動作しているかを確認します。</p><h3 id="ExitCode-53"><a href="#ExitCode-53" class="headerlink" title="ExitCode: 53"></a>ExitCode: 53</h3><p>ExitCode: 53 のエラーは、<a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-networks-name-resolution-for-vms-and-role-instances">Azure 既定の DNS サービス</a>を使用して、AKS ノードが AKS API サーバーの完全修飾ドメイン名 (FQDN) を名前解決できない場合に発生します。</p><h4 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h4><p>AKS ノードが AKS API サーバーに正常にアクセスできない場合に発生します。<br>状況は ExitCode: 52 と似ていますが、異なる点は、名前解決の結果を応答した DNS サーバーです。</p><p>VNet にカスタム DNS サーバーが設定されていない場合は、Azure の DNS サービスによって名前解決が提供されます。<br>Azure 既定の DNS サービスである <code>168.63.129.16</code> で名前解決が成功しなかった場合に、ExitCode: 53 が発生します。</p><blockquote><p>ご参考) IP アドレス 168.63.129.16 とは<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/what-is-ip-address-168-63-129-16">https://learn.microsoft.com/ja-jp/azure/virtual-network/what-is-ip-address-168-63-129-16</a></p></blockquote><p>(プライベートではない) 通常の AKS クラスターと、プライベート AKS クラスターの一部の構成では、クラスター作成と同時に API サーバーの DNS レコードが作成されるため、API サーバーの名前解決の結果が <code>NXDOMAIN</code> にはならない想定です。<br>一方、プライベート AKS クラスターの作成時に、独自の Azure Private DNS Zone を使用するように指定した場合では注意が必要です。</p><p>Azure Private DNS Zone を使用した名前解決では、DNS のリクエストを Azure の DNS サービスに対して送信します。<br>Private DNS Zone 内に AKS API サーバーの DNS レコードが存在しないと、<code>168.63.129.16</code> から <code>NXDOMAIN</code> の応答が返され、ExitCode: 53 が発生します。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>プライベート AKS クラスターでは、クラスター作成時の<code>--private-dns-zone</code> オプションに応じて、API サーバーの DNS レコードの管理方法が変更可能です。</p><p>ご参考) プライベート DNS ゾーンを構成する</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#configure-a-private-dns-zone">https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#configure-a-private-dns-zone</a></p></div><h4 id="トラブルシューティング-3"><a href="#トラブルシューティング-3" class="headerlink" title="トラブルシューティング"></a>トラブルシューティング</h4><p>はじめに、対象の AKS クラスターで使用されている API サーバーの FQDN を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az aks show -g &lt;RESOURCE GROUP&gt; --name &lt;CLUSTER&gt; --query fqdn</span><br></pre></td></tr></table></figure><p><code>az vmss run-command</code> コマンドを利用して、VMSS インスタンス上で名前解決の検証コマンドを実行します。<br>次のように、<code>nslookup</code> コマンドに API サーバーの FQDN を指定して実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">az vmss run-command invoke -g &lt;NODE RESOURCE GROUP&gt; -n &lt;VMSS NAME&gt; \</span><br><span class="line">    --command-id RunShellScript --instance-id &lt;INSTANCE_ID&gt; \</span><br><span class="line">    --scripts &quot;nslookup &lt;API Server FQDN&gt;&quot;</span><br></pre></td></tr></table></figure><p><strong>成功の例</strong></p><p><code>&quot;message&quot;</code> フィールドに <code>nslookup</code> コマンドの実行結果が出力されます。<br><code>Address: 10.240.0.5</code> のように、AKS API サーバーの IP アドレスが表示されていれば、名前解決は成功しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_my-RG_myAKSCluster_japaneast -n aks-nodepool1-22506348-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 0 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nslookup myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\nServer:\t\t168.63.129.16\nAddress:\t168.63.129.16#53\n\nNon-authoritative answer:\nName:\tmyakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io\nAddress: 10.240.0.4\n\n\n[stderr]\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>失敗の例</strong></p><p>IP アドレスが出力されておらず、<code>server can&#39;t find &lt;API Server FQDN&gt;</code> のようなエラーメッセージや <code>NXDOMAIN</code> が出力されている場合は、名前解決が成功していません。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_my-RG_myAKSCluster_japaneast -n aks-nodepool1-22506348-vmss</span> </span><br><span class="line">    --command-id RunShellScript --instance-id 0 \</span><br><span class="line">    --scripts &quot;nslookup myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io&quot;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\nServer:\t\t168.63.129.16\nAddress:\t168.63.129.16#53\n\n** server can&#x27;t find myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io: NXDOMAIN\n\n\n[stderr]\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記の例では、プライベート AKS クラスターの FQDN の名前解決を検証しています。<br>名前解決の結果を応答した DNS サーバーが、Azure の DNS サービスで使用される IP アドレス <code>168.63.129.16</code> となっていることが確認できます。<br><code>NXDOMAIN</code> が返されているため、API サーバーの FQDN に該当する DNS レコードが発見できなかった状態となります。</p><p>このような場合は、Private DNS Zone の構成と DNS レコードの作成状況を確認します。<br>AKS ノードが存在する VNet と、Private DNS Zone との間に仮想ネットワーク リンクが設定されていることを確認します。<br>また、AKS API サーバーの FQDN に該当する A レコードが作成されているかどうかを確認します。<br>仮想ネットワーク リンクの構成方法と DNS レコードの作成については、次のプライベート AKS クラスターのドキュメントをご参照ください。</p><blockquote><p>ご参考) プライベート エンドポイント接続を使用する<br><a href="https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#use-a-private-endpoint-connection">https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#use-a-private-endpoint-connection</a></p></blockquote><div class="alert is-warning"><p class="alert-title">警告</p><p>プライベート エンドポイントのリソースをお客様にて独自に作成されている場合は、クラスターの停止・起動において注意が必要です。</p><p>この場合、クラスターの停止と再起動をすると、プライベート リンク サービスが削除され、プライベート エンドポイントとプライベート AKS クラスターの間の接続が切断されます。</p><p>この問題を解決するには、プライベート エンドポイントの再作成ならびに DNS レコードの再登録が必要です。</p><p>下記リンクの「警告」のセクションをあわせてご確認ください。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#link-the-private-dns-zone-to-the-virtual-network">https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#link-the-private-dns-zone-to-the-virtual-network</a></p></div><h3 id="その他の-ExitCode"><a href="#その他の-ExitCode" class="headerlink" title="その他の ExitCode"></a>その他の ExitCode</h3><p>上記で紹介した 50 ～ 53 の ExitCode が、AKS において発生することのある代表的な ExitCode となります。</p><p>このほかにも、ExitCode の定義自体はいくつかの種類があり、ごく稀に本記事で紹介したものとは異なる ExitCode が発生する場合がございます。</p><blockquote><p>トラブルシューティング ページに記載のある ExitCode では、ExitCode 124 が挙げられます。<br>　<br>ご参考) ERR_VHD_FILE_NOT_FOUND エラー コードのトラブルシューティング - Azure / Microsoft Learn<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-vhdfilenotfound">https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-vhdfilenotfound</a></p></blockquote><p>ExitCode の一覧は、AKS ノードイメージの生成で使われるスクリプト内に定義がございます。<br>このスクリプトは GitHub のリポジトリに公開されていますので、ご興味のある方は下記 URL よりご確認ください。</p><blockquote><p>ご参考) vmssCSE exit codes<br><a href="https://github.com/Azure/AgentBaker/blob/master/parts/linux/cloud-init/artifacts/cse_helpers.sh">https://github.com/Azure/AgentBaker/blob/master/parts/linux/cloud-init/artifacts/cse_helpers.sh</a></p></blockquote><p>万が一、本記事や AKS トラブルシューティングのページに記載のない ExitCode が発生し、お客様にてトラブルシューティングが難しい場合には、お気兼ねなく Azure サポートまでご相談ください。</p><h2 id="vmssCSE-拡張機能が成功しなかったノードの復旧"><a href="#vmssCSE-拡張機能が成功しなかったノードの復旧" class="headerlink" title="vmssCSE 拡張機能が成功しなかったノードの復旧"></a>vmssCSE 拡張機能が成功しなかったノードの復旧</h2><p>VMSS インスタンスの拡張機能は、インスタンスを”再イメージ化”することで、あらためて実行可能です。</p><p>ノード初期化を妨げる要因を取り除いたあとは、VMSS インスタンスの再イメージ化を行い、クラスターにノードが追加されることをご確認ください。<br>再イメージ化の方法は、次の URL のドキュメントをご参照ください。</p><blockquote><p>ご参考) 既存の VM の “再イメージ化”<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-upgrade-policy#exceptions-to-upgrade-policies">https://learn.microsoft.com/ja-jp/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-upgrade-policy#exceptions-to-upgrade-policies</a></p></blockquote><p>すでに存在する VMSS インスタンスはそのままの状態で、新規ノードが作成可能であるかを確認したいという場合には、ノードプールのスケール操作によって、ノードの追加をすることをご検討ください。<br>ノードプールのスケール方法は、次の URL のドキュメントをご参照ください。</p><blockquote><p>ご参考) ノード プールの手動でのスケーリング<br><a href="https://learn.microsoft.com/ja-jp/azure/aks/manage-node-pools#scale-a-node-pool-manually">https://learn.microsoft.com/ja-jp/azure/aks/manage-node-pools#scale-a-node-pool-manually</a></p></blockquote><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>今回紹介しました内容が、AKS をよりご活用いただくうえでのご参考になりましたら幸いです。<br>また、AKS のご利用において、お困りの点やご不明点がありました際は、いつでも Azure サポートまでお気兼ねなくご相談ください。</p><hr><p>本記事の執筆にあたっては、Azure テクニカル サポートチームの沈さんはじめ多くの方々にご支援をいただきました。<br>この場をお借りし、ご協力いただいた皆様に深く感謝申し上げます。ありがとうございました。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポートチームの桐井です。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/ja-jp/azure/aks/intro-kubernetes&quot;&gt;Azure Kubernetes Service (AKS)&lt;/a&gt; クラスターで、ノードの新規作成が成功しない事象や、停止したクラスターの起動が成功しないといった事象が発生することがございます。&lt;/p&gt;
&lt;p&gt;このような事象は、ノードの初期化が成功していない場合に発生するもので、弊社サポート事例においても多くのお客様よりご相談をいただくことがございます。&lt;/p&gt;
&lt;p&gt;本記事では、AKS ノードの初期化を担う vmssCSE 拡張機能についての解説と、ノード初期化が成功しない代表的な要因とトラブルシューティング方法について紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>ゾーン未指定時の VM 起動ゾーン、およびサブスクリプション毎のゾーン番号指す物理ゾーンについて</title>
    <link href="https://jpaztech.github.io/blog/vm/physical-zone/"/>
    <id>https://jpaztech.github.io/blog/vm/physical-zone/</id>
    <published>2023-12-04T04:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.963Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>今年も日本マイクロソフトの社員がお届けする、<a href="https://qiita.com/advent-calendar/2023/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2023</a> の「シリーズ 2」、12 月 4 日分の記事として公開させていただきます。<br>Advent Calendar には他にも多くの Azure に関する有益な記事がございますので、是非ご参照いただけますと幸いです。</p><p>本記事ではお問い合わせ頂くことも多い、 Azure VM で可用性ゾーンを未指定の場合にはゾーン番号が何処になるかは分からない点と、サブスクリプション毎にゾーン番号が指し示す物理ゾーンが違う点について解説させていただきます。  </p><hr><h2 id="可用性ゾーンを未指定の場合のゾーンについて"><a href="#可用性ゾーンを未指定の場合のゾーンについて" class="headerlink" title="可用性ゾーンを未指定の場合のゾーンについて"></a>可用性ゾーンを未指定の場合のゾーンについて</h2><p>可用性ゾーンに対応するリージョンでは Azure VM の可用性ゾーンを指定することで、ご希望のゾーン上に VM をデプロイすることが可能です。<br>ゾーンは原則 1 ～ 3 番のゾーン番号で指定が可能でございます。  </p><blockquote><p>■ご参考：可用性ゾーン<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/availability#availability-zones">https://learn.microsoft.com/ja-jp/azure/virtual-machines/availability#availability-zones</a></p></blockquote><p>なお、可用性ゾーンを未指定の場合はゾーン 1 ～ 3 いずれかのゾーンで VM が起動されますが、どのゾーンで VM が起動されるかは把握することは叶いません。<br>VM 割り当て解除をして起動することでゾーンが変更となることもございます。<br>加えて現在どのゾーンで VM が起動しているかといったことも確認をすることが叶いません。<br>特定ゾーンでの稼働が必要な場合は、可用性ゾーンを指定して VM をデプロイいただくようにお願いいたします。  </p><hr><h2 id="サブスクリプション毎にゾーン番号が指し示す物理ゾーンが違う点について"><a href="#サブスクリプション毎にゾーン番号が指し示す物理ゾーンが違う点について" class="headerlink" title="サブスクリプション毎にゾーン番号が指し示す物理ゾーンが違う点について"></a>サブスクリプション毎にゾーン番号が指し示す物理ゾーンが違う点について</h2><p>Azure ポータル等で表示・指定できるゾーン番号は、サブスクリプション毎に指し示す物理ゾーンが異なります。<br>Azure ポータル等で表示・指定できるゾーン番号のことを「論理ゾーン」、実際の物理的なゾーンの場所のことを「物理ゾーン」と呼びます。<br>例えば東日本リージョンでは以下のように物理ゾーンが 3 つございます。  </p><ul><li>japaneast-az1 </li><li>japaneast-az2 </li><li>japaneast-az3</li></ul><p>この際にサブスクリプションによって、以下の例のように指し示すゾーンが違う場合がございます。  </p><p><strong>contoso サブスクリプションの場合</strong></p><table><thead><tr><th align="left">論理ゾーン番号</th><th align="left">実際の物理ゾーン</th></tr></thead><tbody><tr><td align="left">1 番</td><td align="left">japaneast-az1</td></tr><tr><td align="left">2 番</td><td align="left">japaneast-az2</td></tr><tr><td align="left">3 番</td><td align="left">japaneast-az3</td></tr></tbody></table><p><strong>hogehoge サブスクリプションの場合</strong></p><table><thead><tr><th align="left">論理ゾーン番号</th><th align="left">実際の物理ゾーン</th></tr></thead><tbody><tr><td align="left">1 番</td><td align="left">japaneast-az3</td></tr><tr><td align="left">2 番</td><td align="left">japaneast-az1</td></tr><tr><td align="left">3 番</td><td align="left">japaneast-az2</td></tr></tbody></table><p>そのため、「contoso サブスクリプション」と「hogehoge サブスクリプション」でどちらも Azure ポータルから論理ゾーン 1 番に VM を作成したとしても、実際の物理ゾーンは違う場所であるといったことが発生します。<br>これは特定のゾーンに需要が偏らないようにするために必要な措置でございます点、ご理解いただけますと幸いです。  </p><hr><h2 id="論理ゾーンと物理ゾーンのマッピングを-REST-API-で確認する"><a href="#論理ゾーンと物理ゾーンのマッピングを-REST-API-で確認する" class="headerlink" title="論理ゾーンと物理ゾーンのマッピングを REST API で確認する"></a>論理ゾーンと物理ゾーンのマッピングを REST API で確認する</h2><p>論理ゾーン番号と実際の物理ゾーンのマッピングについては以下の REST API を用いて確認する事が可能です。  </p><p>■ご参考：Subscriptions - List Locations<br><a href="https://learn.microsoft.com/ja-jp/rest/api/resources/subscriptions/list-locations">https://learn.microsoft.com/ja-jp/rest/api/resources/subscriptions/list-locations</a></p><p>上記ページの「使ってみる」を選択し、対象サブスクリプションでログインした後に表示された画面で「実行」をすると、各リージョンについて、そのサブスクリプションでの論理ゾーン番号と実際の物理ゾーンのマッピングが<br>確認出来ます。<br>以下は実行結果例の抜粋です。この結果はサブスクリプション毎に違うことがございます。  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;/subscriptions/XXXX/locations/japaneast&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;japaneast&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;Region&quot;,</span><br><span class="line">～～～～～～～～～～中略～～～～～～～～～～</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;availabilityZoneMappings&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;logicalZone&quot;: &quot;1&quot;,</span><br><span class="line">          &quot;physicalZone&quot;: &quot;japaneast-az2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;logicalZone&quot;: &quot;2&quot;,</span><br><span class="line">          &quot;physicalZone&quot;: &quot;japaneast-az3&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;logicalZone&quot;: &quot;3&quot;,</span><br><span class="line">          &quot;physicalZone&quot;: &quot;japaneast-az1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>上記の例では、このサブスクリプションでは東日本リージョンで論理ゾーン 1 番を選ぶと、物理ゾーン japaneast-az2 にデプロイされるといったことが確認できます。  </p><hr><h2 id="サブスクリプション間の論理ゾーンのマッピングを-REST-API-で確認する"><a href="#サブスクリプション間の論理ゾーンのマッピングを-REST-API-で確認する" class="headerlink" title="サブスクリプション間の論理ゾーンのマッピングを REST API で確認する"></a>サブスクリプション間の論理ゾーンのマッピングを REST API で確認する</h2><p>別のサブスクリプションとの論理ゾーン同士のマッピングについても後述の通り REST API にて確認が可能です。<br>すなわち、「contoso 社サブスクリプション」の論理ゾーン 1 番は「hogehoge 社サブスクリプション」の論理ゾーン 2 番と同じである、との点について確認が可能です。  </p><p>■ご参考：Subscriptions - Check Zone Peers<br><a href="https://learn.microsoft.com/ja-jp/rest/api/resources/subscriptions/check-zone-peers">https://learn.microsoft.com/ja-jp/rest/api/resources/subscriptions/check-zone-peers</a></p><p>上記ページの「使ってみる」より、サブスクリプション間の論理ゾーンのマッピングを確認する方法を解説させていただきます。  </p><p>まずはこの比較用の Microsoft.Resources/AvailabilityZonePeering 機能が有効か確認します。<br>Azure Cloud Shell 等を用いて、比較元サブスクリプションにて以下の Azure CLI コマンドを実行します。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az feature show --namespace Microsoft.Resources --name AvailabilityZonePeering --subscription 比較元サブスクリプションID | jq .properties.state</span><br></pre></td></tr></table></figure><p>上記コマンドの結果として “Registered” と表示されていない場合は、以下の Azure CLI コマンドで機能を登録します。<br>なお、”Registered” の状態になるまでお時間がかかることがございます。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az feature register --namespace Microsoft.Resources --name AvailabilityZonePeering</span><br></pre></td></tr></table></figure><p>上記ページの「使ってみる」を選択して、比較元サブスクリプションでログインします。<br>その後表示された「REST API 使ってみる」のページにて、パラメーターの subscriptionId で比較元サブスクリプションを選択します。  </p><p>そして、「REST API 使ってみる」のページの本文のエリアに以下の例のように、比較対象のリージョンおよび比較先サブスクリプション ID を記載します。<br>以下の通り複数サブスクリプションを設定することも可能です。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;location&quot;: &quot;リージョン名（japaneast など）&quot;,</span><br><span class="line">  &quot;subscriptionIds&quot;: [</span><br><span class="line">    &quot;subscriptions/比較先サブスクリプションAのID&quot;,</span><br><span class="line">    &quot;subscriptions/比較先サブスクリプションBのID&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>その後、実行ボタンを選択すると以下の例のような結果が得られます。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;subscriptionId&quot;: &quot;比較元サブスクリプションID&quot;,</span><br><span class="line">  &quot;location&quot;: &quot;japaneast&quot;,</span><br><span class="line">  &quot;availabilityZonePeers&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;availabilityZone&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;peers&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;subscriptionId&quot;: &quot;比較先サブスクリプションAのID&quot;,</span><br><span class="line">          &quot;availabilityZone&quot;: &quot;3&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;subscriptionId&quot;: &quot;比較先サブスクリプションBのID&quot;,</span><br><span class="line">          &quot;availabilityZone&quot;: &quot;2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;availabilityZone&quot;: &quot;2&quot;,</span><br><span class="line">      &quot;peers&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;subscriptionId&quot;: &quot;比較先サブスクリプションAのID&quot;,</span><br><span class="line">          &quot;availabilityZone&quot;: &quot;2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;subscriptionId&quot;: &quot;比較先サブスクリプションBのID&quot;,</span><br><span class="line">          &quot;availabilityZone&quot;: &quot;1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;availabilityZone&quot;: &quot;3&quot;,</span><br><span class="line">      &quot;peers&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;subscriptionId&quot;: &quot;比較先サブスクリプションAのID&quot;,</span><br><span class="line">          &quot;availabilityZone&quot;: &quot;1&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;subscriptionId&quot;: &quot;比較先サブスクリプションBのID&quot;,</span><br><span class="line">          &quot;availabilityZone&quot;: &quot;3&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記の結果より、比較元サブスクリプションの論理ゾーン 1 は、  </p><ul><li>比較先サブスクリプション A では、論理ゾーン 3</li><li>比較先サブスクリプション B では、論理ゾーン 2</li></ul><p>と同じ、物理ゾーンを指しているといったマッピングの確認ができました。  </p><p>上述の内容がお客様のお役に立てますと幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;今年も日本マイクロソフトの社員がお届けする、&lt;a href=&quot;https://qiita.com/advent-calendar/2023/microsoft-azure-tech&quot;&gt;Microsoft</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>可用性セット・可用性ゾーン・近接配置グループの併用について</title>
    <link href="https://jpaztech.github.io/blog/vm/availability_options_with_ppg/"/>
    <id>https://jpaztech.github.io/blog/vm/availability_options_with_ppg/</id>
    <published>2023-12-04T03:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.775Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>Azure VM における可用性セット・可用性ゾーン・近接配置グループの併用について解説させていただきます。<br>結論から記載すると以下の通り併用可能・不可能といった状況となっております。  </p><ul><li>「可用性セット」と「可用性ゾーン」：併用できません</li><li>「可用性セット」と「近接配置グループ」：併用可</li><li>「可用性ゾーン」と「近接配置グループ」：併用可</li></ul><p>以下に解説させていただきます。<br>まず、「可用性セット」と「可用性ゾーン」はどちらも VM の可用性を高めるためのオプションでございます。  </p><p>「可用性セット」と「可用性ゾーン」はいずれも仮想マシンの配置を分散することで障害やメンテナンスの影響を同時に受けることを回避するという同じ目的で利用されますため、併用することは叶いません。<br>ご利用の際はどちらか片方のみをご選択いただくこととなります。<br>なお、可用性セットについては単一ゾーン内で分散される一方で、可用性ゾーンについては配置するゾーン自体を分散するためゾーン単位の障害に対する耐性がございます。  </p><p>他方、「近接配置グループ」は特定の複数の VM を物理的に近い位置に配置し、VM 間のレイテンシーを可能な限り低減するといったオプションとなります。<br>「近接配置グループ」は「可用性セット」もしくは「可用性ゾーン」との併用が可能です。<br>各機能については公式ドキュメントもご参照いただけますと幸いです。  </p><p>■ご参考：Azure Virtual Machines の可用性オプション<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/availability">https://learn.microsoft.com/ja-jp/azure/virtual-machines/availability</a></p><p>■ご参考：近接配置グループ<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/co-location">https://learn.microsoft.com/ja-jp/azure/virtual-machines/co-location</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;Azure VM における可用性セット・可用性ゾーン・近接配置グループの併用について解説させていただきます。&lt;br&gt;結論から記載すると以下の通り併用可能・不可能といった状況となっております。  &lt;/p&gt;</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>東日本リージョンでの Azure Firewall のゾーン冗長に関するアナウンスの補足 (Tracking ID:7KYK-R8G)</title>
    <link href="https://jpaztech.github.io/blog/network/fw_notification_7kyk-r8g/"/>
    <id>https://jpaztech.github.io/blog/network/fw_notification_7kyk-r8g/</id>
    <published>2023-12-01T05:30:00.000Z</published>
    <updated>2023-12-29T07:45:21.691Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームです。<br>2023 年 11 月 29 日に Azure Firewall で東日本リージョンの物理ゾーン #2 の使用に関するアナウンスがされました(Tracking ID:7KYK-R8G)。<br>アナウンスされた内容は英語でのご案内であるため、この記事にて補足させていただきます。</p><span id="more"></span><h2 id="通知内容の日本語抄訳"><a href="#通知内容の日本語抄訳" class="headerlink" title="通知内容の日本語抄訳"></a>通知内容の日本語抄訳</h2><p>東日本リージョンの物理ゾーン #2 にデプロイされた Azure Firewall に関する問題について、詳細をご報告いたします。<br>現在、可用性ゾーンを指定して Azure Firewall を構成する際に、東日本リージョンの物理ゾーン #2 をご利用いただくことが出来ないという問題が発生しております。<br>この問題は全ての SKU (basic / standard / premium) に影響があり、また、新規の Azure Firewall リソースのデプロイだけでなく、既存の Azure Firewall の起動にも影響を及ぼす可能性がございます。<br>現在事象の解消に向けた作業を実施しており、現時点で本制限は 2024 年 12 月に解除される予定となっております。</p><h3 id="対応が必要な事項"><a href="#対応が必要な事項" class="headerlink" title="対応が必要な事項"></a>対応が必要な事項</h3><p><strong>本記事では通知内容をよりわかりやすく整理しております。</strong></p><h4 id="1-東日本リージョンで新規に可用性ゾーンを持つ-Azure-Firewall-をデプロイしたい場合："><a href="#1-東日本リージョンで新規に可用性ゾーンを持つ-Azure-Firewall-をデプロイしたい場合：" class="headerlink" title="1 東日本リージョンで新規に可用性ゾーンを持つ Azure Firewall をデプロイしたい場合："></a>1 東日本リージョンで新規に可用性ゾーンを持つ Azure Firewall をデプロイしたい場合：</h4><p>1-1 お客様のサブスクリプション内で、東日本リージョンの物理ゾーン #2 にマッピングされている論理ゾーンの番号を確認してください。次項の<a href="#%E7%89%A9%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3-2-%E3%81%AB%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%9F%E8%AB%96%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3%E3%81%AE%E7%A2%BA%E8%AA%8D%E6%96%B9%E6%B3%95">物理ゾーン #2 にマッピングされた論理ゾーンの確認方法</a>をご覧ください。</p><p>1-2 物理ゾーン #2 にマッピングされている論理ゾーンの使用を避けてください。この地域の他のゾーンに  Azure Firewall をデプロイするか、別のリージョン（例：オーストラリア東部）にデプロイしてください。</p><h4 id="2-東日本リージョンで可用性ゾーンを指定せずに-Azure-Firewall-をデプロイしている場合："><a href="#2-東日本リージョンで可用性ゾーンを指定せずに-Azure-Firewall-をデプロイしている場合：" class="headerlink" title="2 東日本リージョンで可用性ゾーンを指定せずに Azure Firewall をデプロイしている場合："></a>2 東日本リージョンで可用性ゾーンを指定せずに Azure Firewall をデプロイしている場合：</h4><p>2-1 必要な対応はございません。</p><h4 id="3-東日本リージョンで単一の可用性ゾーンを指定して-Azure-Firewall-をデプロイしている場合："><a href="#3-東日本リージョンで単一の可用性ゾーンを指定して-Azure-Firewall-をデプロイしている場合：" class="headerlink" title="3 東日本リージョンで単一の可用性ゾーンを指定して Azure Firewall をデプロイしている場合："></a>3 東日本リージョンで単一の可用性ゾーンを指定して Azure Firewall をデプロイしている場合：</h4><p>3-1 お客様のサブスクリプション内で、東日本リージョンの物理ゾーン #2にマッピングされている論理ゾーンの番号を確認してください。次項の<a href="#%E7%89%A9%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3-2-%E3%81%AB%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%9F%E8%AB%96%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3%E3%81%AE%E7%A2%BA%E8%AA%8D%E6%96%B9%E6%B3%95">物理ゾーン #2 にマッピングされた論理ゾーンの確認方法</a>をご覧ください。</p><p>3-2 お客様の Azure Firewall が物理ゾーン #2 にマッピングされているゾーンでデプロイされている場合、<a href="https://learn.microsoft.com/ja-jp/azure/firewall/firewall-faq#-----------------------------:~:text=%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E5%BE%8C%E3%81%AB%E5%8F%AF%E7%94%A8%E6%80%A7%E3%82%BE%E3%83%BC%E3%83%B3%E3%82%92%E6%A7%8B%E6%88%90%E3%81%99%E3%82%8B%E3%81%AB%E3%81%AF%E3%81%A9%E3%81%86%E3%81%99%E3%82%8C%E3%81%B0%E3%82%88%E3%81%84%E3%81%A7%E3%81%99%E3%81%8B%3F">stop / startを使用して可用性ゾーンの設定を更新</a>し、他の可用性ゾーンを使用することが推奨されます。</p><h4 id="4-東日本リージョンで複数の可用性ゾーンにわたって-Azure-Firewall-をデプロイしている場合："><a href="#4-東日本リージョンで複数の可用性ゾーンにわたって-Azure-Firewall-をデプロイしている場合：" class="headerlink" title="4 東日本リージョンで複数の可用性ゾーンにわたって Azure Firewall をデプロイしている場合："></a>4 東日本リージョンで複数の可用性ゾーンにわたって Azure Firewall をデプロイしている場合：</h4><p>4-1 お客様のサブスクリプション内で、東日本リージョンの物理ゾーン #2にマッピングされている論理ゾーンの番号を確認してください。次項の<a href="#%E7%89%A9%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3-2-%E3%81%AB%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%9F%E8%AB%96%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3%E3%81%AE%E7%A2%BA%E8%AA%8D%E6%96%B9%E6%B3%95">物理ゾーン #2 にマッピングされた論理ゾーンの確認方法</a>をご覧ください。</p><p>4-2 お客様の Azure Firewall が物理ゾーン #2 にマッピングされているゾーンを含んでデプロイされている場合でもそのままご利用いただけますが、何らかの理由でこのファイアウォールを<a href="https://learn.microsoft.com/ja-jp/azure/firewall/firewall-faq#azure-firewall-----------------:~:text=Azure%20Firewall%20%E3%81%AE%E5%81%9C%E6%AD%A2%E3%81%A8%E8%B5%B7%E5%8B%95%E3%81%AE%E6%96%B9%E6%B3%95%E3%82%92%E6%95%99%E3%81%88%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84">停止</a>した場合、物理ゾーン #2 を除いた<a href="https://learn.microsoft.com/ja-jp/azure/firewall/firewall-faq#-----------------------------:~:text=%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E5%BE%8C%E3%81%AB%E5%8F%AF%E7%94%A8%E6%80%A7%E3%82%BE%E3%83%BC%E3%83%B3%E3%82%92%E6%A7%8B%E6%88%90%E3%81%99%E3%82%8B%E3%81%AB%E3%81%AF%E3%81%A9%E3%81%86%E3%81%99%E3%82%8C%E3%81%B0%E3%82%88%E3%81%84%E3%81%A7%E3%81%99%E3%81%8B%3F">異なる Availability Zones の設定で再起動</a>する必要があります。</p><p>以上の条件と必要な対応をまとめたフローチャートは以下の通りになります。<br><img src="./flow_chart.png"></p><h3 id="物理ゾーン-2-にマッピングされた論理ゾーンの確認方法"><a href="#物理ゾーン-2-にマッピングされた論理ゾーンの確認方法" class="headerlink" title="物理ゾーン #2 にマッピングされた論理ゾーンの確認方法"></a>物理ゾーン #2 にマッピングされた論理ゾーンの確認方法</h3><p>物理ゾーンは、Azure サブスクリプションや地域ごとに異なる論理ゾーンにマッピングされています。お客様のAzureサブスクリプションでこの物理ゾーンにマッピングされた論理ゾーンを確認するには、<a href="https://learn.microsoft.com/en-us/azure/reliability/availability-zones-overview?tabs=azure-cli#physical-and-logical-availability-zones">本ドキュメントの手順</a>をご実施ください。（現在、ドキュメントは英語のみとなります。本ブログ記事の<a href="#%E7%89%A9%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3%E3%81%A8%E8%AB%96%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3%E3%81%AE%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0%E3%81%AE%E7%A2%BA%E8%AA%8D%E6%96%B9%E6%B3%95">物理ゾーンと論理ゾーンのマッピングの確認方法</a>にも手順を記載しております。）</p><p>本問題に関して、情報のアップデートが行われた際には、速やかに最新の情報をご案内いたします。<br>この度は、お客様にご不便をおかけし、大変申し訳ありません。</p><h2 id="物理ゾーンと論理ゾーンのマッピングの確認方法"><a href="#物理ゾーンと論理ゾーンのマッピングの確認方法" class="headerlink" title="物理ゾーンと論理ゾーンのマッピングの確認方法"></a>物理ゾーンと論理ゾーンのマッピングの確認方法</h2><p>物理ゾーンと論理ゾーンのマッピングは以下のコマンドで確認が可能です。</p><p>Azure CLI の場合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az rest --method get --uri <span class="string">&#x27;/subscriptions/&#123;サブスクリプション ID&#125;/locations?api-version=2022-12-01&#x27;</span> --query <span class="string">&#x27;value&#x27;</span></span><br></pre></td></tr></table></figure><p>Azure PowerShell の場合</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$subscriptionId</span> = (<span class="built_in">Get-AzContext</span>).Subscription.ID</span><br><span class="line"><span class="variable">$response</span> = <span class="built_in">Invoke-AzRestMethod</span> <span class="literal">-Method</span> GET <span class="literal">-Path</span> <span class="string">&quot;/subscriptions/<span class="variable">$subscriptionId</span>/locations?api-version=2022-12-01&quot;</span></span><br><span class="line"><span class="variable">$locations</span> = (<span class="variable">$response</span>.Content | <span class="built_in">ConvertFrom-Json</span>).value | <span class="built_in">where</span> &#123; <span class="variable">$_</span>.Name <span class="operator">-eq</span> <span class="string">&quot;japaneast&quot;</span> &#125;; <span class="variable">$locations</span></span><br></pre></td></tr></table></figure><p>コマンドを実行すると、各リージョンの物理ゾーンと論理ゾーンのマッピング情報が取得できます。このマッピングはサブスクリプションごとに異なります。<br>以下は各コマンドごとの取得したマッピング情報の抜粋となります。</p><p>Azure CLI の場合</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;availabilityZoneMappings&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;logicalZone&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;physicalZone&quot;</span>: <span class="string">&quot;japaneast-az2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;logicalZone&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;physicalZone&quot;</span>: <span class="string">&quot;japaneast-az3&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;logicalZone&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;physicalZone&quot;</span>: <span class="string">&quot;japaneast-az1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>Azure PowerShell の場合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">id                       : /subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/locations/japaneast</span><br><span class="line">name                     : japaneast</span><br><span class="line">type                     : Region</span><br><span class="line">displayName              : Japan East</span><br><span class="line">regionalDisplayName      : (Asia Pacific) Japan East</span><br><span class="line">metadata                 : @&#123;regionType=Physical; regionCategory=Recommended; geography=Japan; geographyGroup=Asia Paci</span><br><span class="line">                           fic; longitude=139.77; latitude=35.68; physicalLocation=Tokyo, Saitama; pairedRegion=System.</span><br><span class="line">                           Object[]&#125;</span><br><span class="line">availabilityZoneMappings : &#123;@&#123;logicalZone=1; physicalZone=japaneast-az2&#125;, @&#123;logicalZone=2; physicalZone=japaneast-az3&#125;,</span><br><span class="line">                            @&#123;logicalZone=3; physicalZone=japaneast-az1&#125;&#125;</span><br></pre></td></tr></table></figure><p>logicalZone が論理ゾーンとなり、通常、ポータルやコマンドで見えているゾーンの番号となります。<br>physicalZone が物理ゾーンとなります。<br>今回は japaneast-az2 と紐づいている logicalZone の番号を Azure Firewall のデプロイ時に指定しないように対応が必要となります。</p><h2 id="Azure-Firewall-の可用性ゾーンの確認方法"><a href="#Azure-Firewall-の可用性ゾーンの確認方法" class="headerlink" title="Azure Firewall の可用性ゾーンの確認方法"></a>Azure Firewall の可用性ゾーンの確認方法</h2><p>Azure Firewall の可用性ゾーンは Azure ポータル &gt; Azure Firewall リソース &gt; プロパティ ブレード &gt; 可用性ゾーンの項目から確認できます。<br><br>以下の画像は可用性ゾーンの指定がない Azure Firewall の画面です。<br><img src="./azfw_az.png"></p><h2 id="Azure-Firewall-の停止および可用性ゾーンを指定する開始方法"><a href="#Azure-Firewall-の停止および可用性ゾーンを指定する開始方法" class="headerlink" title="Azure Firewall の停止および可用性ゾーンを指定する開始方法"></a>Azure Firewall の停止および可用性ゾーンを指定する開始方法</h2><p>Azure Firewall の Azure PowerShell での停止方法は以下のコマンドになります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$azfw</span> = <span class="built_in">Get-AzFirewall</span> <span class="literal">-Name</span> <span class="string">&quot;ファイアウォール名&quot;</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span></span><br><span class="line"><span class="variable">$azfw</span>.Deallocate()</span><br><span class="line"><span class="built_in">Set-AzFirewall</span> <span class="literal">-AzureFirewall</span> <span class="variable">$azfw</span></span><br></pre></td></tr></table></figure><div class="alert is-warning"><p class="alert-title">警告</p><p>単一の可用性ゾーンを指定して Azure Firewall と同時に作成された パブリック IP は他の可用性ゾーンでは使用できません。新たに Standard のパブリック IP アドレス リソースを他の可用性ゾーンに対応する形で作成しておく必要があります。</p></div><p>パブリック IP アドレスの作成についての詳細は以下のドキュメントをご参考ください。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/ip-services/virtual-network-public-ip-address">Azure パブリック IP アドレスを作成、変更、または削除する - Azure Virtual Network | Microsoft Learn</a></p><p> Azure PowerShell で全ての可用性ゾーンに対応した パブリック IP アドレスを作成するには以下のコマンドで行えます。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ip</span> = <span class="selector-tag">@</span>&#123;</span><br><span class="line">    Name = <span class="string">&#x27;新しい Public IP 名&#x27;</span></span><br><span class="line">    ResourceGroupName = <span class="string">&#x27;リソースグループ名&#x27;</span></span><br><span class="line">    Location = <span class="string">&#x27;japaneast&#x27;</span></span><br><span class="line">    Sku = <span class="string">&#x27;Standard&#x27;</span></span><br><span class="line">    AllocationMethod = <span class="string">&#x27;Static&#x27;</span></span><br><span class="line">    IpAddressVersion = <span class="string">&#x27;IPv4&#x27;</span></span><br><span class="line">    Zone = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">New-AzPublicIpAddress</span> @ip</span><br></pre></td></tr></table></figure><p>例として、論理ゾーン 1 が物理ゾーン 2 の場合において、論理ゾーン 2, 3（物理ゾーン 1, 3）を指定して Azure Firewall を Azure PowerShell で開始する方法は以下のコマンドになります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$azfw</span> = <span class="built_in">Get-AzFirewall</span> <span class="literal">-Name</span> <span class="string">&quot;ファイアウォール名&quot;</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span></span><br><span class="line"><span class="variable">$vnet</span> = <span class="built_in">Get-AzVirtualNetwork</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span> <span class="literal">-Name</span> <span class="string">&quot;VNet 名&quot;</span></span><br><span class="line"><span class="variable">$pip</span>= <span class="built_in">Get-AzPublicIpAddress</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span> <span class="literal">-Name</span> <span class="string">&quot;Public IP 名&quot;</span></span><br><span class="line"><span class="variable">$azfw</span>.Allocate(<span class="variable">$vnet</span>, <span class="variable">$pip</span>)</span><br><span class="line"><span class="variable">$azFw</span>.Zones=<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="variable">$azfw</span> | <span class="built_in">Set-AzFirewall</span></span><br></pre></td></tr></table></figure><p>例として、2 つの Public IP が関連付けられており、マネージメント サブネットの Public IP がある Azure Firewall を論理ゾーン 2, 3（物理ゾーン 1, 3）を指定して Azure PowerShell で開始する方法は以下のコマンドになります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$azfw</span> = <span class="built_in">Get-AzFirewall</span> <span class="literal">-Name</span> <span class="string">&quot;ファイアウォール名&quot;</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span></span><br><span class="line"><span class="variable">$vnet</span> = <span class="built_in">Get-AzVirtualNetwork</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span> <span class="literal">-Name</span> <span class="string">&quot;VNet 名&quot;</span></span><br><span class="line"><span class="variable">$pip1</span>= <span class="built_in">Get-AzPublicIpAddress</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span> <span class="literal">-Name</span> <span class="string">&quot;Public IP 名&quot;</span></span><br><span class="line"><span class="variable">$pip2</span>= <span class="built_in">Get-AzPublicIpAddress</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span> <span class="literal">-Name</span> <span class="string">&quot;Public IP2 名&quot;</span></span><br><span class="line"><span class="variable">$mgmtPip</span> = <span class="built_in">Get-AzPublicIpAddress</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span> <span class="literal">-Name</span> <span class="string">&quot;マネージメント サブネットの Public IP 名&quot;</span></span><br><span class="line"><span class="variable">$azfw</span>.Allocate(<span class="variable">$vnet</span>, <span class="selector-tag">@</span>(<span class="variable">$pip1</span>,<span class="variable">$pip2</span>), <span class="variable">$mgmtPip</span>)</span><br><span class="line"><span class="variable">$azFw</span>.Zones=<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="variable">$azfw</span> | <span class="built_in">Set-AzFirewall</span></span><br></pre></td></tr></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="Azure-Firewall-を物理ゾーン-2-のみにデプロイしている場合の影響は何ですか"><a href="#Azure-Firewall-を物理ゾーン-2-のみにデプロイしている場合の影響は何ですか" class="headerlink" title="Azure Firewall を物理ゾーン #2 のみにデプロイしている場合の影響は何ですか"></a>Azure Firewall を物理ゾーン #2 のみにデプロイしている場合の影響は何ですか</h3><p>Azure Firewall が処理するトラフィック量が増加した際のスケールアウトが失敗する可能性があります。</p><h3 id="SLA-に影響ありますか"><a href="#SLA-に影響ありますか" class="headerlink" title="SLA に影響ありますか"></a>SLA に影響ありますか</h3><p>今回の通知内容の事象が SLA に影響することはございません。<br>SLA については以下のドキュメントの「可用性ゾーン」の項目に記載がございます。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/firewall/features#availability-zones">Azure Firewall Standard の機能</a></p><h3 id="費用の差異はありますか"><a href="#費用の差異はありますか" class="headerlink" title="費用の差異はありますか"></a>費用の差異はありますか</h3><p>今回の事象の発生期間と発生していない期間では、Azure Firewall の費用に対しての違いはございません。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームです。&lt;br&gt;2023 年 11 月 29 日に Azure Firewall で東日本リージョンの物理ゾーン #2 の使用に関するアナウンスがされました(Tracking ID:7KYK-R8G)。&lt;br&gt;アナウンスされた内容は英語でのご案内であるため、この記事にて補足させていただきます。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="Azure Firewall" scheme="https://jpaztech.github.io/blog/tags/Azure-Firewall/"/>
    
  </entry>
  
  <entry>
    <title>お問い合わせの発行方法について</title>
    <link href="https://jpaztech.github.io/blog/information/How-to-inquiry-to-the-Azure-Support/"/>
    <id>https://jpaztech.github.io/blog/information/How-to-inquiry-to-the-Azure-Support/</id>
    <published>2023-11-27T05:52:00.000Z</published>
    <updated>2023-12-29T07:45:21.667Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームです。</p><p>私たちは、Azure をご利用いただいているお客様に、Azure を正常かつ快適にご利用いただくためのご支援を差し上げています。<br>この度、Azure サポートを効果的に利用するやり方について知りたい、というご要望を頂戴しましたので、以下にサポートへのお問い合わせ方法をご案内させていただきます。</p><span id="more"></span><p>本資料は、以下のようなお客様にお読みいただくことを想定しています。  </p><ul><li>お問い合わせを起票するための契約や、お問い合わせ発行から連絡をもらえるまでの応答時間などのルールと流れを知りたい</li><li>マイクロソフトのサポートからどのような内容を対応してもらえるのか知っておきたい</li><li>Azure サポートを利用する際にどのように起票すれば効率的に成果が得られるか知りたい</li></ul><p>なお、以下に記載しました内容はあくまで 「一般的なお問合せの流れ」 をご紹介していますので、もしこちらに記載がなくお悩みの点がございましたら、一旦お問合せを起票いただくか、既に対応させていただいている件があればそちらの担当サポートエンジニアまで、お気兼ねなくご相談をいただければ幸いです。</p><hr><h2 id="サポート-リクエスト-お問い合わせ-の作成"><a href="#サポート-リクエスト-お問い合わせ-の作成" class="headerlink" title="サポート リクエスト (お問い合わせ) の作成"></a>サポート リクエスト (お問い合わせ) の作成</h2><p>サポートリクエストの作成方法は大きく分けて以下の 2 つの方法にて作成可能です。  </p><ol><li>対象リソースの画面よりサポートリクエストを作成する（推奨）</li><li>ヘルプとサポートの画面よりサポートリクエストを作成する</li></ol><p>それぞれの方法についてご説明させていただきます。</p><h3 id="対象リソースの画面よりサポートリクエストを作成する（推奨）"><a href="#対象リソースの画面よりサポートリクエストを作成する（推奨）" class="headerlink" title="対象リソースの画面よりサポートリクエストを作成する（推奨）"></a>対象リソースの画面よりサポートリクエストを作成する（推奨）</h3><p>問い合わせ対象のリソースの画面より、サポートリクエストを作成する手順となります。<br>こちらの手順では、自動的に対象リソースの選択がされた状態でサポートリクエストが発行されますので、この手順を推奨させて頂いております。<br>Azure VM の画面のサンプルを用いて、手順をご説明させていただきます。</p><p>まず、Azure ポータルにて問い合わせ対象のリソースの画面を開いて頂き、左側のメニューより [サポートとトラブルシューティング] を選択頂いた上で、発生している問題に近しいトラブルシューティングを選択します。  </p><p><img src="/blog/information/How-to-inquiry-to-the-Azure-Support/2023-11-27-13-39-19.png"></p><p>自動トラブルシューティング ツールが表示されますので、表示された内容に沿ってトラブルシューティングを行います。<br>こちらのトラブルシューティングにて問題の改善等がされない場合は、下部に表示される [サポートに連絡する] を選択することでサポートリクエスト作成画面に進みます。  </p><p><img src="/blog/information/How-to-inquiry-to-the-Azure-Support/2023-11-27-13-39-44.png"></p><h3 id="ヘルプとサポートの画面よりサポートリクエストを作成する"><a href="#ヘルプとサポートの画面よりサポートリクエストを作成する" class="headerlink" title="ヘルプとサポートの画面よりサポートリクエストを作成する"></a>ヘルプとサポートの画面よりサポートリクエストを作成する</h3><p><a href="https://portal.azure.com/">Azure Portal</a> の画面右上、クエスチョン マークから [ヘルプとサポート] に遷移し、続いて [サポート リクエストの作成] をクリックすることで、Azure のサポート リクエストを作成できます。</p><p><img src="/blog/information/How-to-inquiry-to-the-Azure-Support/help_and_support.png"></p><p><img src="/blog/information/How-to-inquiry-to-the-Azure-Support/help_and_support2.png"></p><blockquote><p>ご参考) Azure サポート要求を作成する<br><a href="https://docs.microsoft.com/ja-jp/azure/azure-portal/supportability/how-to-create-azure-support-request">https://docs.microsoft.com/ja-jp/azure/azure-portal/supportability/how-to-create-azure-support-request</a></p></blockquote><hr><h3 id="サポート-リクエスト作成画面-1-問題の説明-ページ"><a href="#サポート-リクエスト作成画面-1-問題の説明-ページ" class="headerlink" title="サポート リクエスト作成画面 - 1. 問題の説明 ページ"></a>サポート リクエスト作成画面 - 1. 問題の説明 ページ</h3><p>まず問題の種類を選択します。<br>サブスクリプションの管理、サービスとサブスクリプションの制限 (クォータ)、課金、に関しては無償でお問い合わせいただけます。</p><p><img src="/blog/information/How-to-inquiry-to-the-Azure-Support/sr_creation.png"></p><p>技術的なお問い合わせについては、有償サポート契約が必要であり、”技術 (各種 Azure サービスについて)” を選択します。<br>なお、対象リソースの画面よりサポートリクエストを作成頂いた場合、対象リソース等が自動的に選択された状態となります。<br>ここでは、技術的なお問い合わせをされる際のフローについて説明します。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p><strong>課金・サブスクリプション・クォータのサポートについての参考資料はこちらです</strong></p><p>Japan Azure 課金 サブスクリプション サポート ブログ - サポートにお問い合わせする方法について</p><p><a href="https://jpazasms.github.io/blog/AzureSubscriptionManagement/20131030a/">https://jpazasms.github.io/blog/AzureSubscriptionManagement/20131030a/</a></p></div><p><img src="/blog/information/How-to-inquiry-to-the-Azure-Support/sr_creation2.png"></p><h4 id="サブスクリプション"><a href="#サブスクリプション" class="headerlink" title="サブスクリプション"></a>サブスクリプション</h4><p>問題が発生しているリソースを含むサブスクリプションを正しく選ぶことは非常に重要なステップです。</p><ul><li>この画面にて、自動的に、今回の画面を開いているユーザーアカウント (Azure Portal の右上に表示) がお問い合わせ可能なサブスクリプションが検索され、選択可能となります。<br>サポート リクエストでは、ご利用されている環境のヒアリングをしており、サポートからの情報の提示を行う場合があります。<br>お問い合わせされる際には、本アカウントが、対象サブスクリプションの所有者・共同作成者・サービス リクエスト共同作成者のいずれかのセキュリティ ロールが付与されている必要があり、これによってお客様の環境について情報を漏洩していないことを確認しています。</li><li>有償サポート契約との紐付きはサブスクリプション単位で行っています。<br>このため、適切なサポート レベルにてサービス提供が受けられます。</li></ul><div class="alert is-important"><p class="alert-title">重要</p><p><strong>異なるサブスクリプション上のリソースの調査について</strong></p><p>サポートリクエストを発行される際、調査対象リソースのサブスクリプションからお問い合わせくださいますようお願いいたします。</p><p>異なるサブスクリプション上のリソースの調査は、セキュリティ上の問題が発生します。詳しくは以下をご参照ください。</p><p>　</p><p>ご参考) お問い合わせ発行時と「異なる」サブスクリプションの調査依頼に対してのセキュリティ チェックが強化されます</p><p><a href="https://jpaztech.github.io/blog/information/Different-subscriptions-research/">https://jpaztech.github.io/blog/information/Different-subscriptions-research/</a></p><p>ご参考) 電話経由における Azure サブスクリプションの調査のセキュリティ チェックが厳格化されます</p><p><a href="https://jpaztech.github.io/blog/information/Security-check-stricter/">https://jpaztech.github.io/blog/information/Security-check-stricter/</a></p></div><h4 id="サービス-サービスの種類"><a href="#サービス-サービスの種類" class="headerlink" title="サービス (サービスの種類)"></a>サービス (サービスの種類)</h4><p>サービスとは、Azure におけるそれぞれのサービス名のことです。<br>できる限り正確に、どのサービスに対してのお問い合わせであるか選択していただくようお願いします。  </p><p>「Azure」はひとつのサービスではなく、数百種類も存在する様々なサービスのプラットフォームとなっています。<br>Azure サポート チームでは、この膨大なサービスを個々のチームで分担し、より専門的な回答を差し上げられるよう研鑽を積んでおります。<br>適切なサービスを選択していただくことで、専門的な知識を持つサポートエンジニアからの正確なご案内をスムーズに行うことができます。  </p><p>「使用中のサービス」ボタンを選択していると、そのサブスクリプションですでに作成済みのリソースのみがリストアップされるため、絞り込みやすくなります。  </p><h4 id="概要、問題の種類と、サブタイプ"><a href="#概要、問題の種類と、サブタイプ" class="headerlink" title="概要、問題の種類と、サブタイプ"></a>概要、問題の種類と、サブタイプ</h4><p>概要については、簡潔に問題の概要を記載下さい。<br>このキーワードをもとに、問題の種類がリストアップされますので、ここからお客様が直面している問題に近いものを選択します。<br>これは、適切な専任チームにお問合せがルーティングされるための貴重な情報として使われます。<br>厳密な表現が難しい場合には、後続のページにてテキスト フォーマットで詳細を記載可能となりますので、ご安心ください。  </p><div class="alert is-success"><p class="alert-title">ヒント</p><p><strong>起票の単位 (サービスごと、リソースごと)</strong></p><p>サポートをご利用いただく際には、問題の最小単位を切りだしたものを 1 件としてお問合せください。</p><p>これは、お問合せの量に応じて適切なサポート人員を配置し、また必要に応じて複数人での対応によりスピーディなご連絡を差し上げるためであり、サポートご利用の皆様にお願いさせて頂いております。</p><p>分割いただくことが適切な例は以下の通りです。</p><p><ul><li>同じサービスで複数のリソースにて問題が発生しているが、発生パターンが異なるなど同じ原因によるものか不明な場合</li><li>1 つの問題と考えられるが、複数のサービス間にわたって問題が発生しており、どちらに問題があるかそれぞれから見解を受けたい場合 (※ 専任部門がことなるそれぞれのエンジニアから対応が受けられるため。お問い合わせ番号を相互にご連絡いただけましたら、内部で連携を取って調査します。)</li><li>お問い合わせの過程で、関連した質問が発生したが元のお問い合わせ内容と異なる場合</li></ul></p></div><p>なお、複数のお問合せを起票した方が良いか分からない、どのサービスとどのサービスが別々なのか判断がつかない、一問一答にしてしまうと膨大な量になってしまう、といった場合には、まず一件起票いただき、担当のサポートエンジニアとご相談をいただけますと助かります。</p><h3 id="サポート-リクエスト作成画面-2-推奨される解決策-ページ"><a href="#サポート-リクエスト作成画面-2-推奨される解決策-ページ" class="headerlink" title="サポート リクエスト作成画面 - 2. 推奨される解決策 ページ"></a>サポート リクエスト作成画面 - 2. 推奨される解決策 ページ</h3><p>この画面は、特に入力が必要な部分は無く、関連する可能性のある情報が提示される箇所です。</p><p><img src="/blog/information/How-to-inquiry-to-the-Azure-Support/sr_creation3.png"></p><p>Azure においては、お問い合わせによるやりとりにてお手間をかけず、極力お客様ご自身で必要な情報にアクセスが出来るよう、公開情報の刷新を続けております。<br>対象ページでは、1ページ目で記載いただいたトピックにて関連する可能性のある技術資料やトラブルシューティング方法など、お客様での解決をお手伝いする資料を検索し、提示します。</p><p>また、最近発生した大規模な障害の情報も自動的に表示される場合があり、お問い合わせのやりとりを待つ事なく情報が得られる可能性もあります。<br>情報を参照された結果、該当していない、もしくはサポート エンジニアからの対応が必要な場合、次へをクリックして進みます。</p><h3 id="サポート-リクエスト作成画面-3-追加の詳細-ページ"><a href="#サポート-リクエスト作成画面-3-追加の詳細-ページ" class="headerlink" title="サポート リクエスト作成画面 - 3. 追加の詳細 ページ"></a>サポート リクエスト作成画面 - 3. 追加の詳細 ページ</h3><p>サポート リクエストの依頼内容の詳細を入力するページとなります。</p><p><img src="/blog/information/How-to-inquiry-to-the-Azure-Support/sr_creation4.png"></p><p><img src="/blog/information/How-to-inquiry-to-the-Azure-Support/sr_creation5.png"></p><h4 id="問題の詳細"><a href="#問題の詳細" class="headerlink" title="問題の詳細"></a>問題の詳細</h4><p>ここでは、お客様のご利用のサービスやリソースについて、いつから問題が発生したのかや、問題の説明について詳細な記載をお願いしております。<br>サポート エンジニアが迅速に問題内容を把握し、調査を行うためにご協力をいただけますと助かります。</p><p><strong>日時 欄</strong><br>エラーや問題が最初に発生した時間について記載してください。</p><p><strong>説明 欄</strong><br>以下を参考に、問題の詳細について記載してください。</p><ul><li>お問い合わせにおけるゴール</li><li>問題、あるいはご質問内容</li><li>再現の手順 (どのような操作を行うことで問題が発生するか)</li><li>問題の頻度 (○時間に一度、定期的/不定期 など)</li><li>問題が出る直前に、構成や設定面で変更を加えたものがあれば、可能な限り詳細に記載ください。</li><li>詳細なエラー メッセージ。ログファイルや画面ショットなどが準備できる場合、アップロードしていただくことも可能です。(エラーと分かった一部分のみに省略せず、コマンドや操作を行ったところからエラーになるまでの全体を抜粋いただくことが確実です)</li><li>お客様にてお試しいただいた対策や、実施された調査内容、既知の回避策の有無</li><li>(すでに他のサポート リクエストを起票済みで関連している場合) 関連するお問合せ番号と当該件の担当者名</li><li>お問い合わせのやりとりに追加されたい他のご担当者様の連絡先</li></ul><div class="alert is-success"><p class="alert-title">ヒント</p><p>その他の一般的なヒアリング事項については、<a href="https://aka.ms/jpazsupportform">https://aka.ms/jpazsupportform</a> に EXCEL シートをご用意しております。</p><p>起票の際のポイントとして参考にしていただけますと幸いです。</p><p>(本テンプレートを埋めてアップロードしていただいても OK です。)</p></div><div class="alert is-success"><p class="alert-title">ヒント</p><p><strong>過度な略語やプロジェクト固有文言の使用は避けましょう</strong></p><p>一般的に Azure の製品名や機能であるものをのぞき、略称やプロジェクト固有の文言の使用により齟齬が発生する可能性があります。</p><p>例: 「PoC 環境」「プライマリ/セカンダリ」など。</p><p>「PoC ではエラーが出なかったが、本番環境では問題が発生している」 =&gt; PoC 環境、本番環境がどのようなリソース名と構成であるかを明記したり、利用方法などの違いについてもご説明いただくことで、比較調査に役立つ場合があります。</p></div><h4 id="高度な診断情報"><a href="#高度な診断情報" class="headerlink" title="高度な診断情報"></a>高度な診断情報</h4><p>Azure サポートでは、お客様のデータ プライバシーに配慮をしつつ、一部リソースのトラブルシューティングに必要な範囲で基盤ログの抽出を行うといった、高度な診断情報へアクセスを行うことができます。<br>これにより、お客様にて手動で情報を抽出し、弊社に送信いただくといった手間が省けます。<br>基本的には、こちらで「はい」を選択していただくことをお勧めしております。<br>アクセス許可を付与することで Azure サポートが参照できる情報は以下の通りとなります。  </p><blockquote><p>ご参考) Data we use to deliver Azure support<br><a href="https://azure.microsoft.com/en-us/support/legal/support-diagnostic-information-collection/">https://azure.microsoft.com/en-us/support/legal/support-diagnostic-information-collection/</a><br>(※ お問い合わせのクローズと共にアクセス許可は削除されます)</p></blockquote><h4 id="サポート方法"><a href="#サポート方法" class="headerlink" title="サポート方法"></a>サポート方法</h4><p><strong>重要度 (重大度)</strong><br>問題の状況によって、3 種類の重要度が設定可能です。<br>お客様がご利用されている契約と、この緊急度に応じて、初回応答時間が設定されています。<br>初回応答時間は、Microsoft のサポートエンジニアがお客様と連絡を取り、サポートが開始されるまでの時間です。重大度 A 以外は営業時間内でのご連絡となります。</p><ul><li>事業に軽微な影響が及ぶ場合 (重大度 C):<br>Standard サポート契約の場合 8 時間以内</li><li>事業に部分的な影響が発生する場合 (重大度 B):<br>Standard サポート契約の場合 4 時間以内</li><li>事業に大きな影響が発生する場合 (重大度 A):<br>Standard サポート契約の場合 1 時間以内</li></ul><p>詳しくは、<a href="https://azure.microsoft.com/ja-jp/support/plans/response/">サポート プラン—サポート内容と応答性</a> のページを参照してください。</p><div class="alert is-important"><p class="alert-title">重要</p><p><strong>重要度 A について</strong></p><p>平日の夜間と休日も含めた 24x7 (24 時間体制) でのご支援であり、具体的には以下のような「今すぐに対応が必要」という場合の利用を想定しております。</p><p><ul><li>原則として、事業が停止しているような危機的障害 (例 : 全社員のメール送受信が失敗、全社員がアプリケーションへのアクセスに失敗、など) からの復旧を目指したサポートとなります。</p><p>このため、以下のような場合は重要度 B 以下を選択してください。</li><ul><li>復旧済みの問題についての原因の調査</li><li>環境の構築中やこれまでと異なる設定への変更に伴う問題発生で切り戻しによって解消可能</li><li>プロジェクトの進捗に影響が出ているので対応を加速</li></ul><li>即時の情報提供などが必要なため、お客様にも常にご連絡がつく体制の維持をお願いしております</li><li>障害からの復旧後には、お客様とのご相談の上で重要度を変更させていただきます</li></ul></p></p><p></blockquote><blockquote><p><strong>対応中の案件の緊急度 を A (24x7 対応) に上昇させたい場合</strong></p><p>お問い合わせの件について緊急性が上昇した結果、重要度を A に変更されたい場合には、お手数ですが別途新規に重要度 A のお問い合わせの起票をお願いいたします。</p><p>新規のお問合せを起票いただくことで、そのタイミングの緊急対応担当へ呼び出しが行われます。</p><p>その際、既存のお問い合わせのお問合せ番号を文中に記載いただくことで、関連のお問い合わせの経緯も参考にしつつ対応します。</p></div><p><strong>ご希望の連絡方法</strong><br>メールか電話、ご希望の連絡方法をご選択ください。選択した方法で初回のご連絡をさせていただきます。<br>なお、2 回目以降のご連絡はサポートエンジニアが状況に応じて異なるご連絡方法のお願いをさせて頂く場合がございます。<br>もし、より細かいご要望がございましたら、是非お問合せ説明欄にいただけますと助かります。<br>緊急度 A については電話のみでの対応となります。  </p><p><strong>サポート言語</strong><br>対応を要望される言語をご選択ください。  </p><div class="alert is-success"><p class="alert-title">ヒント</p><p><strong>英語でのお問い合わせについて</strong></p><p>英語での対応をご要望の際には、お手数ですがお問合せ本文等もすべて英文での記載をお願いいたします。</p><p>また、緊急度 B かつ 24x7 のお問合せは、現在のところ英語のみの対応となりますのでご注意ください。</p></div><h4 id="連絡先情報"><a href="#連絡先情報" class="headerlink" title="連絡先情報"></a>連絡先情報</h4><p>お客様の連絡先を記載します。<br>「編集」ボタンをクリックすることで、任意のメール アドレスやご担当者名に変更することが可能ですので、お間違え無いよう今一度有効なメールアドレスおよび電話番号かをご確認ください。</p><h3 id="サポート-リクエスト作成画面-4-確認と作成-ページ"><a href="#サポート-リクエスト作成画面-4-確認と作成-ページ" class="headerlink" title="サポート リクエスト作成画面 - 4. 確認と作成 ページ"></a>サポート リクエスト作成画面 - 4. 確認と作成 ページ</h3><p>最後に、お問い合わせの作成確認画面となります。<br>これまでに入力いただいた内容に漏れがないことをご確認の上、チケット作成を完了します。<br>その後、初回応答時間内に、サポート エンジニアからのご連絡差し上げます。  </p><hr><h2 id="お問い合わせの完了-サポート-リクエストのクローズ"><a href="#お問い合わせの完了-サポート-リクエストのクローズ" class="headerlink" title="お問い合わせの完了 (サポート リクエストのクローズ)"></a>お問い合わせの完了 (サポート リクエストのクローズ)</h2><h3 id="お問い合わせの終了方法について"><a href="#お問い合わせの終了方法について" class="headerlink" title="お問い合わせの終了方法について"></a>お問い合わせの終了方法について</h3><p>弊社のサポート エンジニアからの回答によって、お問い合わせに記載頂いた問題が解決した場合や、お客様ご自身で問題が解決した場合は、解決した旨を Azure ポータルやメール、お電話にてご連絡頂きますようお願い致します。<br>その後、弊社のサポート エンジニアにてお問い合わせ対応の終了 (クローズ) を実施します。<br>なお、一定期間お客様からご連絡を頂けなかった場合は、弊社のサポート エンジニアにてお問い合わせのクローズを実施します。  </p><h3 id="クローズ済みのお問い合わせの再開方法について"><a href="#クローズ済みのお問い合わせの再開方法について" class="headerlink" title="クローズ済みのお問い合わせの再開方法について"></a>クローズ済みのお問い合わせの再開方法について</h3><p>お客様のサポート契約が有効な場合は、クローズ済みのお問い合わせに関する追加のご質問や調査を再開することが可能ですので、お問い合わせ内容に対象のお問い合わせ番号を明記の上、新規でお問い合わせを起票頂きますようお願い致します。  </p><h3 id="サポート-リクエストのクローズ後のアンケートについて"><a href="#サポート-リクエストのクローズ後のアンケートについて" class="headerlink" title="サポート リクエストのクローズ後のアンケートについて"></a>サポート リクエストのクローズ後のアンケートについて</h3><p>サポート リクエストをクローズ時にメールでアンケートを送付しています。<br>サポート対応の品質向上を目的として、各サポート リクエストでのサポート エンジニアによる対応品質をお客様にご評価いただいております。<br>回答内容については担当したサポート エンジニアならびに担当チームメンバーで共有し、次回以降のより良い対応に繋げたり、励みとさせていただいております。 </p><h3 id="Azure-への製品へのフィードバックや機能追加の要望"><a href="#Azure-への製品へのフィードバックや機能追加の要望" class="headerlink" title="Azure への製品へのフィードバックや機能追加の要望"></a>Azure への製品へのフィードバックや機能追加の要望</h3><p>Azure における製品自体の品質のフィードバック、機能追加・変更といったご要望については、以下の「アイデア」ページにて集約しております。<br>こちらのサイトから投稿していただくことで、開発部門に直接お声を届けることが可能となっています。  </p><blockquote><p>ご参考) <a href="https://feedback.azure.com/d365community/">https://feedback.azure.com/d365community/</a>  </p></blockquote><div class="alert is-important"><p class="alert-title">重要</p><p><strong>サポートと機能要望の違いについて</strong></p><p>Azure サポートは、現在進行形の問題に対して対処を行い、製品を使い続けられるような支援を行うことに注力しています。Azure などのクラウド製品においては、中・長期的に見た機能改善や追加のご要望、一過性の問題に対しての修正完了までの追跡はサポートでは行っておりません。上記フィードバック サイトでは、製品がより良くなるようなご要望について、その賛同意見や技術的な実現正とメリットを考え、今後の開発ロードマップに活かすべく開発者が直接参照しておりますので、ぜひとも積極的に投稿をお願いいたします。</p><p>なお、このような機能改善へのご要望について、中・長期的ではあっても、お客様にとって Azure を継続利用するにあたって極めて大きな障壁となるようでしたら、プレミア サポートの契約をいただいている場合、担当の CSAM (カスタマー サクセス アカウント マネージャー) までご連絡をお願いします。</p></div><p>以上が Azure サポートを効果的にご利用いただくためのお問い合わせ方法、および流れとなります。  </p><p>なお、お問い合わせをされるお客様には様々なご要望があり、また様々なご事情を抱えていらっしゃると拝察しております。<br>「すぐに電話が欲しい」、「電話は絶対にして欲しくない」、「メールはテキストが良い」、「いや HTML で図が入っていた方が読みやすい」などなど、日々対応させて頂いているなかで、頂戴するご要望は多岐に渡り、正反対のものもございます。</p><p>私たち Azure サポートでは、まずお客様と対話させて頂くことが必要であり、Q を入れたら A が出てくるような機械的なサポートではなく、ご要望をお聞きして、それに寄り添ったご支援を差し上げられればと考えています。<br>もし、上記にうまくあてはめられないようなご要望やお悩みがございましたら、まずは一件お問合せをお送りいただき、その中でお気兼ねなく担当サポートエンジニアまでご相談ください。  </p><p>Azure をサポートサービスの質でお選び頂けるよう、チーム一同努めてまいりますので、これからも、弊社 Azure サービスならびに Azure サポートをご愛顧賜りますと幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームです。&lt;/p&gt;
&lt;p&gt;私たちは、Azure をご利用いただいているお客様に、Azure を正常かつ快適にご利用いただくためのご支援を差し上げています。&lt;br&gt;この度、Azure サポートを効果的に利用するやり方について知りたい、というご要望を頂戴しましたので、以下にサポートへのお問い合わせ方法をご案内させていただきます。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Information" scheme="https://jpaztech.github.io/blog/tags/Information/"/>
    
  </entry>
  
  <entry>
    <title>Microsoft ピアリングを経由するかどうかの確認方法</title>
    <link href="https://jpaztech.github.io/blog/network/judge-via-ms-peering/"/>
    <id>https://jpaztech.github.io/blog/network/judge-via-ms-peering/</id>
    <published>2023-11-24T07:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.695Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの山崎です。<br>今回は対象の通信が Microsoft ピアリングを経由するかどうかの確認方法についてご紹介します。</p><h2 id="Microsoft-ピアリングで広報される経路について"><a href="#Microsoft-ピアリングで広報される経路について" class="headerlink" title="Microsoft ピアリングで広報される経路について"></a>Microsoft ピアリングで広報される経路について</h2><p>ExpressRoute の Microsoft ピアリングをご利用の場合、ルートフィルターの設定でどのような経路を広報するかを設定します。</p><p><strong>(ルートフィルターの設定画面 - Azure ポータル)</strong><br><img src="/blog/network/judge-via-ms-peering/judge-via-ms-peering-01.png"> </p><p><strong>(実行コマンド)</strong><br>各サービスコミュニティで広報される経路については以下の PowerShell コマンドからご確認いただけます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-AzBgpServiceCommunity</span><br></pre></td></tr></table></figure><p><strong>(出力例 1)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">$communities = Get-AzBgpServiceCommunity</span><br><span class="line">$communities | format-list</span><br><span class="line"></span><br><span class="line">Name               : Exchange</span><br><span class="line">Id                 : /subscriptions//resourceGroups//providers/Microsoft.Network/bgpServiceCommunities/Exchange</span><br><span class="line">Type               : Microsoft.Network/bgpServiceCommunities</span><br><span class="line">ServiceName        : Exchange</span><br><span class="line">BgpCommunities     : &#123;Exchange, Exchange IPv6&#125;</span><br><span class="line">BgpCommunitiesText : [</span><br><span class="line">                       &#123;</span><br><span class="line">                         &quot;ServiceSupportedRegion&quot;: &quot;Global&quot;,</span><br><span class="line">                         &quot;CommunityName&quot;: &quot;Exchange&quot;,</span><br><span class="line">                         &quot;CommunityValue&quot;: &quot;12076:5010&quot;,</span><br><span class="line">                         &quot;CommunityPrefixes&quot;: [</span><br><span class="line">                           &quot;13.107.6.152/31&quot;,</span><br><span class="line">                           &quot;13.107.18.10/31&quot;,</span><br><span class="line">                           &quot;13.107.128.0/22&quot;,</span><br><span class="line">                           &quot;23.103.160.0/20&quot;,</span><br><span class="line">                           &quot;40.92.0.0/15&quot;,</span><br><span class="line">                           &quot;40.96.0.0/13&quot;,</span><br><span class="line">                           &quot;40.104.0.0/15&quot;,</span><br><span class="line">                           &quot;40.107.0.0/16&quot;,</span><br><span class="line">                           &quot;52.96.0.0/14&quot;,</span><br><span class="line">                           &quot;52.100.0.0/14&quot;,</span><br><span class="line">                           &quot;52.238.78.88/32&quot;,</span><br><span class="line">                           &quot;104.47.0.0/17&quot;,</span><br><span class="line">                           &quot;131.253.33.215/32&quot;,</span><br><span class="line">                           &quot;132.245.0.0/16&quot;,</span><br><span class="line">                           &quot;150.171.32.0/22&quot;,</span><br><span class="line">                           &quot;204.79.197.215/32&quot;,</span><br><span class="line">                           &quot;13.107.128.0/24&quot;,</span><br><span class="line">                           &quot;13.107.129.0/24&quot;,</span><br><span class="line">                           &quot;150.171.32.0/24&quot;,</span><br><span class="line">                           &quot;150.171.34.0/24&quot;,</span><br><span class="line">                           &quot;150.171.35.0/24&quot;,</span><br><span class="line">                           &quot;52.96.38.0/24&quot;</span><br><span class="line">                         ],</span><br><span class="line">                         &quot;IsAuthorizedToUse&quot;: false,</span><br><span class="line">                         &quot;ServiceGroup&quot;: &quot;O365&quot;</span><br><span class="line">                       &#125;,</span><br><span class="line">                       &#123;</span><br><span class="line">                         &quot;ServiceSupportedRegion&quot;: &quot;Global&quot;,</span><br><span class="line">                         &quot;CommunityName&quot;: &quot;Exchange IPv6&quot;,</span><br><span class="line">                         &quot;CommunityValue&quot;: &quot;12076:5010&quot;,</span><br><span class="line">                         &quot;CommunityPrefixes&quot;: [</span><br><span class="line">                           &quot;2603:1006::/40&quot;,</span><br><span class="line">                           &quot;2603:1016::/36&quot;,</span><br><span class="line">                           &quot;2603:1026::/36&quot;,</span><br><span class="line">                           &quot;2603:1036::/36&quot;,</span><br><span class="line">                           &quot;2603:1046::/36&quot;,</span><br><span class="line">                           &quot;2603:1056::/36&quot;,</span><br><span class="line">                           &quot;2620:1ec:4::152/128&quot;,</span><br><span class="line">                           &quot;2620:1ec:4::153/128&quot;,</span><br><span class="line">                           &quot;2620:1ec:c::10/128&quot;,</span><br><span class="line">                           &quot;2620:1ec:c::11/128&quot;,</span><br><span class="line">                           &quot;2620:1ec:d::10/128&quot;,</span><br><span class="line">                           &quot;2620:1ec:d::11/128&quot;,</span><br><span class="line">                           &quot;2620:1ec:8f0::/46&quot;,</span><br><span class="line">                           &quot;2620:1ec:900::/46&quot;,</span><br><span class="line">                           &quot;2620:1ec:a92::152/128&quot;,</span><br><span class="line">                           &quot;2620:1ec:a92::153/128&quot;,</span><br><span class="line">                           &quot;2a01:111:f400::/48&quot;,</span><br><span class="line">                           &quot;2a01:111:f403::/48&quot;</span><br><span class="line">                         ],</span><br><span class="line">                         &quot;IsAuthorizedToUse&quot;: false,</span><br><span class="line">                         &quot;ServiceGroup&quot;: &quot;O365&quot;</span><br><span class="line">                       &#125;</span><br><span class="line">                     ]</span><br><span class="line"></span><br><span class="line">Name               : OtherOffice365Services</span><br><span class="line">Id                 : /subscriptions//resourceGroups//providers/Microsoft.Network/bgpServiceCommunities/OtherOffice365Se</span><br><span class="line">                     rvices</span><br><span class="line">Type               : Microsoft.Network/bgpServiceCommunities</span><br><span class="line">ServiceName        : OtherOffice365Services</span><br><span class="line">BgpCommunities     : &#123;Other Office 365 Services, Other Office 365 Services IPv6&#125;</span><br><span class="line">BgpCommunitiesText : [</span><br><span class="line">                       &#123;</span><br><span class="line">                         &quot;ServiceSupportedRegion&quot;: &quot;Global&quot;,</span><br><span class="line">                         &quot;CommunityName&quot;: &quot;Other Office 365 Services&quot;,</span><br><span class="line">                         &quot;CommunityValue&quot;: &quot;12076:5100&quot;,</span><br><span class="line">                         &quot;CommunityPrefixes&quot;: [</span><br><span class="line">                           &quot;13.107.6.171/32&quot;,</span><br><span class="line">                           &quot;13.107.6.192/32&quot;,</span><br><span class="line">                           &quot;13.107.9.192/32&quot;,</span><br><span class="line">                           &quot;13.107.18.15/32&quot;,</span><br><span class="line">                           &quot;13.107.140.6/32&quot;,</span><br><span class="line">                       (... 省略)</span><br></pre></td></tr></table></figure><p><strong>(出力例 2)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$communities = Get-AzBgpServiceCommunity</span><br><span class="line">$communities.BgpCommunities | where &#123; $_.CommunityName -eq &#x27;Exchange&#x27; &#125;</span><br><span class="line"></span><br><span class="line">ServiceSupportedRegion : Global</span><br><span class="line">CommunityName          : Exchange</span><br><span class="line">CommunityValue         : 12076:5010</span><br><span class="line">CommunityPrefixes      : &#123;13.107.6.152/31, 13.107.18.10/31, 13.107.128.0/22, 23.103.160.0/20...&#125;</span><br><span class="line">IsAuthorizedToUse      : False</span><br><span class="line">ServiceGroup           : O365</span><br><span class="line">CommunityPrefixesText  : [</span><br><span class="line">                           &quot;13.107.6.152/31&quot;,</span><br><span class="line">                           &quot;13.107.18.10/31&quot;,</span><br><span class="line">                           &quot;13.107.128.0/22&quot;,</span><br><span class="line">                           &quot;23.103.160.0/20&quot;,</span><br><span class="line">                           &quot;40.92.0.0/15&quot;,</span><br><span class="line">                           &quot;40.96.0.0/13&quot;,</span><br><span class="line">                           &quot;40.104.0.0/15&quot;,</span><br><span class="line">                           &quot;40.107.0.0/16&quot;,</span><br><span class="line">                           &quot;52.96.0.0/14&quot;,</span><br><span class="line">                           &quot;52.100.0.0/14&quot;,</span><br><span class="line">                           &quot;52.238.78.88/32&quot;,</span><br><span class="line">                           &quot;104.47.0.0/17&quot;,</span><br><span class="line">                           &quot;131.253.33.215/32&quot;,</span><br><span class="line">                           &quot;132.245.0.0/16&quot;,</span><br><span class="line">                           &quot;150.171.32.0/22&quot;,</span><br><span class="line">                           &quot;204.79.197.215/32&quot;,</span><br><span class="line">                           &quot;13.107.128.0/24&quot;,</span><br><span class="line">                           &quot;13.107.129.0/24&quot;,</span><br><span class="line">                           &quot;150.171.32.0/24&quot;,</span><br><span class="line">                           &quot;150.171.34.0/24&quot;,</span><br><span class="line">                           &quot;150.171.35.0/24&quot;,</span><br><span class="line">                           &quot;52.96.38.0/24&quot;</span><br><span class="line">                         ]</span><br></pre></td></tr></table></figure><h2 id="宛先が-FQDN-の場合"><a href="#宛先が-FQDN-の場合" class="headerlink" title="宛先が FQDN の場合"></a>宛先が FQDN の場合</h2><p>通信対象が IP の場合、上記の手順で IP をご確認いただくことで対象のサービスコミュニティが確認可能で、ルートフィルターの設定状況により Microsoft ピアリングを経由するかどうかを確認することが可能です。また、各サービス毎に以下のようなドキュメントでも ExpressRoute の対応状況について記載がされています。</p><p>  [Office 365 の URL と IP アドレスの範囲]<br>  <a href="https://docs.microsoft.com/ja-jp/office365/enterprise/urls-and-ip-address-ranges">https://docs.microsoft.com/ja-jp/office365/enterprise/urls-and-ip-address-ranges</a></p><p>  [Azure ExpressRoute と Azure Site Recovery]<br>  <a href="https://docs.microsoft.com/ja-jp/azure/site-recovery/concepts-expressroute-with-site-recovery">https://docs.microsoft.com/ja-jp/azure/site-recovery/concepts-expressroute-with-site-recovery</a></p><p>ドキュメントに記載がなく、対象が FQDN の場合には個別に調査が必要となります。Microsoft ピアリング観点としては IP を特定いただくことで経由、非経由が判断出来ますため、調査としては対象の FQDN に紐づく IP 情報についてご確認いただく必要がございます。</p><blockquote><p>対象の FQDN に紐づく IP アドレスの調査については FQDN が利用されるサービス毎に調査が必要となりますので、ご利用サービス宛てにお問い合わせをお願いします。</p></blockquote><p>対象の FQDN によっては IP が固定でわかる場合もあれば、情報公開されておらず不定の場合もあります。IP が明確に特定できないような場合には Internet 経由で通信できるようネットワークを構成いただければ幸いです。</p><p>以上、ご参考になれば幸いです。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの山崎です。&lt;br&gt;今回は対象の通信が Microsoft ピアリングを経由するかどうかの確認方法についてご紹介します。&lt;/p&gt;
&lt;h2 id=&quot;Microsoft-ピアリングで広報される経路について&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="ExpressRoute" scheme="https://jpaztech.github.io/blog/tags/ExpressRoute/"/>
    
  </entry>
  
  <entry>
    <title>Azure Container Instances に固定の IP アドレスを割り当てる以外の代替案</title>
    <link href="https://jpaztech.github.io/blog/containers/aci-fix-ip/"/>
    <id>https://jpaztech.github.io/blog/containers/aci-fix-ip/</id>
    <published>2023-11-15T03:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.619Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポートチームのシンです。</p><p>Azure Container Instances (ACI) のサービスには、静的な IP アドレスを割り当てる (IP アドレスを固定する) 方法がございません。<br>本記事では、IP アドレス固定化に代わる代替案についてご案内いたします。</p><span id="more"></span><hr><h2 id="コンテナー-インスタンスのネットワークの種類"><a href="#コンテナー-インスタンスのネットワークの種類" class="headerlink" title="コンテナー インスタンスのネットワークの種類"></a>コンテナー インスタンスのネットワークの種類</h2><p>コンテナー インスタンスのネットワーク種類には、「パブリック」、「プライベート」、「なし」の3つがあります。</p><p>「パブリック」のネットワーク種類を選択した場合、コンテナーインスタンスの起動時に自動的にパブリックIPアドレスが生成されます。コンテナーインスタンスを停止すると、そのパブリックIPアドレスがリリースされます。コンテナーインスタンスタンスの起動時には、新しいパブリックIPアドレスが使用されます。</p><p>「プライベート」のネットワーク種類を選択した場合、コンテナーインスタンスは指定された仮想ネットワーク上にデプロイされ、その仮想ネットワーク上のプライベートIPアドレスが使用されます。コンテナーインスタンスを停止すると、プライベートIPアドレスがリリースされます。次回の起動時には、仮想ネットワーク上で利用可能なIPアドレスが自動的に割り当てられます。前回使用したプライベートIPアドレスと異なる可能性があります。</p><p>「なし」のネットワーク種類を選択した場合、パブリックIPアドレスもプライベートIPアドレスも生成されません。</p><div class="alert is-important"><p class="alert-title">重要</p><p>したがって、コンテナーインスタンスに割り当てられたパブリックIPアドレスやプライベートIPアドレスは、ACIの開始、起動もしくは再起動により変更されることがあります。</p><p>また、Azure Container Instances のサービスとしては、固定のアドレスを割り当てる方法は提供されていません。</p></div><p>一方で、お客様のシステム構成や要件により、コンテナーインスタンスが再起動しても同じIPアドレスでアクセスできるように実現したいというご要望があるかと存じます。以下にネットワークの種類ごとの代替案をご紹介します。</p><h2 id="パブリック-ネットワーク種類について"><a href="#パブリック-ネットワーク種類について" class="headerlink" title="[パブリック] ネットワーク種類について"></a>[パブリック] ネットワーク種類について</h2><p>「パブリック」ネットワーク種類を選択する際には、DNS名ラベルを指定することが可能です。コンテナーインスタンスを作成する際にDNS名ラベルを指定すると、そのDNS名ラベルから始まるFQDN名が生成されます。パブリックIPの代わりに、このFQDN名を使用してアプリケーションにアクセスできます。<br>DNS名ラベルの指定手順は、公開ドキュメントで紹介されています。ご確認くださいませ。  </p><blockquote><p>ご参考情報：Azure portalを使用してコンテナーインスタンスをAzure内にデプロイする<br><a href="https://learn.microsoft.com/ja-jp/azure/container-instances/container-instances-quickstart-portal">https://learn.microsoft.com/ja-jp/azure/container-instances/container-instances-quickstart-portal</a></p></blockquote><blockquote><p>ご参考情報：Azure CLIを使用してコンテナーインスタンスをAzureにデプロイする<br><a href="https://learn.microsoft.com/ja-jp/azure/container-instances/container-instances-quickstart">https://learn.microsoft.com/ja-jp/azure/container-instances/container-instances-quickstart</a></p></blockquote><h2 id="プライベート-のネットワーク種類について"><a href="#プライベート-のネットワーク種類について" class="headerlink" title="[プライベート] のネットワーク種類について"></a>[プライベート] のネットワーク種類について</h2><p>[プライベート] のネットワーク種類の場合、以下2つの代替案を挙げさせていただきます。</p><h3 id="案1-コンテナー-インスタンスの前段に-Application-Gateway-を配置する"><a href="#案1-コンテナー-インスタンスの前段に-Application-Gateway-を配置する" class="headerlink" title="案1: コンテナー インスタンスの前段に Application Gateway を配置する"></a>案1: コンテナー インスタンスの前段に Application Gateway を配置する</h3><p>コンテナー インスタンスの前段に Application Gateway を配置し、コンテナー インスタンス側割り当てられたIPアドレスではなく、Application Gateway に割り当てられた静的 IP アドレスでアクセスします。  </p><blockquote><p>ご参考情報：コンテナー グループの静的 IP アドレス - Azure Container Instances | Microsoft Docs<br><a href="https://learn.microsoft.com/ja-jp/azure/container-instances/container-instances-application-gateway">https://learn.microsoft.com/ja-jp/azure/container-instances/container-instances-application-gateway</a></p></blockquote><div class="alert is-important"><p class="alert-title">重要</p><p>コンテナー インスタンスの停止、起動もしくは再起動によりコンテナー インスタンスの IP アドレスが変更となった場合、手動でApplication Gateway のバックエンドの設定を更新する必要があります。</p><p>この仕組みを自動化したい場合は、Azure Automation などをご利用いただき、お客様にて自動化の仕組みをご構築いただく必要がございます。</p></div><h3 id="案２-DNS-名でアクセスをする-コンテナー-インスタンス起動時に-DNS-レコードを更新"><a href="#案２-DNS-名でアクセスをする-コンテナー-インスタンス起動時に-DNS-レコードを更新" class="headerlink" title="案２: DNS 名でアクセスをする (コンテナー インスタンス起動時に DNS レコードを更新)"></a>案２: DNS 名でアクセスをする (コンテナー インスタンス起動時に DNS レコードを更新)</h3><p>IPアドレスの代わりに、外部から完全修飾ドメイン名 (FQDN) を利用して、コンテナー インスタンスへアクセスします。<br>実現方法として、init コンテナーを使用します。Init コンテナーは、アプリケーション本体のコンテナーが実行される前に実行される、環境の初期化の用途などで使用されるコンテナーです。<br>init コンテナーは、アプリケーション コンテナーに割り当てられている IP アドレスを取得し、Azure クライアントツールでコンテナーに到達するために使用される DNS エントリを更新します。 init コンテナーとアプリケーション コンテナーは同じネットワーク スタックを共有するため、init コンテナーから参照可能な IP アドレスは、アプリケーション コンテナーで使用されるアドレスと同じです。<br>以下は、実現手順となります。</p><p>１、リソースグループやコンテナー インスタンスにデプロイされた仮想ネットワークを作成します。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rg=myResourceGroup</span><br><span class="line">aci_name=myaci</span><br><span class="line">vnet_name=aci-vnet</span><br><span class="line">az group create --name $rg --location japaneast</span><br><span class="line">az network vnet create --resource-group $rg --name aci-vnet --address-prefixes 10.0.0.0/16 --subnet-name aci-subnet --subnet-prefix 10.0.0.0/24</span><br><span class="line">aci_subnet_id=$(az network vnet subnet update --resource-group $rg --name aci-subnet --vnet-name $vnet_name   --delegations Microsoft.ContainerInstance/containerGroups  --query id -o tsv)</span><br></pre></td></tr></table></figure><p>２、プライベート DNS ゾーンを操作するサービス プリンシパルを作成します。init コンテナーからは該当サービス プリンシパルを使用して、プライベート DNS ゾーンのレコードを更新します。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scope=$(az group show -n $rg --query id -o tsv)</span><br><span class="line">new_sp=$(az ad sp create-for-rbac --scopes $scope --role Contributor --name acilabsp -o json)</span><br><span class="line">sp_appid=$(echo $new_sp | jq -r &#x27;.appId&#x27;) &amp;&amp; echo $sp_appid</span><br><span class="line">sp_tenant=$(echo $new_sp | jq -r &#x27;.tenant&#x27;) &amp;&amp; echo $sp_tenant</span><br><span class="line">sp_password=$(echo $new_sp | jq -r &#x27;.password&#x27;)</span><br></pre></td></tr></table></figure><p>３、init コンテナーで実行するスクリプトを作成し、該当スクリプトをAzure Filesにアップロードします。<br>init コンテナーは、該当スクリプトをAzure Filesからマウントします。コンテナー インスタンスを起動すると、メインコンテナーが実行される前に、init コンテナーで該当スクリプトが実行されます。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">storage_account_name=&quot;acilab$RANDOM&quot;</span><br><span class="line">az storage account create -n $storage_account_name -g $rg --sku Standard_LRS --kind StorageV2</span><br><span class="line">storage_account_key=$(az storage account keys list --account-name $storage_account_name -g $rg --query &#x27;[0].value&#x27; -o tsv)</span><br><span class="line">az storage share create --account-name $storage_account_name --account-key $storage_account_key --name initscript</span><br><span class="line">init_script_filename=init.sh</span><br><span class="line">init_script_path=/tmp/</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt; $&#123;init_script_path&#125;$&#123;init_script_filename&#125;</span><br><span class="line">echo &quot;Logging into Azure...&quot;</span><br><span class="line">az login --service-principal -u \$SP_APPID -p \$SP_PASSWORD --tenant \$SP_TENANT</span><br><span class="line">echo &quot;Finding out IP address...&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> my_private_ip=\$(az container show -n \<span class="variable">$ACI_NAME</span> -g \<span class="variable">$RG</span> --query <span class="string">&#x27;ipAddress.ip&#x27;</span> -o tsv) &amp;&amp; <span class="built_in">echo</span> \<span class="variable">$my_private_ip</span></span></span><br><span class="line">my_private_ip=\$(ifconfig eth0 | grep &#x27;inet addr&#x27; | cut -d: -f2 | cut -d&#x27; &#x27; -f 1) &amp;&amp; echo \$my_private_ip</span><br><span class="line">echo &quot;Deleting previous record if there was one…&quot;</span><br><span class="line">az network private-dns record-set a delete -n \$HOSTNAME -z \$DNS_ZONE_NAME -g \$RG -y</span><br><span class="line">echo &quot;Creating DNS record...&quot;</span><br><span class="line">az network private-dns record-set a create -n \$HOSTNAME -z \$DNS_ZONE_NAME -g \$RG</span><br><span class="line">az network private-dns record-set a add-record --record-set-name \$HOSTNAME -z \$DNS_ZONE_NAME -g \$RG -a \$my_private_ip</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">az storage file upload --account-name $storage_account_name --account-key $storage_account_key -s initscript --source $&#123;init_script_path&#125;$&#123;init_script_filename&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、コンテナーの YAML 定義を作成します。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Create YAML</span></span><br><span class="line">aci_yaml_file=/tmp/acilab.yaml</span><br><span class="line">cat &lt;&lt;EOF &gt; $aci_yaml_file</span><br><span class="line">apiVersion: &#x27;2023-05-01&#x27;</span><br><span class="line">location: $location</span><br><span class="line">name: $aci_name</span><br><span class="line">properties:</span><br><span class="line">  subnetIds:</span><br><span class="line">  - id: $aci_subnet_id</span><br><span class="line">  initContainers:</span><br><span class="line">  - name: azcli</span><br><span class="line">    properties:</span><br><span class="line">      image: mcr.microsoft.com/azure-cli:latest</span><br><span class="line">      command:</span><br><span class="line">      - &quot;/bin/sh&quot;</span><br><span class="line">      - &quot;-c&quot;</span><br><span class="line">      - &quot;/mnt/init/$init_script_filename&quot;</span><br><span class="line">      environmentVariables:</span><br><span class="line">      - name: RG</span><br><span class="line">        value: $rg</span><br><span class="line">      - name: SP_APPID</span><br><span class="line">        value: $sp_appid</span><br><span class="line">      - name: SP_PASSWORD</span><br><span class="line">        secureValue: $sp_password</span><br><span class="line">      - name: SP_TENANT</span><br><span class="line">        value: $sp_tenant</span><br><span class="line">      - name: DNS_ZONE_NAME</span><br><span class="line">        value: $dns_zone_name</span><br><span class="line">      - name: HOSTNAME</span><br><span class="line">        value: $aci_name</span><br><span class="line">      - name: ACI_NAME</span><br><span class="line">        value: $aci_name</span><br><span class="line">      volumeMounts:</span><br><span class="line">      - name: initscript</span><br><span class="line">        mountPath: /mnt/init/</span><br><span class="line">  containers:</span><br><span class="line">  - name: aci-helloworld</span><br><span class="line">    properties:</span><br><span class="line">      image: mcr.microsoft.com/azuredocs/aci-helloworld</span><br><span class="line">      ports:</span><br><span class="line">      - port: 80</span><br><span class="line">        protocol: TCP</span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          cpu: 1.0</span><br><span class="line">          memoryInGB: 1.5</span><br><span class="line">  volumes:</span><br><span class="line">  - name: initscript</span><br><span class="line">    azureFile:</span><br><span class="line">      readOnly: false</span><br><span class="line">      shareName: initscript</span><br><span class="line">      storageAccountName: $storage_account_name</span><br><span class="line">      storageAccountKey: $storage_account_key</span><br><span class="line">  ipAddress:</span><br><span class="line">    ports:</span><br><span class="line">    - port: 80</span><br><span class="line">      protocol: TCP</span><br><span class="line">    type: Private</span><br><span class="line">  osType: Linux</span><br><span class="line">tags: null</span><br><span class="line">type: Microsoft.ContainerInstance/containerGroups</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>5、コンテナーインスタンスをデプロイします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az container create -g $rg --file $aci_yaml_file</span><br></pre></td></tr></table></figure><p>NginxアプリケーションをDNS名でアクセスする例も、以下のドキュメントに公開されています。 </p><blockquote><p>ご参考情報：サイドカー コンテナーを使用して Azure Container Instances をデプロイするDocs<br><a href="https://learn.microsoft.com/ja-jp/training/modules/secure-apps-azure-container-instances-sidecar/4-deploy-sidecar">https://learn.microsoft.com/ja-jp/training/modules/secure-apps-azure-container-instances-sidecar/4-deploy-sidecar</a></p></blockquote><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>Application GatewayはOSIレイヤー7のロードバランサーとなりますので、コンテナー インスタンスの前段にApplication Gatewayを配置する案につきましては、コンテナー インスタンスを冗長化配置する場合でも、構成を変更することなく対応可能です。また、ロードバランサー機能以外にも、TLS終端などの機能も備えていますので、様々なシナリオに対応可能です。一方、Application Gatewayを追加することで、構成が複雑になる点は留意が必要です。<br>DNS名でアクセスするという案については、コンテナーインスタンスとAzureプライベートDNSゾーン機能を利用すれば、シンプルに実現可能です。ただし、アプリケーションから完全修飾ドメイン名 (FQDN) でアクセス可能であることを考慮する必要があります。  </p><p>以上で、AzureコンテナーインスタンスIPを固定する代替案を紹介させていただきました。 本稿がお役に立てれば幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポートチームのシンです。&lt;/p&gt;
&lt;p&gt;Azure Container Instances (ACI) のサービスには、静的な IP アドレスを割り当てる (IP アドレスを固定する) 方法がございません。&lt;br&gt;本記事では、IP アドレス固定化に代わる代替案についてご案内いたします。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Container Instances (ACI)" scheme="https://jpaztech.github.io/blog/tags/Azure-Container-Instances-ACI/"/>
    
  </entry>
  
  <entry>
    <title>Azure 既定の送信アクセスの動作変更のアナウンスに関する補足 (Tracking ID:3T84-PZZ) </title>
    <link href="https://jpaztech.github.io/blog/network/default-outbound-access-for-vms-will-be-retired/"/>
    <id>https://jpaztech.github.io/blog/network/default-outbound-access-for-vms-will-be-retired/</id>
    <published>2023-10-11T06:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.687Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームです。</p><p>2023 年 9 月末、Azure が既定で提供しているインターネット向けへの外部接続用の送信アクセスのサービス提供を、2025 年 9 月 30 日の翌日から限定的に終了することがアナウンスされました(Tracking ID:3T84-PZZ)。<br>アナウンスされた内容は英語でのご案内であったり、対処方法のご説明などを省略させていただいた概要でのご案内となっておりますので、この記事にて補足させていただきます。</p><h2 id="アナウンスの概要"><a href="#アナウンスの概要" class="headerlink" title="[アナウンスの概要]"></a>[アナウンスの概要]</h2><p>2025 年 10 月 1 日以降に作成された新しい Azure VM は、Azure 既定の送信アクセス (既定の SNAT) を利用してインターネット宛へのアウトバウンド通信ができなくなります。<br>インターネット宛へのアウトバウンド接続が必要な場合には、明示的な送信接続の設定が必要となります。<br><strong>2025 年 10 月 1 日よりも前に作成している既存の Azure VM は、現状、本通知の対象外となるため影響を受けませんが明示的に送信接続の設定を加えていただくことを推奨としています。</strong><br>既定の送信アクセスとは、ユーザーが明示的に送信接続の指定をしていない場合でも、Azure VM がインターネットにアクセスできるようにする仕組みです。具体的には、Azure プラットフォーム上で使われていないパブリック IP アドレスを一時的に借りて SNAT を行います。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="[FAQ]"></a>[FAQ]</h2><p>Q1. Azure 既定の送信アクセスを利用しているかはどのように判断すればよいですか？</p><p>A1. 当ブログサイトの以下の記事に記載されている「判定フローチャート」をご確認の上、Azure 既定の送信アクセスをご利用いただいているか判断ください。</p><p><a href="https://jpaztech.github.io/blog/network/snat-options-for-azure-vm/#%E5%88%A4%E5%AE%9A%E3%83%95%E3%83%AD%E3%83%BC%E3%83%81%E3%83%A3%E3%83%BC%E3%83%88">Azure VM の外部接続 (SNAT) オプション まとめ - 判定フローチャート | Japan Azure IaaS Core Support Blog</a></p><p>Q2. 明示的な送信接続方法が様々ありますが、どの送信接続方法を利用すればよいですか？</p><p>A2. 現在、明示的な送信接続方法は、4 パターンございますが、各構成パターンによって特性が異なります。<br>当ブログサイトの以下の記事に記載されている「構成の比較」をご確認の上、お客様の通信要件に合った明示的な送信接続方法をご利用下さい。</p><p><a href="https://jpaztech.github.io/blog/network/snat-options-for-azure-vm/#%E6%A7%8B%E6%88%90%E3%81%AE%E6%AF%94%E8%BC%83">Azure VM の外部接続 (SNAT) オプション まとめ - 構成の比較 | Japan Azure IaaS Core Support Blog</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームです。&lt;/p&gt;
&lt;p&gt;2023 年 9 月末、Azure が既定で提供しているインターネット向けへの外部接続用の送信アクセスのサービス提供を、2025 年 9 月 30 日の翌日から限定的に終了することがアナウンスされまし</summary>
      
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="Public IP Address" scheme="https://jpaztech.github.io/blog/tags/Public-IP-Address/"/>
    
    <category term="NAT Gateway" scheme="https://jpaztech.github.io/blog/tags/NAT-Gateway/"/>
    
    <category term="Azure Load Balancer" scheme="https://jpaztech.github.io/blog/tags/Azure-Load-Balancer/"/>
    
    <category term="SNAT" scheme="https://jpaztech.github.io/blog/tags/SNAT/"/>
    
  </entry>
  
  <entry>
    <title>Azure VM の送信接続 (SNAT) オプション まとめ</title>
    <link href="https://jpaztech.github.io/blog/network/snat-options-for-azure-vm/"/>
    <id>https://jpaztech.github.io/blog/network/snat-options-for-azure-vm/</id>
    <published>2023-09-30T09:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.699Z</updated>
    
    <content type="html"><![CDATA[<p>Azure Networking テクニカル サポート チームの山口です。</p><p>Azure では、インターネット宛てのアウトバウンド方向の接続 (送信接続) をいくつかの方法で実装できます。選択の幅があることは喜ばしいですが、一方で内容の把握のが難しい側面も否めません。そこで本記事では、Azure VM に使える送信接続の構成をまとめて説明します。また、ある Azure VM がどの構成に該当しているか判定するためのフローチャートや、各構成の特徴についても併せて紹介します。</p><div class="alert is-info"><p class="alert-title">Note</p><p><span style="color: #c00000;">2023 年 9 月、送信接続の構成の一つである<a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/ip-services/default-outbound-access">既定の送信アクセス</a>の提供終了がアナウンスされました。</span></p><p>これは、2025 年 9 月 30 日以降に作成された Azure VM は、後述の Azure 既定の SNAT が廃止され、明示的な外部接続ポリシーを設定しない限り、Azure 仮想ネットワークからの外部送信が行えなくなるという内容です。廃止アナウンスに関する補足については、当ブログサイトの以下の記事をご参照の上、技術的な内容については併せて本記事をご確認いただけますと幸いでございます。</p><p><a href="https://jpaztech.github.io/blog/network/default-outbound-access-for-vms-will-be-retired/">Azure 既定の送信アクセスの動作変更のアナウンスに関する補足 (Tracking ID:3T84-PZZ)</a></p></div><span id="more"></span><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>Azure VM をはじめとする仮想ネットワーク (VNet) のコンピューティング リソースは、必要に応じてインターネット上のサーバーにアクセスします。たとえば、Web ブラウザが TLS/SSL 証明書の失効を検証する場合や、外部の権威 DNS サーバーに再帰問い合わせを実施する場合などです。この接続は、Azure から外部に出ていくように見えることから、アウトバウンド方向の接続あるいは <strong>送信接続</strong> と呼ばれます。</p><p>インターネット上のホストと通信するために、パケットの送信元と宛先 IP アドレスは共にパブリック IP アドレス (グローバル IP アドレス) である必要があります。特に、送信接続の文脈では、宛先はパブリック IP アドレスであることが確定しているため、送信元のパブリック IP アドレスをいかにして確保するかが重要となります。</p><p>一般に、これを実現する方法は大きく２つあります。</p><ol><li>送信元のホスト (オペレーティング システムのネットワーク インターフェイス) に、パブリック IP アドレスを割り当てます。これで送信元ホストはグローバル アドレス帯のセグメントに参加している状態となり、インターネットを介して宛先ホストとエンド・ツー・エンドな通信が行えます。</li><li>送信元のホストには、プライベート IP アドレスのみを割り当てます。その代わり、送信元ホストの外部にあるネットワーク装置で、送信元 IP アドレスをパブリック IP アドレスに変換します。</li></ol><p>このうち、Azure でサポートされているのは 2 番目の方法です。これは、ネットワークのアドレス変換 (Network Address Translation; NAT) と呼ばれる技術を使っています。特に送信元を変換するので送信元 NAT (Source NAT; SNAT) と呼ばれることもあります。Azure では、仮想化基盤に実装された仮想的なルーター (各サブネットの最初のユーザブル アドレスでホストされるデフォルトゲートウェイ) が、Azure VM のパケットに対して SNAT を実施します。このようなルーターを NAT 装置と呼びます。</p><p>SNAT の実現方法は、さらに 2 つの方式に細分化できます。</p><ul><li><strong>Basic NAT</strong>: 2 つの IP アドレスを 1 対 1 の関係で変換する NAT です。狭義の NAT と呼ばれることもあります。NAT 装置上では、単純にアドレスの対応付けを覚えておくだけで良いので、それ以上のステート管理が不要です。</li><li><strong>NAPT (Network Address Port Translation)</strong>: プロトコルやポート番号の情報を利用することで、アドレスを 1 対多の関係で変換できる NAT です。たとえば、複数のクライアントに同じパブリック IP アドレスでの SNAT を提供できます。NAT 装置は、5 タプル (プロトコル、送信元アドレス、送信元ポート番号、宛先アドレス、宛先ポート番号) でフローを一意に識別し、フローごとのアドレスの対応付けを NAT テーブルと呼ばれるデータベースに記録します。</li></ul><p>特に、後者の NAPT による SNAT では<strong>SNAT ポート枯渇</strong>に留意する必要があります。</p><p>NAPT を使用して複数のクライアントに共通の SNAT アドレスを割り当てると、当然 SNAT 後の送信元アドレスは同じものになります。さらに、通信先のエンドポイント (プロトコル、宛先アドレス、宛先ポート番号) が同じである場合は、フローを識別できる情報は 5 タプルのうち送信元ポート番号 (SNAT ポート) だけです。したがって、同一エンドポイント宛ての接続が発生するたびに SNAT ポートを割り当てる (消費する) 必要があり、ポート番号を使い切るとそれ以降の送信接続が失敗します。</p><p>SNAT ポートがどのように消費されるかを示すため、次のようなシナリオを考えます。SNAT 装置が、あるパブリック IP アドレス (<code>SNAT</code>) を使って、プライベート IP アドレスだけが割り当てられた Azure VM #1 (<code>10.0.0.4</code>) と #2 (<code>10.0.0.5</code>) に対して NAPT による SNAT を提供します。VM 間で SNAT ポートの奪い合いが発生しないよう、各 VM に 100 個ずつ SNAT ポートを事前に割り当てることにします。</p><p><img src="/blog/network/snat-options-for-azure-vm/snat-port-exhaustion.png" alt="snat-port-exhaustion"></p><p>ここで、VM から Web サーバー (<code>WEB</code>) に対する大量の HTTP アクセスを発生させました。この通信は、[プロトコル、宛先 IP アドレス、宛先ポート] がすべて同一 (<code>TCP, WEB:80</code>) であることに留意してください。コネクションを識別しなければならない SNAT 装置は、SNAT ポートをコネクションごとに消費していきながら SNAT を行います。</p><p>そして、VM #1 からの 101 個目の接続を受け付けた時、使える SNAT ポートが存在しないことに気が付きます。なぜなら、VM #1 には 100 個の SNAT ポートのみを割り当てたからです。これが SNAT ポートが枯渇した状態です。一度消費した SNAT ポートを再利用するには、既存のコネクションを VM か WEB サーバーが FIN/RST で終了するか、SNAT 装置上のアイドルタイムアウトで強制切断するのを待つ必要があります。</p><p>ただし、SNAT ポート枯渇が発生したからと言って、他のプロトコルや宛先の通信に影響がでるわけではありません。あくまで SNAT ポートはコネクションを識別するための一要素にすぎず、5 タプルの他の値で識別できれば SNAT ポートが重複しても問題ないためです。たとえば、この状況でも VM #1 から DNS サーバー (<code>DNS:53</code>) に対する UDP の接続要求は成功します。</p><p>SNAT ポート枯渇は、同じエンドポイントへのアクセスを繰り返すワークロードで発生する可能性が高まります。たとえば次のようなシナリオです。</p><ul><li>外部の DNS サーバーへの問い合わせ</li><li>インターネット上のプロキシ サーバーの利用</li><li>コネクションプーリングを使わないデータベース アクセス</li><li>ファイル共有 サーバーとの連携</li></ul><p>枯渇を防止するためには、SNAT ポート数の十分な確保だけでなく、アプリケーションでコネクションを再利用したり不要なコネクションをこまめに切断することが効果的です。</p><h2 id="構成パターンの一覧"><a href="#構成パターンの一覧" class="headerlink" title="構成パターンの一覧"></a>構成パターンの一覧</h2><p>それでは、具体的にどのような構成を取れば、送信接続 (SNAT) が可能になるのでしょうか。2023 年 9 月現在、Azure VM の送信接続に使える構成パターンは次の通りです。</p><ul><li>サブネットに NAT ゲートウェイを関連付ける</li><li>NIC にパブリック IP アドレスを関連付ける</li><li>パブリック ロードバランサーで送信規則を定義する</li><li>パブリック ロードバランサーで自動アウトバウンド NAT が有効な負荷分散規則を定義する</li><li>既定の送信アクセスを利用する ※ 2025 年 9 月で廃止、非推奨</li></ul><h2 id="判定フローチャート"><a href="#判定フローチャート" class="headerlink" title="判定フローチャート"></a>判定フローチャート</h2><p>ここでは、ある Azure VM がどの構成パターンで送信接続を実現しているか判定するためのフローチャートを示します。</p><p>より厳密に言えば、これは NIC に対しての判定チャートです。なぜなら、同一 Azure VM にアタッチされた NIC であっても、NIC ごとに異なる送信接続を構成できるためです。たとえば、異なる二つのサブネットに足を出す Azure VM に対し、片方のサブネットでは NAT ゲートウェイを使った送信接続を、もう一方のサブネットでは Azure Firewall を使った送信接続を構成することが可能です。</p><p>また、構成間の優先度も考慮して作成されています。たとえば、ある NIC に対して NAT ゲートウェイとインスタンス レベルのパブリック IP アドレスが両方構成された場合、NAT ゲートウェイによる SNAT で送信接続が行われます。当該のフローチャートを使うと、このような依存関係を判断できます。</p><p><img src="/blog/network/snat-options-for-azure-vm/flowchart-to-determine-snat-scenario.png" alt="flowchart"></p><h3 id="各ステップの詳細"><a href="#各ステップの詳細" class="headerlink" title="各ステップの詳細"></a>各ステップの詳細</h3><h4 id="ルートのネクストホップがインターネット？"><a href="#ルートのネクストホップがインターネット？" class="headerlink" title="ルートのネクストホップがインターネット？"></a>ルートのネクストホップがインターネット？</h4><p>本ステップは、トラフィックが SNAT の対象であるか判定します。</p><p>Azure では、パブリック IP アドレスに宛てた通信が必ずしもパブリック IP アドレスで SNAT されるとは限りません。ルートテーブル上でインターネットにルーティングされる通信だけが、SNAT の対象です (SNAT の対象であることと SNAT に成功することは別である点に注意してください。フローチャートの接続不可に相当する構成であれば SNAT に失敗します)。一方で、SNAT の対象にならないパブリック IP アドレス宛てのトラフィックは、次のような状況で発生します。</p><ul><li>VNet のアドレス範囲にパブリック IP アドレスを使用している場合</li><li>強制トンネリング (オンプレミス拠点にインターネット トラフィックを引き込むネットワーク構成) を採用している場合</li><li>Azure Firewall などのネットワーク仮想アプライアンスをインターネット ゲートウェイとして利用している場合</li><li>サービス エンドポイントを利用している場合</li></ul><p>こうしたシナリオの判断は、Azure VM に設定された<a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/diagnose-network-routing-problem#diagnose-using-azure-portal">有効なルート</a>で確認できます。具体的には、ルートのネクストホップが [インターネット] となっている場合は  SNAT の対象で、そうでない場合は対象外です。</p><p>初期状態では、デフォルトルート (0.0.0.0/0) のネクストホップが [インターネット] に向けられているため、仮想ネットワークやオンプレミス拠点のアドレス範囲以外に宛てられたトラフィック、つまりほとんどのトラフィックが SNAT の対象です。当該ステップの判定では、この既定のデフォルトルートを無効化あるいは上書きするようなルートが定義されていないかを重点的に確認していただくのが良いでしょう。</p><p>たとえば、次のような状況について考えてみます。</p><p><img src="/blog/network/snat-options-for-azure-vm/effective-routes-afw.png" alt="effective-routes-afw"></p><ul><li>既定のデフォルトルートが無効となり、代わりにネクストホップが [仮想アプライアンス] のユーザー定義ルートが設定されています。したがって、Azure VM では SNAT を試みず、仮想アプライアンス側でインターネット トラフィックを処理 (フィルタリングや SNAT) する構成だと判断できます。</li><li>ただし、<a href="https://jpaztech.github.io/blog/vm/azure-kms-update/">KMS サーバーをホストする 3 つのアドレス</a> のネクストホップが [インターネット] に設定されています。これらのエンドポイントに関しては、仮想アプライアンスを使わず Azure VM 側で SNAT することが意図されているようです。</li></ul><p>したがって、この例での当該ステップへの回答は次の通りです。</p><ul><li>KMS サーバー宛てのトラフィック: はい (SNAT の対象)</li><li>それ以外のインターネット宛てのトラフィック: いいえ (SNAT の対象外)</li></ul><h4 id="NAT-ゲートウェイがサブネットに関連付けられている？"><a href="#NAT-ゲートウェイがサブネットに関連付けられている？" class="headerlink" title="NAT ゲートウェイがサブネットに関連付けられている？"></a>NAT ゲートウェイがサブネットに関連付けられている？</h4><p>本ステップでは、NAT ゲートウェイによる SNAT 構成であるか判定します。これは、NIC がデプロイされているサブネットのプロパティで確認できます。以下に、Azure Portal での確認方法の例を示します。</p><ol><li>対象の Azure VM の [ネットワーク] メニューで、 NIC がデプロイされている仮想ネットワーク/サブネットを確認する</li><li>対象の仮想ネットワークの [サブネット] メニューから、対象サブネットを開く</li><li>[NAT ゲートウェイ] の項目に NAT ゲートウェイの名前が存在すれば、本ステップの回答は「はい」です</li></ol><h4 id="パブリック-IP-が-NIC-に関連付けられている？"><a href="#パブリック-IP-が-NIC-に関連付けられている？" class="headerlink" title="パブリック IP が NIC に関連付けられている？"></a>パブリック IP が NIC に関連付けられている？</h4><p>本ステップでは、NIC に関連付けたパブリック IP アドレス (インスタンス レベルのパブリック IP アドレス) による SNAT 構成であるか判定します。NIC プロパティを見て、プライマリ IP 構成にパブリック IP アドレスが紐づけられているか確認してください。</p><p>Azure Portal で確認する場合は。<a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/ip-services/associate-public-ip-address-vm?tabs=azure-portal">パブリック IP アドレスの関連付けの手順</a>を参考に、次のような手順で実行します。</p><ol><li>対象の NIC の [IP 構成] メニューで、プライマリの IP 構成を確認する</li><li>パブリック IP アドレスの欄にアドレスが表示されていれば、本ステップの回答は「はい」です</li></ol><h4 id="送信規則を定義している？"><a href="#送信規則を定義している？" class="headerlink" title="送信規則を定義している？"></a>送信規則を定義している？</h4><p>本ステップでは、送信規則を使った SNAT 構成であるか判定します。送信規則は Standard SKU のパブリック ロードバランサーでのみ利用できる機能で、送信接続を定義したバックエンド プールの VM に対して SNAT を提供します。Azure Portal での確認方法の例は次の通りです。</p><ol><li>対象の Azure VM の [ネットワーク] メニューで、対象の NIC を確認します</li><li>[負荷分散] タブを開き、所属しているロードバランサーとバックエンド プールの一覧を確認します。</li><li>種別がパブリックで SKU が Standard であるロードバランサーのみを抽出します。</li><li>対象のロードバランサーの [送信規則] メニューを開き、対象のバックエンド プールに関連付けられた送信規則がある場合、本ステップの回答は「はい」です</li></ol><h4 id="自動アウトバウンド-NAT-が有効な負荷分散規則を定義している？"><a href="#自動アウトバウンド-NAT-が有効な負荷分散規則を定義している？" class="headerlink" title="自動アウトバウンド NAT が有効な負荷分散規則を定義している？"></a>自動アウトバウンド NAT が有効な負荷分散規則を定義している？</h4><p>本ステップでは、アウトバウンド NAT の自動プログラミングが有効な負荷分散規則による SNAT 構成であるか判定します。</p><p>パブリック ロードバランサーでは、負荷分散規則を定義すると同時に送信接続を有効化できます。この暗黙的な SNAT は、自動アウトバウンド NAT などと呼ばれます。Azure Portal での確認方法の例は次の通りです。</p><ol><li>対象の Azure VM の [ネットワーク] メニューで、対象の NIC を確認します</li><li>[負荷分散] タブを開き、所属しているロードバランサーとバックエンド プールの一覧を確認します。</li><li>種別がパブリックであるロードバランサーのみを抽出します。</li><li>対象のロードバランサーの [負荷分散規則] メニューを開き、対象のバックエンド プールに定義された負荷分散規則が次のいずれかに該当していれば本ステップの回答は「はい」です</li></ol><ul><li>Basic SKU のパブリック ロードバランサーの負荷分散規則が定義されている</li><li>Standard SKU のパブリックロードバランサーの負荷分散規則が定義されており、その負荷分散規則で自動アウトバウンド NAT が有効化されている</li></ul><h4 id="既定の送信アクセスの条件を満たしている？"><a href="#既定の送信アクセスの条件を満たしている？" class="headerlink" title="既定の送信アクセスの条件を満たしている？"></a>既定の送信アクセスの条件を満たしている？</h4><p>本ステップでは、<a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/ip-services/default-outbound-access">既定の送信アクセス</a> が有効なシナリオであるか確認します。</p><p>既定の送信アクセスとは、明示的に送信接続の設定をしていない Azure VM に最低限の送信接続を提供する Azure プラットフォームの SNAT 機能です。次の 2 つの条件をすべて満たす Azure VM は、既定の送信アクセスでの送信接続が有効です。</p><ul><li><strong>条件1</strong>: 同一の可用性セット(※) に含まれるすべての NIC が、Standard SKU のパブリック IP アドレス、ロードバランサーのいずれにも関連付けられていない。</li><li><strong>条件2</strong>: フレキシブル オーケストレーション モードで動作する VMSS のインスタンスではない。</li></ul><p>※ 可用性セットを作成していない場合は、「可用性セット」と「Azure VM」を置き替えてください (1台の Azure VM だけが所属する疑似的な可用性セットを考える)。同様に、VMSS のインスタンスの場合は、「可用性セット」と「VMSS」を置き替えてください。</p><p><img src="/blog/network/snat-options-for-azure-vm/default-snat-condition.png" alt="default-snat-condition-1"></p><h4 id="送信接続-不可"><a href="#送信接続-不可" class="headerlink" title="送信接続 不可"></a>送信接続 不可</h4><p>最後に「送信接続 不可」のシナリオについて補足します。</p><p>フローチャートからもわかるように、Azure では多くの SNAT オプションがあり、多くの状況で送信接続が可能です。特に、まったく SNAT の構成を意識せず、Azure VM をデプロイするだけで送信接続が勝手にできるようになる「既定の送信アクセス」は、特筆すべき機能です。それだけに、いざ送信接続ができなくなった時にパニックに陥ってしまうという、諸刃の剣としての側面もあります。</p><p>実際、技術サポートでも「Azure VM が送信接続できない、できなくなった」という類のお問い合わせは、頻繁に目にするシナリオのひとつです。中でも、ロードバランサーの構成変更作業を契機として事象が発生するケースが多く、過去にロードバランサー関連の TIPS としてブログ記事を公開しています。</p><blockquote><p>ロードバランサーのバックエンドプールに追加したら外部へ接続できなくなった<br>こちらの事象についてよくある原因としては以下があります。</p><ol><li>Standard SKU の内部ロードバランサーのバックエンドプールに所属している</li></ol><p>引用: <a href="https://jpaztech.github.io/blog/archive/azurelb-tips/">Azure ロードバランサー利用時の注意点 &gt; ロードバランサーのバックエンドプールに追加したら外部へ接続できなくなった</a></p></blockquote><p>もし、送信接続ができない場合や、あるタイミングを境に送信接続できない状況になってしまった場合は、以下のような対応で事象が緩和するかご確認ください。</p><ul><li>NAT ゲートウェイを Azure VM が配置されているサブネットに関連付ける</li><li>パブリック IP アドレスを Azure VM の NIC に関連付ける</li><li>Standard SKU のパブリック ロードバランサーを利用して送信規則を構成する</li></ul><h2 id="構成の比較"><a href="#構成の比較" class="headerlink" title="構成の比較"></a>構成の比較</h2><p>次の表は、各構成にどのような特性があるかを示したものです。詳細は後述のセクションで確認していただければと思いますが、横ぐしで比較する際に参考となれば幸いです。</p><table><thead><tr><th align="left"></th><th align="left">NAT ゲートウェイ</th><th align="left">インスタンスレベル パブリック IP アドレス</th><th align="left">送信規則</th><th align="left">負荷分散規則</th><th align="left">既定の送信アクセス</th></tr></thead><tbody><tr><td align="left">構成単位</td><td align="left">サブネット</td><td align="left">NIC</td><td align="left">バックエンド プール</td><td align="left">バックエンド プール</td><td align="left">可用性セット</td></tr><tr><td align="left">アドレスの割り当て</td><td align="left">固定</td><td align="left">固定</td><td align="left">固定</td><td align="left">固定</td><td align="left">ランダム</td></tr><tr><td align="left">NAT 方式</td><td align="left">NAPT</td><td align="left">Basic NAT</td><td align="left">NAPT</td><td align="left">NAPT</td><td align="left">NAPT</td></tr><tr><td align="left">最大 SNAT ポート数</td><td align="left">~64,512*16</td><td align="left"></td><td align="left">64,000</td><td align="left">1,024</td><td align="left">1,024</td></tr><tr><td align="left">アイドル タイムアウト[分]</td><td align="left">4~120</td><td align="left">4</td><td align="left">4~100</td><td align="left">4</td><td align="left">4</td></tr><tr><td align="left">プロトコル</td><td align="left">TCP/UDP</td><td align="left">TCP/UDP/ICMP/ESP</td><td align="left">TCP/UDP</td><td align="left">TCP/UDP</td><td align="left">TCP/UDP</td></tr><tr><td align="left">インバウンド接続</td><td align="left">なし</td><td align="left">あり</td><td align="left">なし</td><td align="left">あり</td><td align="left">なし</td></tr></tbody></table><ul><li><strong>構成単位</strong>: 同じ送信接続が構成されるスコープです。たとえば、サブネットが構成単位である場合、サブネット内のすべての NIC は同じ方法で送信接続されます。</li><li><strong>アドレスの割り当て</strong>: “固定” の構成では、特定の SNAT アドレス プールから送信元 IP アドレスが払い出されることを保証できます。これにより、宛先側のホストで送信元を使った ACL を利用できます。”ランダム” の構成では、SNAT アドレスを限定できません。Azure VM の割り当てを停止すると、パブリック IP アドレスが変化します。</li><li><strong>NAT 方式</strong>: “Basic NAT” は、1対1 のステートレス NAT によって実装されていることを表します。これが採用されているのは、インスタンスレベルのパブリック IP アドレスだけです。”NAPT” は、NAPT を利用した SNAT であることを表します。この方式では、SNAT ポートを使い切ると同じ宛先ホストへの同時接続が制限される「ポート枯渇」の問題が発生する可能性があります。</li><li><strong>最大 SNAT ポート数</strong>: NIC が利用できる最大の SNAT ポート数を表します。NAT ゲートウェイでは、利用状況に応じて SNAT ポートを動的に分配するため、他の Azure VM の稼働状況にも左右されます。理論上、NAT ゲートウェイ全体で最大 64,512 * 16 = 1,032,192 個の SNAT ポートが確保できます。</li><li><strong>アイドルタイムアウト</strong>: TCP コネクションをアウトバウンド向けに確立した時のアイドル タイムアウト値 (分) です。タイムアウト値よりも長くアイドル状態が続くコネクションに関しては、それ以降の接続が保証されません。範囲が記載されているものに関しては、設定により変動できます。ロードバランサーの場合、タイムアウト時に RST を通知する機能があります。</li><li><strong>プロトコル</strong>: 送信接続でサポートされているプロトコルです。すべてのオプションで TCP/UDP はサポートされています。ICMP が利用できないオプションもあるので、外部サーバーへの ping 監視のシナリオでは注意してください。</li><li><strong>インバウンド接続</strong>: 「なし」の場合、送信接続のためだけにパブリック IP アドレスが使用されます。「あり」の場合、外部からの接続エンドポイントとしてもパブリック IP アドレスが利用されます。</li></ul><p>また、送信接続の構成を選択する際は、以下の公式ドキュメントも併せてご確認ください。</p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/well-architected/mission-critical/mission-critical-networking-connectivity#internet-egress">Azure でのミッション クリティカルなワークロードのネットワークと接続 - Microsoft Azure Well-Architected Framework | Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-outbound-connections">アウトバウンド接続の送信元ネットワーク アドレス変換 (SNAT) - Azure Load Balancer | Microsoft Learn</a></li></ul><h2 id="構成の詳細"><a href="#構成の詳細" class="headerlink" title="構成の詳細"></a>構成の詳細</h2><p>ここからは、送信接続の構成ごとに特徴・ユースケース・注意事項を紹介していきます。</p><h3 id="NAT-ゲートウェイ"><a href="#NAT-ゲートウェイ" class="headerlink" title="NAT ゲートウェイ"></a>NAT ゲートウェイ</h3><p><img src="/blog/network/snat-options-for-azure-vm/nat-gateway-snat.png" alt="nat-gateway"></p><p>NAT ゲートウェイは、送信接続の SNAT を主な目的として設計されたネットワーク サービスです。専門的なサービスなだけあって、送信元アドレスの固定化はもちろん、動的なポート確保によりるポート資源の有効活用など、他の SNAT 方式にはない機能を有します。</p><p><strong>特徴</strong></p><ul><li>フルマネージドな PaaS サービスで、高い可用性を有します。最新の SLA では、可用性が 99.99% を下回ると一部料金の返金 (サービス クレジット) を受け取ることができます。</li><li>複数の VM で SNAT ポート プールを共有し、動的に SNAT ポートを確保できるのは NAT ゲートウェイだけです。[<a href="https://learn.microsoft.com/ja-jp/azure/nat-gateway/nat-gateway-snat">参考</a>]</li><li>NAT ゲートウェイに追加できるパブリック IP アドレスの最大数は 16 個です。パブリック IP アドレスあたり 64,152 の SNAT ポートが確保されるため、NAT ゲートウェイ全体で最大 64,512 * 16 = 1,032,192 の SNAT ポートを確保できます。[<a href="https://learn.microsoft.com/ja-jp/azure/nat-gateway/nat-gateway-resource#snat-ports">参考</a>]</li><li>送信接続の TCP アイドル タイムアウトを 4 分から最大 120 分まで伸ばせます。[<a href="https://learn.microsoft.com/ja-jp/azure/nat-gateway/nat-gateway-resource#tcp-idle-timeout">参考</a>]</li><li>Azure Monitor のメトリックで NAT ゲートウェイで処理されたデータサイズ、パケット数、現在の接続数を確認することができます。[<a href="https://learn.microsoft.com/ja-jp/azure/nat-gateway/nat-metrics">参考</a>]</li></ul><p><strong>構成方法</strong></p><ol><li>NAT ゲートウェイ リソースを作成する。</li><li>対象のサブネットに NAT ゲートウェイを関連付ける。</li></ol><p><strong>ユースケース</strong></p><ul><li>一般的な送信接続のシナリオ全般</li><li>大量のインターネットへの接続が必要となる場合</li><li>複数の Azure VM で SNAT 用のパブリック IP アドレス (SNAT ポート) を共有したい場合</li></ul><p><strong>注意事項</strong></p><ul><li>NAT ゲートウェイを使用する NIC は、Basic SKU のインスタンス レベル パブリック IP アドレスを関連付けたり、Basic SKU のロードバランサーのバックエンドに配置できません。</li><li>仮想ネットワーク内の通信に対する一般的な NAT 装置として利用できません。あくまで、インターネットへの送信接続における SNAT 機能だけを提供します。</li><li>インバウンド方向のインターネット接続を受け付けることはできません。インバウンド接続性が必要な場合、Application Gateway やロードバランサーなどの利用を検討してください。</li><li>NAT ゲートウェイの可用性オプションは、特定可用性ゾーンへの固定 (zonal) または非ゾーン (regional) のいずれかです。可用性ゾーン レベルの冗長性が必要なシステムに組み込む場合は、可用性ゾーンごとにサブネットを作成し、複数の NAT ゲートウェイを各サブネットに関連付けるようにします。[<a href="https://learn.microsoft.com/ja-jp/azure/nat-gateway/nat-availability-zones">参考</a>]</li><li>ICMP プロトコルはサポートされません。</li></ul><p><strong>参考文献</strong></p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/nat-gateway/nat-overview">Azure NAT Gateway とは | Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/ja-jp/azure/nat-gateway/nat-gateway-resource">Azure NAT Gateway リソース | Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/ja-jp/azure/nat-gateway/troubleshoot-nat">Azure NAT Gateway のトラブルシューティング - Azure Virtual Network | Microsoft Learn</a></li></ul><h3 id="インスタンス-レベルのパブリック-IP-アドレス"><a href="#インスタンス-レベルのパブリック-IP-アドレス" class="headerlink" title="インスタンス レベルのパブリック IP アドレス"></a>インスタンス レベルのパブリック IP アドレス</h3><p><img src="/blog/network/snat-options-for-azure-vm/public-ip-address-snat.png" alt="public-ip-address"></p><p>Azure VM の NIC にパブリック IP アドレス (インスタンス レベルのパブリック IP アドレス) を関連付けると、そのパブリック IP アドレスで通信が SNAT されるようになります。1 対 1 のステートレス NAT (Basic NAT) として実装されるため、基盤側では SNAT ポートを管理しません。</p><p><strong>特徴</strong></p><ul><li>基盤に備わる SNAT 機能の中で、唯一 NAPT を利用しない (SNAT ポートを使わない) 方式による SNAT です。SNAT ポートの枯渇を心配する必要はありません。</li><li>SNAT アドレスが一つの VM に占有され、他の VM に使われないことを保証できます。</li><li>構成が非常にシンプルです。</li></ul><p><strong>構成方法</strong></p><ol><li>パブリック IP アドレス リソースを作成する。</li><li>対象の Azure VM の NIC に関連付ける。</li></ol><p><strong>ユースケース</strong></p><ul><li>単一の Azure VM に対する送信接続の確保 (NAT ゲートウェイなどを導入するまでの一時的な対策)</li><li>送信接続だけでなく、Azure VM へのインバウンド接続も確保したい場合</li></ul><p><strong>注意事項</strong></p><ul><li>Basic SKU だと NAT Gateway と共存出来ない等、SKU 依存の制限が存在します。可用性ゾーンへの対応も考慮すると、基本的には Standard SKU の使用が推奨されます。</li><li>SNAT ポートの消費を気にしなくて済む反面、OS のネットワーク スタックでエフェメラル ポートが枯渇する可能があります。エフェメラルポートの枯渇が疑われる場合は、次のような情報を参考にしてください。<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/windows-client/networking/tcp-ip-port-exhaustion-troubleshooting">TCP/IP ポート枯渇のトラブルシューティング - Windows Client | Microsoft Learn</a></li></ul><p><strong>参考文献</strong></p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-outbound-connections">アウトバウンド接続の送信元ネットワーク アドレス変換 (SNAT) - Azure Load Balancer | Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/ip-services/virtual-network-public-ip-address">Azure パブリック IP アドレスを作成、変更、または削除する - Azure Virtual Network | Microsoft Learn</a></li></ul><h3 id="送信規則"><a href="#送信規則" class="headerlink" title="送信規則"></a>送信規則</h3><p><img src="/blog/network/snat-options-for-azure-vm/auzre-load-balancer-snat.png" alt="auzre-load-balancer-snat"></p><p>送信規則は Standard SKU のパブリック ロードバランサーで利用可能な送信接続構成です。バックエンド プールに Azure VM を配置して送信規則を定義すると、フロントエンドのパブリック IP アドレスを使った SNAT が提供されます。</p><p>NAT の方式には NAPT が利用されています。バックエンド プール内の Azure VM に対して、各々どの程度の SNAT ポート数を割り与えるか、予め設定しておきます。パブリック IP アドレスあたり 64,000 の SNAT ポートを持つので、これをバックエンド プール内の Azure VM で分配する形になります。たとえば、8 台なら 8,000 ポートずつ割り振ることができます。</p><p><strong>特徴</strong></p><ul><li>バックエンド プールの単位で構成されるため、サブネットをまたいで複数の Azure VM を同じ方法で SNAT できる。</li><li>送信規則で制御できるパラメータが豊富。<ul><li>バックエンド プール (どの Azure VM を対象とするか)</li><li>フロントエンド IP 構成 (どのパブリック IP アドレスで SNAT するか)</li><li>SNAT ポート数の割り当て (各 Azure VM へ自動的に均等に割り当てる方式か、明示的に値を入力する方式が選択できます)</li><li>SNAT の対象とするプロトコル (TCP、UDP、または両方)</li><li>TCP アイドルタイムアウト (4 分から最大 100 分まで)</li><li>アイドル タイムアウト時の TCP リセット送信の有無</li></ul></li><li>インバウンド接続性も、負荷分散規則やインバウンド NAT 規則を作成すれば確保できる。作成しなければ、単に送信接続のみを行う SNAT 装置として使うことも可能。</li></ul><p><strong>構成方法</strong></p><ol><li>パブリック IP アドレスをフロントエンドに付与したパブリック ロードバランサーを作成する。</li><li>バックエンド プールに対象の Azure VM の NIC を追加する。</li><li>送信規則を作成する。</li></ol><p><strong>ユースケース</strong></p><ul><li>SNAT と同時に、インバウンド方向の負荷分散も同時に構成したい場合 (例: 外部への DB アクセスが必要となるアプリケーション サーバー)</li><li>サブネット以外の単位で、複数の Azure VM の送信接続を制御したい場合 (例: サブネット内の一部の Azure VM に、まとめてインターネット接続を許可する)</li></ul><p><strong>注意事項</strong></p><ul><li>複数のパブリック IP アドレス (フロントエンド IP 構成) をまとめて指定すると、バックエンド プール全体としては 64,000 x &lt;IP アドレスの数&gt; だけ SNAT ポートが用意されます。しかし、どれだけパブリック IP アドレスを追加しても、各 Azure VM に割り当てられる最大の SNAT ポート数は 64,000 までです。</li><li>負荷分散規則には、既定の送信アクセスによって SNAT を構成するオプションがあります。これを有効化すると、同じバックエンドプールには送信規則が作成できなくなります。</li></ul><p><strong>参考文献</strong></p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-outbound-connections">アウトバウンド接続の送信元ネットワーク アドレス変換 (SNAT) - Azure Load Balancer | Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/outbound-rules">Azure Load Balancer のアウトバウンド規則 | Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/egress-only">送信専用のロード バランサーの構成 - Azure Load Balancer | Microsoft Learn</a></li></ul><h3 id="自動アウトバウンド-NAT-が有効な負荷分散規則"><a href="#自動アウトバウンド-NAT-が有効な負荷分散規則" class="headerlink" title="自動アウトバウンド NAT が有効な負荷分散規則"></a>自動アウトバウンド NAT が有効な負荷分散規則</h3><p>パブリック ロードバランサーの負荷分散規則で自動アウトバウンド NAT が有効な場合、バックエンド プールに配置している Azure VM に対して送信接続の機能が提供されます。SNAT アドレスは、負荷分散規則に紐づいたフロントエンド IP 構成 (フロントエンドのパブリック IP アドレス) です。</p><p>Basic SKU のロードバランサーでは、負荷分散規則の自動アウトバウンド NAT は必ず有効です。一方で、Standard SKU のロードバランサーの場合、自動アウトバウンド NAT の ON/OFF を設定するフラグ項目が負荷分散規則に存在します。具体的には、<code>disableOutboundSnat</code> パラメータを false に設定すると自動アウトバウンド NAT が有効となります。</p><p><strong>特徴</strong></p><ul><li>負荷分散規則と合わせて構成する性質上、インバウンドとアウトバウンド両方の接続性を確保できます。</li><li>NAT ゲートウェイや送信規則より古くから存在する送信接続構成の一つです。歴史的な経緯から、現在でもこの構成を利用して SNAT を実施している Azure VM は少なくありません。</li></ul><p><strong>構成方法</strong></p><ul><li>パブリック ロードバランサーを作成する</li><li>バックエンド プールを作成し、対象の Azure VM を配置する</li><li>バックエンド プールに負荷分散規則を定義する (Standard SKU の場合、自動アウトバウンド NAT を有効化するオプションを指定する)</li></ul><p><strong>ユースケース</strong></p><ul><li>負荷分散規則と同時に簡易的な送信接続を構成する場合</li></ul><p><strong>注意事項</strong></p><ul><li>Standard SKU の場合、送信規則との併用はできません。つまり、負荷分散規則の自動アウトバウンド NAT を使用しているバックエンド プールには、送信規則を定義することが出来ません。</li><li>SNAT ポートの割り当ては、バックエンド プール内の Azure VM のサイズに応じて、自動で 32 から 1,024 まで変化します。[<a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-outbound-connections#preallocatedports">参考</a>]</li><li>最大 SNAT ポートが 1,024 であるため、容易にポート枯渇が発生する可能性があります。</li></ul><p><strong>参考文献</strong></p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/outbound-rules#preventoutbound">Azure Load Balancer のアウトバウンド規則 | Microsoft Learn</a></li></ul><h3 id="Azure-既定の送信アクセス"><a href="#Azure-既定の送信アクセス" class="headerlink" title="Azure 既定の送信アクセス"></a>Azure 既定の送信アクセス</h3><p><span style="color: #c00000;"> 本記事の冒頭で追記している通り、2025 年 10 月 1 日以降、新規 Azure VM に対して既定の送信アクセスは無効化されます。具体的な内容や対応方法は、追記部分をご参照下さい。</span></p><p><img src="/blog/network/snat-options-for-azure-vm/azure-default-snat.png" alt="azure-default-snat"></p><p>これまでの送信接続の構成は、明示的にリソースを作成したり、関連付けることで SNAT をプログラミングするものでした。しかし、Azure には送信接続の方法をユーザーが指定していない場合でも、Azure VM がインターネット接続できるようにする仕組みが存在します。これを Azure 既定の送信アクセスと呼びます。</p><p>具体的には、Azure プラットフォーム上で使われていないパブリック IP アドレスを一時的に借りて SNAT を行います。そのため、Azure VM を割り当て解除 &amp; 起動するたびに、SNAT に利用されるパブリック アドレスが変動します。</p><p>なお、割り当てられる可能性のある IP アドレスはある程度絞り込むことができます。なぜなら、Azure リージョンで使用されているパブリック IP アドレスの一覧が、以下のダウンロード サイトから提供されているためです。対象の Azure VM が存在するリージョンを確認し、<code>AzureCloud.&lt;リージョン名&gt;</code> で検索すると候補の IP アドレスを取得できます。</p><ul><li><a href="https://www.microsoft.com/en-us/download/details.aspx?id=56519">Download Azure IP Ranges and Service Tags – Public Cloud from Official Microsoft Download Center</a></li></ul><p><strong>特徴</strong></p><ul><li>唯一パブリック IP アドレス リソースを作らずに SNAT が出来る送信接続の構成です。</li><li>NAPT により実現されており、確保される SNAT ポート数は NIC (Azure VM) あたり 1024 で固定されています。</li></ul><p><strong>構成方法</strong></p><p>典型的には、次のような状況で既定の送信アクセスが利用されます。条件の詳細は、判定フローチャートの「既定の送信アクセスの条件を満たしている？」をご覧ください。</p><ul><li>NAT ゲートウェイ、インスタンス レベルのパブリック IP アドレス、パブリック ロードバランサーの送信規則を使わず、スタンドアロンな Azure VM をデプロイしている。</li><li>Azure VM を Basic SKU の内部ロードバランサーのバックエンド プールに配置している。</li></ul><p><strong>ユースケース</strong></p><ul><li>テスト/開発用の Azure VM で送信接続が必要になる場合</li></ul><p><strong>注意事項</strong></p><ul><li>既定の送信アクセスでは最大でも 1024 までしか SNAT ポートが確保されず、SNAT ポート枯渇の問題が顕在化しやすい問題があります。</li><li>また、明示的な SNAT 方法の指定がないことが、セキュリティや管理上の問題となることもあります。</li><li>以上のような背景から、本番環境での利用は推奨されていません。</li></ul><p><strong>参考文献</strong></p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/ip-services/default-outbound-access">Azure での既定の送信アクセス - Azure Virtual Network | Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-outbound-connections">アウトバウンド接続の送信元ネットワーク アドレス変換 (SNAT) - Azure Load Balancer | Microsoft Learn</a></li></ul><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>今回の記事では、インターネット送信を実現する SNAT の仕組みと、Azure で利用できる SNAT の方式を紹介しました。</p><p>「判定フローチャート」を使うと、対象の Azure VM (NIC) がどの方式の送信接続で構成されているのか簡単に調べられます。送信接続できない時のトラブルシューティングにも、ぜひこのフローチャートを活用していただければと思います。</p><p>また、各送信接続構成の比較には「機能の比較」で示した表もご利用ください。それぞれのオプションのすべての側面を映し出しているわけではありませんが、大まかにどのような違いがあるのかを把握するための参考にしていただければ幸いです。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;Azure Networking テクニカル サポート チームの山口です。&lt;/p&gt;
&lt;p&gt;Azure では、インターネット宛てのアウトバウンド方向の接続 (送信接続) をいくつかの方法で実装できます。選択の幅があることは喜ばしいですが、一方で内容の把握のが難しい側面も否めません。そこで本記事では、Azure VM に使える送信接続の構成をまとめて説明します。また、ある Azure VM がどの構成に該当しているか判定するためのフローチャートや、各構成の特徴についても併せて紹介します。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;br&gt;&lt;span style=&quot;color: #c00000;&quot;&gt;2023 年 9 月、送信接続の構成の一つである&lt;a href=&quot;https://learn.microsoft.com/ja-jp/azure/virtual-network/ip-services/default-outbound-access&quot;&gt;既定の送信アクセス&lt;/a&gt;の提供終了がアナウンスされました。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;これは、2025 年 9 月 30 日以降に作成された Azure VM は、後述の Azure 既定の SNAT が廃止され、明示的な外部接続ポリシーを設定しない限り、Azure 仮想ネットワークからの外部送信が行えなくなるという内容です。廃止アナウンスに関する補足については、当ブログサイトの以下の記事をご参照の上、技術的な内容については併せて本記事をご確認いただけますと幸いでございます。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jpaztech.github.io/blog/network/default-outbound-access-for-vms-will-be-retired/&quot;&gt;Azure 既定の送信アクセスの動作変更のアナウンスに関する補足 (Tracking ID:3T84-PZZ)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="Public IP Address" scheme="https://jpaztech.github.io/blog/tags/Public-IP-Address/"/>
    
    <category term="NAT Gateway" scheme="https://jpaztech.github.io/blog/tags/NAT-Gateway/"/>
    
    <category term="Azure Load Balancer" scheme="https://jpaztech.github.io/blog/tags/Azure-Load-Balancer/"/>
    
    <category term="SNAT" scheme="https://jpaztech.github.io/blog/tags/SNAT/"/>
    
  </entry>
  
  <entry>
    <title>クラシック VM で使用していた VHD から ARM VM を作成する手順</title>
    <link href="https://jpaztech.github.io/blog/vm/classic-vhd-to-arm-vm/"/>
    <id>https://jpaztech.github.io/blog/vm/classic-vhd-to-arm-vm/</id>
    <published>2023-09-01T00:00:00.000Z</published>
    <updated>2023-12-29T07:45:21.787Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>Azure のクラシック VM は 2023 年 9 月 6 日を持ちまして廃止となりました。<br>そのためこれ以降サポートされる VM は ARM（Azure Resource Manager）の VM となります。<br>クラシック VM の ARM VM への移行については以下の通りドキュメント等がございます。  </p><p>■ご参考：2023 年 9 月 6 日までに IaaS リソースを Azure Resource Manager に移行する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/classic-vm-deprecation">https://learn.microsoft.com/ja-jp/azure/virtual-machines/classic-vm-deprecation</a>  </p><p>■ご参考：Classic VM から ARM への移行についての注意事項 (VM、ストレージ編)<br><a href="https://jpaztech.github.io/blog/vm/migrate_classic_vm_and_storage">https://jpaztech.github.io/blog/vm/migrate_classic_vm_and_storage</a>  </p><p>他方、上記とは別の方法としてクラシック VM で使用していた OS ディスクの VHD から ARM VM を作成することも可能でございますので、今回はこの手順についてご説明させていただきます。  </p><div class="alert is-info"><p class="alert-title">Note</p><p>クラシック VM で使用していた VHD はクラシックストレージアカウントに保存されておりますが、クラシックストレージアカウントも 2024 年 8 月 31 日に完全に廃止されます。</p><p>クラシックストレージアカウントの移行については以下のドキュメントをご参照くださいませ。</p><p>　</p><p>■ご参考：クラシック ストレージ アカウントを Azure Resource Manager へ 2024 年 8 月 31 日までに移行する</p><p><a href="https://learn.microsoft.com/ja-jp/azure/storage/common/classic-account-migration-overview">https://learn.microsoft.com/ja-jp/azure/storage/common/classic-account-migration-overview</a></p></div><hr><h2 id="手順の大まかな流れ"><a href="#手順の大まかな流れ" class="headerlink" title="手順の大まかな流れ"></a>手順の大まかな流れ</h2><p>クラシック VM で使用していた OS ディスクの VHD から ARM VM を作成する手順についてご紹介させていただきます。<br>クラシックストレージアカウントに保存されている VHD からそのままでは ARM VM の作成が叶いませんため、以下の手順を踏む必要がございます。  </p><ol><li>クラシックストレージアカウントから ARM ストレージアカウントへ VHD をコピーする。（AzCopy コマンド実行）</li><li>ARM ストレージアカウント内の VHD からディスクリソースを作成する。</li><li>ディスクリソースから ARM VM を作成する。</li></ol><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-16-11-01-20.png"></p><p>ディスクリソースの作成のためには ARM ストレージアカウントに VHD を一旦コピーする必要があるため少し手順が多いですが一つずつ解説させていただきます。<br>それでは、それぞれの手順の詳細をご案内させていただきます。</p><hr><h2 id="1-クラシックストレージアカウントから-ARM-ストレージアカウントへ-VHD-をコピーする。（AzCopy-コマンド実行）"><a href="#1-クラシックストレージアカウントから-ARM-ストレージアカウントへ-VHD-をコピーする。（AzCopy-コマンド実行）" class="headerlink" title="1. クラシックストレージアカウントから ARM ストレージアカウントへ VHD をコピーする。（AzCopy コマンド実行）"></a>1. クラシックストレージアカウントから ARM ストレージアカウントへ VHD をコピーする。（AzCopy コマンド実行）</h2><p>AzCopy コマンドを用いてクラシックストレージアカウントから ARM ストレージアカウントへ VHD をコピーします。<br>コマンド実行のために <strong>&lt;①コピー元ディスクの Blob URI&gt;&lt;②コピー元 SAS トークン&gt;&lt;③コピー先 URL&gt;</strong> の 3 つが必要となりますので、以下の順で用意をします。</p><hr><h3 id="1-1-クラシック-VM-で使用していた-VHD-の-Blob-URI-を特定する。"><a href="#1-1-クラシック-VM-で使用していた-VHD-の-Blob-URI-を特定する。" class="headerlink" title="1-1. クラシック VM で使用していた VHD の Blob URI を特定する。"></a>1-1. クラシック VM で使用していた VHD の Blob URI を特定する。</h3><p>ポータルの上部の検索ボックスより「仮想マシン (クラシック)」を検索して、クラシック VM の一覧を表示します。</p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-15-14-32-30.png"></p><p>表示されたクラシック VM の一覧から対象となる VM を選択します。</p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-15-14-33-57.png"></p><p>クラシック VM のリージョンをメモしておきます。  </p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-15-15-49-14.png"></p><p>左側のメニューより「ディスク」を選択して、OS ディスクの名前をクリックします。</p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-15-14-34-57.png"></p><p>ディスクの Blob URI が「場所」として表示されますので、この URI を <strong>&lt;①コピー元ディスクの Blob URI&gt;</strong> としてメモします。</p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-15-14-36-48.png"></p><p>データディスクがある場合は同じ手順でデータディスクについても URI をメモしておいてください。</p><hr><h3 id="1-2-コピー元クラシックストレージアカウントの準備"><a href="#1-2-コピー元クラシックストレージアカウントの準備" class="headerlink" title="1-2. コピー元クラシックストレージアカウントの準備"></a>1-2. コピー元クラシックストレージアカウントの準備</h3><p>先の手順でクラシック VM のディスクの Blob URI を <strong>&lt;①ディスクの Blob URI&gt;</strong> としてメモしていると思います。<br>Blob URI より以下の通り、クラシックストレージアカウント名が判別可能です。</p><blockquote><p>https://<strong>&lt;クラシックストレージアカウント名&gt;</strong>.blob.core.windows.net/&lt;コンテナー名&gt;/&lt;VHD名&gt;.vhd</p></blockquote><p>こちらで確認したクラシックストレージアカウント名を、ポータルの上部の検索ボックスより検索して、クラシックストレージアカウントの画面を表示します。</p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-15-16-27-20.png"></p><p>表示されたクラシックストレージアカウントの画面にて、左側のメニューより「Shared Access Signature」を選択し、以下の画像の例のように SAS トークンを生成し <strong>&lt;②コピー元 SAS トークン&gt;</strong> としてメモします。<br>この際 SAS の有効期限等を適切に設定をお願いいたします。  </p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-16-09-20-13.png"></p><p>以上でコピー元の準備は完了です。</p><hr><h3 id="1-3-コピー先-ARM-ストレージアカウントの準備"><a href="#1-3-コピー先-ARM-ストレージアカウントの準備" class="headerlink" title="1-3. コピー先 ARM ストレージアカウントの準備"></a>1-3. コピー先 ARM ストレージアカウントの準備</h3><p>コピー先の ARM ストレージアカウントを作成します。<br>既に ARM ストレージアカウントがある場合は、そちらをご利用いただいても大丈夫です。</p><p>ポータルの上部の検索ボックスより「ストレージアカウント」を検索して、ストレージアカウントの一覧画面を表示します。  </p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-15-15-46-00.png"></p><p>ストレージアカウント一覧画面の左上にある「作成」より ARM ストレージアカウントを作成します。  </p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-15-15-46-57.png"></p><p>ストレージアカウント作成の際、リージョン（地域）はクラシック VM と同じリージョンに作成します。<br>一時的なものですので冗長性は「LRS」で良いかと存じます。その他の設定項目は既定のままで問題ないものと存じます。</p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-15-15-57-23.png"></p><p>作成したストレージアカウントを表示し、左側のメニューより「コンテナー」を選択し、上部の「＋コンテナー」から新規 Blob コンテナーを作成します。  </p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-15-16-03-53.png"></p><p>作成したコンテナーを選択し、コンテナーの画面の左側のメニューより「共有アクセス トークン」を選択の上、以下の図の例のようにコピー先の URL を生成します。<br>この際も SAS の有効期限等を適切に設定をお願いいたします。<br>以下のように表示された「BLOB SAS URL」が <strong>&lt;③コピー先 URL&gt;</strong> となります。  </p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-15-16-19-19.png"></p><p>以上でコピー先の準備も完了しました。</p><hr><h3 id="1-4-AzCopy-コマンドを組み立てる"><a href="#1-4-AzCopy-コマンドを組み立てる" class="headerlink" title="1-4. AzCopy コマンドを組み立てる"></a>1-4. AzCopy コマンドを組み立てる</h3><p>用意した <strong>&lt;①コピー元ディスクの Blob URI&gt;&lt;②コピー元 SAS トークン&gt;&lt;③コピー先 URL&gt;</strong> を使って、コピーを実行する AzCopy コマンドを組み立てましょう。<br>以下の順で並べます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">azcopy copy &#x27;&lt;①コピー元ディスクの Blob URI&gt;&lt;②コピー元 SAS トークン&gt;&#x27; &#x27;&lt;③コピー先 URL&gt;&#x27; --blob-type PageBlob</span><br></pre></td></tr></table></figure><p>実際の文字列の例としては以下のような形となります。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">azcopy copy &#x27;https://classicsasample8.blob.core.windows.net/vhds/os-disk.vhd?sv=2022-11-02&amp;ss=b&amp;srt=sco&amp;sp=rl&amp;se=2023-08-16T10:08:35Z&amp;st=2023-08-16T02:08:35Z&amp;spr=https&amp;sig=saskeyverylongsaskeyverylongsaskeyverylong%3D&#x27; &#x27;https://armsasample8.blob.core.windows.net/newvhd?sp=racwl&amp;st=2023-08-16T02:09:36Z&amp;se=2023-08-16T10:09:36Z&amp;spr=https&amp;sv=2022-11-02&amp;sr=c&amp;sig=hereisasykeyhereisasykeyhereisasykey%3D&#x27; --blob-type PageBlob</span><br></pre></td></tr></table></figure><p>これにて実行する AzCopy のコマンドが用意できました。</p><hr><h3 id="1-5-Cloud-Shell-にて-AzCopy-コマンドで-VHD-コピーを実行する"><a href="#1-5-Cloud-Shell-にて-AzCopy-コマンドで-VHD-コピーを実行する" class="headerlink" title="1-5. Cloud Shell にて AzCopy コマンドで VHD コピーを実行する"></a>1-5. Cloud Shell にて AzCopy コマンドで VHD コピーを実行する</h3><p>AzCopy はコマンドベースでファイルのコピーなどを行えるコマンドライン ユーティリティです。<br>今回は既定で AzCopy がインストールされている Cloud Shell を利用した手順をご紹介させていただきます。<br>既に AzCopy がインストールされている環境をお持ちの場合はそちらをご利用いただいても問題ございません。  </p><p>■ご参考：AzCopy を使ってみる<br><a href="https://learn.microsoft.com/ja-jp/azure/storage/common/storage-use-azcopy-v10">https://learn.microsoft.com/ja-jp/azure/storage/common/storage-use-azcopy-v10</a></p><p>まず、ポータル右上の Cloud Shell 起動ボタンを選択します。</p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-16-09-24-27.png"></p><p>初めて Cloud Shell をご利用頂く場合はセットアップの画面が表示されますので、表示された内容に沿ってセットアップをお願いいたします。<br>なお、Cloud Shell の Bash / PowerShell どちらにも AzCopy はインストールされていますのでどちらをご利用いただいても大丈夫です。  </p><p>Cloud Shell が起動したら用意した AzCopy コマンドを実行します。<br>正常完了した場合は以下のように「Number of Transfers Completed: 1」が記録されます。  </p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-16-11-19-12.png"></p><p>これにて ARM ストレージアカウントに VHD のコピーが完了しました。<br>データディスクも合わせて移行する場合は、同様の手順でデータディスクもご対応をお願いいたします。  </p><hr><h2 id="2-ARM-ストレージアカウント内の-VHD-からディスクリソースを作成する。"><a href="#2-ARM-ストレージアカウント内の-VHD-からディスクリソースを作成する。" class="headerlink" title="2. ARM ストレージアカウント内の VHD からディスクリソースを作成する。"></a>2. ARM ストレージアカウント内の VHD からディスクリソースを作成する。</h2><p>次に ARM VM を作成するためのディスクリソースを作成します。<br>ポータルの上部の検索ボックスより「ディスク」を検索して、ディスクの一覧画面を表示します。  </p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-16-11-22-38.png"></p><p>左上の「作成」ボタンを選択します。</p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-16-11-23-42.png"></p><p>ディスクの新規作成画面に遷移するので、以下の形でディスクを作成します。</p><table><thead><tr><th align="left">項目</th><th align="left">選択する内容</th></tr></thead><tbody><tr><td align="left">サブスクリプション</td><td align="left">当該のサブスクリプションを選択します。</td></tr><tr><td align="left">リソースグループ</td><td align="left">任意で構いません。</td></tr><tr><td align="left">ディスク名</td><td align="left">任意で構いません。</td></tr><tr><td align="left">地域</td><td align="left">元のクラシック VM と同一リージョンにします。</td></tr><tr><td align="left">可用性ゾーン</td><td align="left">ゾーンを使用しない場合は「必要ありません」を選択します。</td></tr><tr><td align="left">ソースの種類</td><td align="left">「ストレージ BLOB」を選択します。</td></tr><tr><td align="left">ソース サブスクリプション</td><td align="left">当該のサブスクリプションを選択します。</td></tr><tr><td align="left">ソース BLOB</td><td align="left">「参照」ボタンを選択し、コピーした ARM ストレージアカウント内の VHD ファイルを選択します。この際サイズも確認できます。</td></tr><tr><td align="left">OS の種類</td><td align="left">VHD の内容に合わせてご選択ください。</td></tr><tr><td align="left">VM の世代</td><td align="left">元がクラシック VM なので「第 1 世代」を選択します。</td></tr><tr><td align="left">VM アーキテクチャ</td><td align="left">既定の「x64」となります。</td></tr><tr><td align="left">サイズ</td><td align="left">VHD より大きなサイズに設定します。ストレージの種類は任意で構いません。</td></tr></tbody></table><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-16-11-41-10.png"></p><p>その他のオプションは既定のままで大丈夫ですので、ディスクの作成を行ってください。<br>データディスクがある場合は同様の手順でデータディスクもご対応をお願いいたします。  </p><hr><h2 id="3-ディスクリソースから-ARM-VM-を作成する。"><a href="#3-ディスクリソースから-ARM-VM-を作成する。" class="headerlink" title="3. ディスクリソースから ARM VM を作成する。"></a>3. ディスクリソースから ARM VM を作成する。</h2><p>最後に作成した OS ディスクのリソースの画面をポータルで表示します。<br>上部に「VM の作成」ボタンがございますので、こちらを選択します。  </p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-16-11-44-29.png"></p><p>新規 ARM VM の作成画面に遷移いたしますので、お客様の環境に合わせて ARM VM の作成を実施くださいませ。<br>作成時に「ディスク」のタブよりデータディスクのアタッチも可能でございます。  </p><p><img src="/blog/vm/classic-vhd-to-arm-vm/2023-08-16-14-38-17.png"></p><hr><p>以上で ARM VM の作成ができました。必要に応じて不要となった VHD などは削除くださいませ。<br>上記の内容がお役に立てますと幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;Azure のクラシック VM は 2023 年 9 月 6 日を持ちまして廃止となりました。&lt;br&gt;そのためこれ以降サポートされる VM は ARM（Azure Resource Manager）の </summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>セルフサービスメンテナンスについて（FAQ）</title>
    <link href="https://jpaztech.github.io/blog/vm/self-service-maintenance/"/>
    <id>https://jpaztech.github.io/blog/vm/self-service-maintenance/</id>
    <published>2023-08-18T03:00:00.000Z</published>
    <updated>2023-12-29T07:45:22.007Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>今回はよくお問い合わせいただく VM（仮想マシン）の「再起動を伴うメンテナンス」に伴い、事前にメンテナンスが可能となるセルフサービスメンテナンスについて、以下のような内容を解説させていただきます。</p><ul><li><a href=".#%E3%82%BB%E3%83%AB%E3%83%95%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E3%81%AE%E6%A6%82%E8%A6%81">セルフサービスメンテナンスの概要</a></li><li><a href=".#%E5%86%8D%E8%B5%B7%E5%8B%95%E3%82%92%E4%BC%B4%E3%81%86%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E5%AF%BE%E8%B1%A1-VM-%E3%81%AE%E7%A2%BA%E8%AA%8D%E3%81%AF%E3%81%A9%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E8%A1%8C%E3%81%88%E3%81%B0%E3%82%88%E3%81%84%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F">再起動を伴うメンテナンス対象 VM の確認はどのように行えばよいですか？</a></li><li><a href=".#%E5%86%8D%E8%B5%B7%E5%8B%95%E3%82%92%E4%BC%B4%E3%81%86%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E3%81%AE%E8%A8%88%E7%94%BB%E3%82%92%E3%83%A1%E3%83%BC%E3%83%AB%E9%80%9A%E7%9F%A5%E3%81%99%E3%82%8B%E3%81%AB%E3%81%AF%E3%81%A9%E3%81%86%E3%81%99%E3%82%8C%E3%81%B0%E3%82%88%E3%81%84%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F">再起動を伴うメンテナンスの計画をメール通知するにはどうすればよいですか？</a></li><li><a href=".#%E5%86%8D%E8%B5%B7%E5%8B%95%E3%82%92%E4%BC%B4%E3%81%86%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E3%81%AE%E9%80%9A%E7%9F%A5%E3%81%AE%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB%E3%81%AF%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F">再起動を伴うメンテナンスの通知のサンプルはありますか？</a></li><li><a href=".#%E3%82%BB%E3%83%AB%E3%83%95%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E3%81%AF%E3%81%A9%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E5%AE%9F%E8%A1%8C%E3%81%99%E3%82%8C%E3%81%B0%E3%82%88%E3%81%84%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F">セルフサービスメンテナンスはどのように実行すればよいですか？</a></li><li><a href=".#%E9%80%9A%E5%B8%B8%E3%81%AE%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E8%A7%A3%E9%99%A4%E3%82%84%E5%86%8D%E8%B5%B7%E5%8B%95%E7%AD%89%E3%81%A7%E3%82%BB%E3%83%AB%E3%83%95%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E3%81%AF%E5%AE%8C%E4%BA%86%E3%81%97%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F">通常の割り当て解除や再起動等でセルフサービスメンテナンスは完了しますか？</a></li><li><a href=".#%E5%86%8D%E8%B5%B7%E5%8B%95%E3%82%92%E4%BC%B4%E3%81%86%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E5%AF%BE%E8%B1%A1%E4%B8%80%E8%A6%A7%E3%81%8B%E3%82%89%E5%AF%BE%E8%B1%A1-VM-%E3%81%8C%E6%B6%88%E3%81%88%E3%81%A6%E3%81%84%E3%81%9F%E3%81%AE%E3%81%A7%E3%81%99%E3%81%8C%E4%BD%95%E6%95%85%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F">再起動を伴うメンテナンス対象一覧から対象 VM が消えていたのですが何故ですか？</a></li><li><a href=".#%E5%86%8D%E8%B5%B7%E5%8B%95%E3%82%92%E4%BC%B4%E3%81%86%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E3%81%AE%E5%AE%8C%E4%BA%86%EF%BC%88%E6%88%90%E5%8A%9F%EF%BC%89%E3%81%AE%E7%A2%BA%E8%AA%8D%E6%96%B9%E6%B3%95%E3%81%AF%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F">再起動を伴うメンテナンスの完了（成功）の確認方法はありますか？</a></li><li><a href=".#%E3%82%BB%E3%83%AB%E3%83%95%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E5%AE%9F%E8%A1%8C%E6%99%82%E3%81%AF-VM-%E3%81%8C%E8%B5%B7%E5%8B%95%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F">セルフサービスメンテナンス実行時は VM が起動している必要がありますか？</a></li><li><a href=".#%E3%82%BB%E3%83%AB%E3%83%95%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E6%9C%9F%E9%96%93%E4%B8%AD%E3%81%AB%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E3%82%92%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%A9%E3%81%86%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F">セルフサービスメンテナンス期間中にメンテナンスをしないとどうなりますか？</a></li><li><a href=".#%E5%88%A5%E3%81%AE%E3%82%B5%E3%83%96%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A7%E3%81%AF%E3%81%93%E3%81%AE%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E3%81%8C%E9%80%9A%E7%9F%A5%E3%81%95%E3%82%8C%E3%81%BE%E3%81%9B%E3%82%93%E3%81%8C%E4%BD%95%E6%95%85%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F">別のサブスクリプションではこのメンテナンスが通知されませんが何故ですか？</a></li><li><a href=".#%E3%83%A1%E3%83%BC%E3%83%AB%E3%81%A7%E3%81%AE%E3%81%BF%E5%AF%BE%E8%B1%A1-VM-%E3%81%8C%E9%80%9A%E7%9F%A5%E3%81%95%E3%82%8C%E3%82%8B%E5%86%8D%E8%B5%B7%E5%8B%95%E3%82%92%E4%BC%B4%E3%81%86%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">メールでのみ対象 VM が通知される再起動を伴うメンテナンスについて</a></li></ul><hr><h2 id="セルフサービスメンテナンスの概要"><a href="#セルフサービスメンテナンスの概要" class="headerlink" title="セルフサービスメンテナンスの概要"></a>セルフサービスメンテナンスの概要</h2><p>Azure ではお客様の安全のためセキュリティの対応や機能改修等として日々メンテナンスを行っております。<br>そのメンテナンスの中で、稀にお客様の VM の再起動を伴う場合がございます。<br>このようなメンテナンスは「再起動を伴うメンテナンス」と呼ばれております。</p><p>■ご参考：Azure での仮想マシンのメンテナンス<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates</a></p><p>■ご参考：計画メンテナンスの通知の処理<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications</a></p><p>■ご参考：Azure IaaS VM で実施されるメンテナンスについて<br><a href="https://jpaztech.github.io/blog/vm/vm-maintenance/">https://jpaztech.github.io/blog/vm/vm-maintenance/</a></p><p>VM 再起動を伴うメンテナンスについては原則として、事前にお客様の方で任意の時間にメンテナンスを実施することができる、セルフサービスメンテナンスが提供されます。<br>以下にセルフサービスメンテナンスについてよく寄せられる質問のご案内をさせていただきます。  </p><div class="alert is-success"><p class="alert-title">ヒント</p><p>セルフサービスメンテナンスを実行しても、実際は Azure 基盤側にてハードウェアのメンテナンスがトリガーされるわけではございません。</p><p>セルフサービスメンテナンスが実行された場合、お客様の VM がメンテナンス対象の物理ホストサーバーからメンテナンス対象外の物理ホストサーバーに移動されるものとなります。</p></div><hr><h2 id="再起動を伴うメンテナンス対象-VM-の確認はどのように行えばよいですか？"><a href="#再起動を伴うメンテナンス対象-VM-の確認はどのように行えばよいですか？" class="headerlink" title="再起動を伴うメンテナンス対象 VM の確認はどのように行えばよいですか？"></a>再起動を伴うメンテナンス対象 VM の確認はどのように行えばよいですか？</h2><p>以下のドキュメントに記載の通り、Azure ポータル / Azure PowerShell / Azure CLI より確認することが可能です。</p><p>■ご参考：ポータルを使用した計画済みメンテナンスの通知の処理<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-portal">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-portal</a></p><p>■ご参考：PowerShell を使用した計画メンテナンスの処理<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-powershell">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-powershell</a></p><p>■ご参考：Azure CLI に対する計画済みメンテナンスの通知の処理<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-cli">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-cli</a></p><p>では、実際にメンテナンスをポータルから確認する例を 2 つの方法よりスクリーンショット交えて紹介させていただきます。  </p><h3 id="方法-1-サービス正常性よりメンテナンス対象-VM-を確認する"><a href="#方法-1-サービス正常性よりメンテナンス対象-VM-を確認する" class="headerlink" title="方法 1: サービス正常性よりメンテナンス対象 VM を確認する"></a>方法 1: サービス正常性よりメンテナンス対象 VM を確認する</h3><p>ポータル上部の検索ボックスより「サービス正常性」を検索して選択します。  </p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-07-11.png"></p><p>表示されたサービス正常性の画面の、左側のメニューより「計画メンテナンス」を表示します。<br>サブスクリプション等のフィルタリングを設定し、対象のメンテナンスを選択すると、メンテナンスの概要が表示されます。</p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-12-02.png"></p><p>下部の「影響を受けるリソース」タブを表示することで、メンテナンス対象となる VM が確認できます。<br>「状態」の列が「先行メンテナンスの管理」になっている VM はメンテナンス対象となっております。<br>「状態」の列が「更新済み」の VM、もしくはそもそも「影響を受けるリソース」表示されていない VM はメンテナンス対象外となっております。  </p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-34-21.png"></p><h3 id="方法-2-VM-一覧よりメンテナンス対象-VM-を確認する"><a href="#方法-2-VM-一覧よりメンテナンス対象-VM-を確認する" class="headerlink" title="方法 2: VM 一覧よりメンテナンス対象 VM を確認する"></a>方法 2: VM 一覧よりメンテナンス対象 VM を確認する</h3><p>ポータル上部の検索ボックスより「Virtual Machines」を検索して選択します。  </p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-23-02.png"></p><p>上部の「メンテナンス」ボタンより「仮想マシンのメンテナンス」を選択します。</p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-25-33.png"></p><p>仮想マシンのメンテナンス一覧の画面が表示されますので、メンテナンス対象となっている VM があるか確認ができます。</p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-26-41.png"></p><hr><h2 id="再起動を伴うメンテナンスの計画をメール通知するにはどうすればよいですか？"><a href="#再起動を伴うメンテナンスの計画をメール通知するにはどうすればよいですか？" class="headerlink" title="再起動を伴うメンテナンスの計画をメール通知するにはどうすればよいですか？"></a>再起動を伴うメンテナンスの計画をメール通知するにはどうすればよいですか？</h2><p>一部のメンテナンスについては、設定をしなくとも管理者にメール通知されることがございますが、原則として再起動が伴うメンテナンスが計画された際にメールで通知を行うには、サービス正常性のアラート設定を行う必要がございます。  </p><p>■ご参考：ポータルの通知とアラート<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-portal#notification-and-alerts-in-the-portal">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-portal#notification-and-alerts-in-the-portal</a></p><blockquote><p>ーーーーーー抜粋ーーーーーー<br>仮想マシン関連のメンテナンス通知は、Azure portal の [サービスの正常性] で使用できます。<br>一部の特定の仮想マシンの計画メンテナンス シナリオでは、Azure が従来のサブスクリプション管理者、共同管理者、およびサブスクリプション所有者グループに追加のメール (Service Health 以外) を送信して、スケジュールを通知する場合があります。<br>ーーーーーーーーーーーーーー  </p></blockquote><p>メンテナンスに限らず、サービス正常性アラートは Azure サービス自体の正常性を監視するのに役立ちます。<br>サービス正常性アラートについては別途弊社の解説ブログ記事もございますので、参考としてご案内させていただきます。  </p><p>■ご参考：サービス正常性アラートの設定手順と推奨設定について<br><a href="https://jpazmon-integ.github.io/blog/ame/HowToSetUpServiceHealthAlertsAndRecommendedSettings/">https://jpazmon-integ.github.io/blog/ame/HowToSetUpServiceHealthAlertsAndRecommendedSettings/</a></p><p>では、実際にメール通知を行うための手順についてスクリーンショットを交えて紹介させていただきます。  </p><p>ポータル上部の検索ボックスより「サービス正常性」を検索して選択します。  </p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-07-11.png"></p><p>上部の「サービス正常性アラートの作成」をボタンを選択します。  </p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-29-10.png"></p><p>スコープにて対象とするサブスクリプションを選択します。  </p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-30-10.png"></p><p>条件にて、VM および VMSS に関する再起動を伴うメンテナンスの通知を行うため、以下の設定を行います。</p><ul><li>サービス：Virtual Machines および Azure Virtual Machine Scale Sets を選択。  </li><li>地域：任意のリージョンを選択。</li><li>イベントの種類：計画メンテナンスを選択。</li></ul><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-30-54.png"></p><p>アクションにて、メンテナンスが計画された際にどのように通知アクションを行うのか設定します。<br>既にアクション グループが存在する場合は「アクション グループの選択」を選んでください。<br>新規にメール通知を行うアクション グループを作成する際は、「アクション グループの作成」を選択いただき、任意のメールアドレスへ通知を行うアクショングループを新規作成してください。</p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-31-57.png"></p><p>最後に詳細にて、このアラートの名前を設定してアラートを作成します。 </p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-32-53.png"></p><p>これで再起動を伴うメンテナンスが計画された際に、メール通知を行うアラートが作成できました。</p><hr><h2 id="再起動を伴うメンテナンスの通知のサンプルはありますか？"><a href="#再起動を伴うメンテナンスの通知のサンプルはありますか？" class="headerlink" title="再起動を伴うメンテナンスの通知のサンプルはありますか？"></a>再起動を伴うメンテナンスの通知のサンプルはありますか？</h2><p>以下は、再起動を伴うメンテナンスの通知のサンプルとなります。<br>「サービス正常性」の「計画メンテナンス」より確認頂くことが可能でございます。<br><strong>メンテナンス毎に内容は変わりますので、実際に通知されたメンテナンス通知内容のご確認をお願い申し上げます。</strong> </p><blockquote><p>Dear Azure customer,</p><p>One or more Azure Virtual Machines (VMs) associated with your subscription require a maintenance update to migrate these VMs to newer hardware. While the vast majority of platform maintenance causes no interruption to your services, this update will require a reboot.  </p><p>This maintenance has two phases: the self-service phase and a scheduled maintenance phase.  </p><p>Azure Service Health provides you with the current status of each VM that requires maintenance and allows you to initiate the self-service maintenance proactively – any time between now and July 26, 2023 (23:59 UTC). If self-service maintenance has not been completed by then, Azure will automatically initiate maintenance on any VM that still requires it, sometime between July 27, 2023 (00:00 UTC) to August 02, 2023 (23:59 UTC). This scheduled maintenance will be performed one update domain at a time, to limit impact to environments configured for high availability.  </p><p>You can view a list of Affected Resources for this event under the ServiceHealth/PlannedMaintenance tab in the Azure portal  </p><p>You should expect each VM to be unavailable for up to 15 minutes after initiating the maintenance and note that operating system and data disks will be retained, but temporary storage will be lost during this maintenance. If you are using Dv1 or DSv1 VM sizes, please refer to the documentation <a href="https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes-previous-gen">here</a> to understand performance changes if any.  </p><p>If you are using Proximity Placement Groups, please refer to the documentation <a href="https://docs.microsoft.com/en-us/azure/virtual-machines/co-location#planned-maintenance-and-proximity-placement-groups">here</a> to understand how to verify the alignment of your resources and to take appropriate action if some resources are not aligned.  </p><p>We apologize for any impact that this maintenance may have. We strive to minimize the impact of platform maintenance, and to provide you with as much visibility and control as possible.  </p></blockquote><hr><h2 id="セルフサービスメンテナンスはどのように実行すればよいですか？"><a href="#セルフサービスメンテナンスはどのように実行すればよいですか？" class="headerlink" title="セルフサービスメンテナンスはどのように実行すればよいですか？"></a>セルフサービスメンテナンスはどのように実行すればよいですか？</h2><p>セルフサービスメンテナンスを実行するためには、通常の再起動操作とは別の操作が必要となります。<br>具体的な実行方法としては、以下のドキュメントに記載の通り、Azure ポータル / Azure PowerShell / Azure CLI より実行することが可能です。<br>セルフサービスメンテナンスを開始すると VM が再起動しますのでご留意ください。  </p><p>■ご参考：ポータルから VM に対するメンテナンスを開始する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-portal#start-maintenance-on-your-vm-from-the-portal">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-portal#start-maintenance-on-your-vm-from-the-portal</a></p><p>■ご参考：PowerShell を使用して VM に対するメンテナンスを開始する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-powershell#start-maintenance-on-your-vm-using-powershell">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-powershell#start-maintenance-on-your-vm-using-powershell</a></p><p>■ご参考：メンテナンスを開始する（Azure CLI）<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-cli#start-maintenance">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications-cli#start-maintenance</a></p><p>ポータルから実行する例として、先述のサービス正常性の計画メンテナンスの対象 VM 確認画面より、「先行メンテナンスの管理」ボタンを推すことでメンテナンス開始画面に遷移することができます。  </p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-34-58.png"></p><p>以下がメンテナンス開始画面の例となります。<br>「メンテナンスを開始する」ボタンを選択頂くことで、セルフサービスメンテナンスが開始されます。  </p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-35-59.png"></p><p>なお、メンテナンス対象となっている VM については対象 VM の概要画面にも、以下のようなリボンが上部に表示されており、このリボンを選択頂くことでメンテナンス開始に進むことができます。  </p><p><img src="/blog/vm/self-service-maintenance/2023-07-26-13-38-00.png"></p><hr><h2 id="通常の割り当て解除や再起動等でセルフサービスメンテナンスは完了しますか？"><a href="#通常の割り当て解除や再起動等でセルフサービスメンテナンスは完了しますか？" class="headerlink" title="通常の割り当て解除や再起動等でセルフサービスメンテナンスは完了しますか？"></a>通常の割り当て解除や再起動等でセルフサービスメンテナンスは完了しますか？</h2><p>まずセルフサービスメンテナンスが実行され、完了時にメンテナンス対象外の物理ホストサーバーに VM が移動することを保証している方法としては、上記の「セルフサービスメンテナンスの開始」の方法となっております。  </p><p>他方、「割り当て解除」および「再デプロイ」操作を行っていただいた場合は、メンテナンス対象外の物理ホストサーバーに VM が移動することがあり、結果としてメンテナンス完了状態となる可能性がございます。<br>しかしながら、引き続きメンテナンス対象の物理ホストサーバーで VM が稼働することもございます。</p><p>なお、「ポータルでの再起動」や「OS 内部のシャットダウン / 再起動」の場合、VM の物理ホストサーバー移動は起きませんため、メンテナンス完了とはならないものと存じます。  </p><p>すなわち、セルフサービスメンテナンスを行う場合は先述の「セルフサービスメンテナンスの開始」の方法で実施をお願いいたします。  </p><hr><h2 id="再起動を伴うメンテナンス対象一覧から対象-VM-が消えていたのですが何故ですか？"><a href="#再起動を伴うメンテナンス対象一覧から対象-VM-が消えていたのですが何故ですか？" class="headerlink" title="再起動を伴うメンテナンス対象一覧から対象 VM が消えていたのですが何故ですか？"></a>再起動を伴うメンテナンス対象一覧から対象 VM が消えていたのですが何故ですか？</h2><p>以下のドキュメントに記載の通り、VM がメンテナンス対象から外れることがございます。<br>よくあるシナリオとしては、お客様の方で VM の割り当て解除および起動が行われたことで、メンテナンス対象外の物理ホストサーバーに VM が移動したことによりメンテナンス対象外となるといったパターンです。<br>メンテナンス対象から表示が消えている VM については、セルフサービスメンテナンスが不要となっておりますので、特にご対応をいただく必要はございません。</p><p>■ご参考：よく寄せられる質問<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications#faq">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications#faq</a></p><blockquote><p>ーーーーーー抜粋ーーーーーー<br>Q: VM のメンテナンス情報が表示されません。 問題の原因  </p><p>A: VM のメンテナンス情報が表示されない理由はいくつかあります。  </p><p>1.Microsoft 社内としてマークされたサブスクリプションを使用している。<br>2.VM のメンテナンスがスケジュールされていない。 メンテナンス ウェーブが終了しているか、取り消し&gt;または変更が行われたため、VM が影響を受けなくなっていると考えられます。<br><strong>3.あなたは VM の割り当てを解除し、その後、VM を起動しました。 それを行うと、メンテナンス ウェーブを計画していない場所に VM が移動する可能性があります。 そのため、VM にはメンテナンス情報が表示されません。</strong><br>4.VM リスト ビューに [メンテナンス] 列が追加されていない。 この列は既定のビューに追加されていますが、既定以外の列を表示するように構成しているお客様は、VM リスト ビューに [メンテナンス] 列を手動で追加する必要があります。<br>ーーーーーーーーーーーーーー  </p></blockquote><hr><h2 id="再起動を伴うメンテナンスの完了（成功）の確認方法はありますか？"><a href="#再起動を伴うメンテナンスの完了（成功）の確認方法はありますか？" class="headerlink" title="再起動を伴うメンテナンスの完了（成功）の確認方法はありますか？"></a>再起動を伴うメンテナンスの完了（成功）の確認方法はありますか？</h2><p>先述のサービス正常性の計画メンテナンスの対象 VM 確認画面上で、「影響を受けるリソース」の一覧をご確認いただき、以下のいずれかの状態であればメンテナンスが完了（成功）していると考えていただいて差し支えございません。</p><ul><li>対象の VM　について「状態」の列が「更新済み」と表示さていている。</li><li>もしくは、対象の VM が「影響を受けるリソース」の一覧表示から消えている。</li></ul><p><img src="/blog/vm/self-service-maintenance/2023-07-26-14-46-32.png"></p><hr><h2 id="セルフサービスメンテナンス実行時は-VM-が起動している必要がありますか？"><a href="#セルフサービスメンテナンス実行時は-VM-が起動している必要がありますか？" class="headerlink" title="セルフサービスメンテナンス実行時は VM が起動している必要がありますか？"></a>セルフサービスメンテナンス実行時は VM が起動している必要がありますか？</h2><p>セルフサービスメンテナンスは VM が「割り当て解除済み」の状態では実行が叶いません。<br>「実行中」や「停止済み（OS 内部からのシャットダウン完了）」の状態であればセルフサービスメンテナンスは実行可能となります。  </p><hr><h2 id="セルフサービスメンテナンス期間中にメンテナンスをしないとどうなりますか？"><a href="#セルフサービスメンテナンス期間中にメンテナンスをしないとどうなりますか？" class="headerlink" title="セルフサービスメンテナンス期間中にメンテナンスをしないとどうなりますか？"></a>セルフサービスメンテナンス期間中にメンテナンスをしないとどうなりますか？</h2><p>セルフサービスメンテナンスの実行可能な期間が終了すると、予定メンテナンス フェーズになります。<br>セルフサービスメンテナンス期間中にセルフサービスメンテナンスを実行せずに、予定メンテナンス フェーズに入った場合は、自動的に再起動を伴うメンテナンスが実行されます。<br>この場合、予定メンテナンス フェーズではお客様の方でメンテナンス実行のタイミングを制御することは叶いません点、ご了承くださいませ。  </p><hr><h2 id="別のサブスクリプションではこのメンテナンスが通知されませんが何故ですか？"><a href="#別のサブスクリプションではこのメンテナンスが通知されませんが何故ですか？" class="headerlink" title="別のサブスクリプションではこのメンテナンスが通知されませんが何故ですか？"></a>別のサブスクリプションではこのメンテナンスが通知されませんが何故ですか？</h2><p>再起動を伴うメンテナンスの通知は、あくまでメンテナンス対象があるサブスクリプションにのみ通知されます。<br>そのため、メンテナンスの通知がされていないサブスクリプションに関してはメンテナンス対象が無いと考えて頂いて差し支えございません。</p><hr><h2 id="メールでのみ対象-VM-が通知される再起動を伴うメンテナンスについて"><a href="#メールでのみ対象-VM-が通知される再起動を伴うメンテナンスについて" class="headerlink" title="メールでのみ対象 VM が通知される再起動を伴うメンテナンスについて"></a>メールでのみ対象 VM が通知される再起動を伴うメンテナンスについて</h2><p>稀ではございますが、再起動を伴うメンテナンスについて、Azure ポータル等では対象 VM の確認が叶わず、メールでのみメンテナンス対象 VM が通知される場合がございます。<br>この場合は、そのメール内に対象 VM の通知を行った旨やどのような対応が必要かといった内容が記載されておりますため、通知に記載の内容をご確認いただきご対応をお願い申し上げます。</p><hr><p>以上の通り、セルフサービスメンテナンスについて解説をさせていただきました。<br>メンテナンスについてご不明点がございます場合は、対象のメンテナンスに割り振られている TrackingID（追跡 ID）を添えて、Azure 技術サポート窓口にお問い合わせを頂けますと幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;今回はよくお問い合わせいただく VM（仮想マシン）の「再起動を伴うメンテナンス」に伴い、事前にメンテナンスが可能となるセルフサービスメンテナンスについて、以下のような内容を解説させていただきます。&lt;/p</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>Azure Windows VM の KMS ライセンス認証トラブルシューティングについて</title>
    <link href="https://jpaztech.github.io/blog/vm/kms-troubleshooting/"/>
    <id>https://jpaztech.github.io/blog/vm/kms-troubleshooting/</id>
    <published>2023-08-17T08:30:00.000Z</published>
    <updated>2023-12-29T07:45:21.939Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>Azure 上で稼働する Windows VM のライセンス認証のためにマイクロソフトが KMS サーバー（KMS ホスト サーバー）を提供しております。<br>KMS サーバーへのライセンス認証要求は KMS クライアント (Windows VM) から KMS サーバーに対して定期的かつ自動的に実行されます。<br>Azure Windows VM から Azure の KMS サーバーに対して適切な経路で通信が行えない環境等においては、KMS のライセンス認証が失敗し続け、ライセンス認証切れに関する警告が表示されることがございます。<br>本件について多くのお問い合わせをいただきますため、KMS のライセンス認証のトラブルシューティング等について以下の内容をご紹介させていただきます。</p><ul><li><p><a href="./#KMS-%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E8%AA%8D%E8%A8%BC%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E8%A7%A3%E8%AA%AC">KMS ライセンス認証についての解説</a></p><ul><li><a href="./#KMS-%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E8%AA%8D%E8%A8%BC%E3%81%AE%E6%A6%82%E8%A6%81">KMS ライセンス認証の概要</a></li><li><a href="./#KMS-%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E8%AA%8D%E8%A8%BC%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%AA%E8%A8%AD%E5%AE%9A%E3%81%8A%E3%82%88%E3%81%B3%E9%80%9A%E4%BF%A1%E8%A6%81%E4%BB%B6">KMS ライセンス認証に必要な設定および通信要件</a></li><li><a href="./#%E8%87%AA%E5%8B%95%E7%9A%84%E3%81%AA%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E8%AA%8D%E8%A8%BC%E3%81%8A%E3%82%88%E3%81%B3%E6%9C%89%E5%8A%B9%E6%9C%9F%E9%99%90%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">自動的なライセンス認証および有効期限について</a></li><li><a href="./#%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E8%AA%8D%E8%A8%BC%E5%88%87%E3%82%8C%E3%81%AE%E5%BD%B1%E9%9F%BF">ライセンス認証切れの影響</a></li></ul></li><li><p><a href="./#%E3%83%88%E3%83%A9%E3%83%96%E3%83%AB%E3%82%B7%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E6%96%B9%E6%B3%95">トラブルシューティング方法</a></p><ul><li><a href="./#%E6%89%8B%E5%8B%95%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E8%AA%8D%E8%A8%BC%E3%81%AE%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E5%AE%9F%E8%A1%8C">手動ライセンス認証のコマンド実行</a></li><li><a href="./#%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E7%8A%B6%E6%85%8B%E3%81%8A%E3%82%88%E3%81%B3%E8%A8%AD%E5%AE%9A%E7%A2%BA%E8%AA%8D">ライセンス状態および設定確認</a></li><li><a href="./#KMS-%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%81%B8%E3%81%AE%E5%90%8D%E5%89%8D%E8%A7%A3%E6%B1%BA%E3%81%8A%E3%82%88%E3%81%B3%E7%96%8E%E9%80%9A%E7%A2%BA%E8%AA%8D%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%AE%E5%AE%9F%E8%A1%8C">KMS サーバーへの名前解決および疎通確認コマンドの実行</a></li><li><a href="./#%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E3%83%AD%E3%82%B0%E3%81%A7%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E3%83%AD%E3%82%B0%E3%82%92%E8%A6%8B%E3%82%8B">イベントログでライセンスログを見る</a></li></ul></li><li><p><a href="./#%E3%82%88%E3%81%8F%E3%81%82%E3%82%8B%E3%83%88%E3%83%A9%E3%83%96%E3%83%AB%E3%81%AE%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">よくあるトラブルのパターン</a></p><ul><li><a href="./#KMS-%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%81%AE%E4%B8%80%E6%99%82%E7%9A%84%E3%81%AA%E8%B2%A0%E8%8D%B7">KMS サーバーの一時的な負荷</a></li><li><a href="./#%E3%83%95%E3%82%A1%E3%82%A4%E3%82%A2%E3%82%A6%E3%82%A9%E3%83%BC%E3%83%AB%E8%A3%BD%E5%93%81%E3%81%A7%E9%80%9A%E4%BF%A1%E3%82%92%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B">ファイアウォール製品で通信をブロックしている</a></li><li><a href="./#%E5%BC%B7%E5%88%B6%E3%83%88%E3%83%B3%E3%83%8D%E3%83%AA%E3%83%B3%E3%82%B0%E7%92%B0%E5%A2%83%EF%BC%88%E3%82%AA%E3%83%B3%E3%83%97%E3%83%AC%E3%83%9F%E3%82%B9%E7%AD%89%E3%82%92%E7%B5%8C%E7%94%B1%E3%81%97%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E3%81%A8%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%EF%BC%89">強制トンネリング環境（オンプレミス等を経由し直接通信となっていない）</a></li><li><a href="./#Standard-SKU-%E3%81%AE-Azure-Load-Balancer-%E9%85%8D%E4%B8%8B%E3%81%AE-VM-%E3%81%A7%E5%A4%96%E9%83%A8%E6%8E%A5%E7%B6%9A%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84">Standard SKU の Azure Load Balancer 配下の VM で外部接続ができない</a></li><li><a href="./#Tokens-dat-%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E7%A0%B4%E6%90%8D">Tokens.dat ファイルの破損</a></li></ul></li><li><p><a href="./#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB%EF%BC%88%E3%81%9D%E3%81%AE%E4%BB%96%E3%81%AE%E8%A6%81%E5%9B%A0%E7%AD%89%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%EF%BC%89">さいごに（その他の要因等について）</a></p></li></ul><hr><h2 id="KMS-ライセンス認証についての解説"><a href="#KMS-ライセンス認証についての解説" class="headerlink" title="KMS ライセンス認証についての解説"></a>KMS ライセンス認証についての解説</h2><p>先述の通り、Azure 上の Windows VM は定期的かつ自動的に KMS ライセンス認証が行われます。<br>KMS ライセンス認証についてどのように行われるのかといった概要などをご紹介させていただきます。  </p><hr><h3 id="KMS-ライセンス認証の概要"><a href="#KMS-ライセンス認証の概要" class="headerlink" title="KMS ライセンス認証の概要"></a>KMS ライセンス認証の概要</h3><p>Azure 上で稼働する Windows VM は従量課金制となっており、原則稼働時の従量課金にライセンス料が含まれております。<br>ゲスト OS となる Windows からは KMS（Key Management Services）サーバーに、定期的なライセンス認証が行われます。<br>このライセンス認証先の KMS サーバーは Azure 上にマイクロソフトがご用意しております。<br>そのため、お客様のご利用の Windows VM から KMS サーバーへのライセンス認証の通信経路が確保されている必要がございます。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>Azure 上にお客様ご自身で KMS ホストサーバーの役割を担う KMS ホストを構築いただく場合は、そのサーバーではオンプレミス環境と同様に KMS ホストサーバー用の MAK キー（KMS ホスト キー）を使用してライセンス認証を実施する手順が必要となります。  </p></div><hr><h3 id="KMS-ライセンス認証に必要な設定および通信要件"><a href="#KMS-ライセンス認証に必要な設定および通信要件" class="headerlink" title="KMS ライセンス認証に必要な設定および通信要件"></a>KMS ライセンス認証に必要な設定および通信要件</h3><p>Azure VM から KMS サーバーへの通信は、<strong>TCP 宛先ポート 1688</strong> で以下のドメインに対して行われます。</p><blockquote><p><strong>kms.core.windows.net</strong> もしくは <strong>azkms.core.windows.net</strong></p></blockquote><p>このドメインは以下の IP アドレスのいずれかに名前解決されます。</p><blockquote><p><strong>20.118.99.224, 40.83.235.53, 23.102.135.246</strong></p></blockquote><p>なお、KMS ライセンスサーバー自体は Azure 上にご用意をしておりますが、上記の通りグローバル IP アドレスで名前解決されますので、VM からは Internet 方向としてルーティングされる必要がございます。  </p><p>重要な点として、原則 VM から直接 KMS サーバーへの通信を行っていただく必要がございます。<br>オンプレミス環境を経由したライセンス認証の通信ではライセンス認証が失敗することがございます。<br>この点については後述の「強制トンネリング環境（直接通信となっていない）」をご参照ください。<br>下図は KMS ライセンス認証の成功・失敗の例を表した図となります。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-04-16-23-05.png"></p><div class="alert is-success"><p class="alert-title">ヒント</p><p>KMS ライセンスサーバーへのライセンス認証通信については、NSG（ネットワークセキュリティグループ）の影響を受けないよう暗黙的なルールが存在します。</p><p>例外的にサブネットに対して 0.0.0.0/0 のルールがある場合は、暗黙的なルールがスキップされ、明示的に許可ルールが必要となります。  </p></div><p>また、OS 毎に KMS 専用のプロダクトキーの設定が必要です。<br>Azure マーケットプレイスからデプロイした VM 等では既定でこのプロダクトキーが設定されており、対応は不要でございますが、以下のシナリオに該当する場合は手動でライセンスキーの入力が必要となります。</p><ul><li>コンピューターをマルチ ライセンス認証キー (MAK) の使用から KMS クライアントに変換する</li><li>Windows の製品版 (OEM/Retail) ライセンスを KMS クライアントに変換する</li><li>コンピューターが以前に KMS ホストであった場合 KMS クライアントに変換する</li></ul><p>■ご参考：キー管理サービス (KMS) クライアントのライセンス認証とプロダクト キー<br><a href="https://learn.microsoft.com/ja-jp/windows-server/get-started/kms-client-activation-keys">https://learn.microsoft.com/ja-jp/windows-server/get-started/kms-client-activation-keys</a></p><hr><h3 id="自動的なライセンス認証および有効期限について"><a href="#自動的なライセンス認証および有効期限について" class="headerlink" title="自動的なライセンス認証および有効期限について"></a>自動的なライセンス認証および有効期限について</h3><p>ライセンス認証は既定では以下の間隔で自動的に認証されます。  </p><ul><li>ライセンス認証がされていない状態：2 時間に 1 回の頻度</li><li>ライセンス認証がされている状態：7 日に 1 回の頻度</li></ul><p>また、ライセンス認証は毎回必ず成功する必要はなく、一度認証されれば 180 日の有効期限が付与されます。<br>認証に成功する度に有効期限が再び 180 日からカウントされます。  </p><p>つまり、正常な状況であれば定期的なライセンス認証によって、180 日の有効期限が毎回更新されるという形となります。</p><hr><h3 id="ライセンス認証切れの影響"><a href="#ライセンス認証切れの影響" class="headerlink" title="ライセンス認証切れの影響"></a>ライセンス認証切れの影響</h3><p>Windows 8 / Windows Server 2012 以降の OS の場合のライセンス認証の影響について記載させていただきます。<br>上記期間内にライセンス認証が成功しない場合は、通知モード（ライセンス認証切れ状態）となります。<br>この際の影響は以下のようなものとなり VM への接続不可や使用不可になるといった影響はございません。<br>しかしながら、ライセンス認証が切れる前にライセンス認証が成功となるようご対応をお願いいたします。  </p><ol><li>画面の右下にライセンス認証が必要であることを示すウォーターマーク（透かし文字） が表示されます。</li><li>壁紙の右下に OS の情報を示す文字が表示されます。（Windows 8 / Windows Server 2012 及び 2012 R2 のみ）</li><li>パーソナル設定内の項目は設定変更不可となります。</li><li>自身が KMS ホストの場合、KMS クライアントの認証が行えません。</li></ol><hr><h2 id="トラブルシューティング方法"><a href="#トラブルシューティング方法" class="headerlink" title="トラブルシューティング方法"></a>トラブルシューティング方法</h2><p>ライセンス有効期限が近づくと、以下のようなライセンス認証を促すメッセージなどが表示されることがございます。  </p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-11-38-39.png" alt="Windows のライセンスの有効期限がもうすぐ切れます [設定] で Windows のライセンス認証を行う必要があります"></p><p>また、ライセンス認証が切れた際にメッセージが表示されるものと存じます。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-11-39-40.png" alt="Windows ライセンスの有効期限が切れています"></p><p>この場合は、何からの理由で自動的なライセンス認証が繰り返し失敗しており、ライセンス認証がまもなく切れる / 切れてしまっているといった状況が考えられます。 </p><p>よくあるライセンス認証の失敗のエラーコードとして「0xC004F074」や「0x8007139F」が表示されることがございます。<br>エラーコードから一発で原因究明ができるのが望ましいですが、恐縮ながら KMS ライセンス認証のトラブルシューティングは 1 つずつ原因切り分け等を行う必要がございます。<br>そのため、まずは先述の必要な通信要件等が可能な状況かご確認いただくことが必要です。<br>以下に正常なライセンス認証を行うためのトラブルシューティング方法を解説させていただきます。  </p><p>■ご参考：Azure Windows 仮想マシンのライセンス認証に関する問題のトラブルシューティング<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-activation-problems">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-activation-problems</a></p><hr><h3 id="手動ライセンス認証のコマンド実行"><a href="#手動ライセンス認証のコマンド実行" class="headerlink" title="手動ライセンス認証のコマンド実行"></a>手動ライセンス認証のコマンド実行</h3><p>まずは、手動でのライセンス認証コマンドを実行し、ライセンス認証が正常に成功するかご確認頂くのが良いかと存じます。<br>別途設定などの修正等を行った後にライセンス認証が成功するか確認する際にもこちらのコマンドをご利用いただけます。<br>管理者特権の Windows PowerShell プロンプトにて以下のコマンドの実行をお願いいたします。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>..<span class="number">12</span> | <span class="built_in">ForEach-Object</span> &#123; <span class="built_in">Invoke-Expression</span> <span class="string">&quot;<span class="variable">$env:windir</span>\system32\cscript.exe <span class="variable">$env:windir</span>\system32\slmgr.vbs /ato&quot;</span> ; <span class="built_in">start-sleep</span> <span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure><p>こちらのコマンドは、KMS サーバーに対しライセンス認証を 5 秒毎に 12 回実行するコマンドとなっております。<br>1 回のみの実行の場合、一時的な問題で失敗することがございますため複数回の実行としております。<br>成功した場合は以下のようなメッセージが表示されます。  </p><blockquote><p>Windows(R)、ServerDatacenter エディションのアクティブ化 (12345678-1234-1234-1234-1234-12345678) … 製品が正常にアクティブ化されました。</p></blockquote><hr><h3 id="ライセンス状態および設定確認"><a href="#ライセンス状態および設定確認" class="headerlink" title="ライセンス状態および設定確認"></a>ライセンス状態および設定確認</h3><p>ライセンス状態および設定確認を行うには PowerShell で以下のコマンドを実行します。  </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript c:\windows\system32\slmgr.vbs /dlv</span><br></pre></td></tr></table></figure><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-11-37-28.png"></p><p>上記のように、ライセンスの状態やライセンス認証先の情報の確認が可能でございます。  </p><p>なお、ライセンスの有効期限が切れた状態などでは上記コマンドでライセンス認証先 KMS サーバーの情報が表示されないことがございます。<br>そのような場合は以下のいずれか方法でライセンス認証先 KMS サーバーの情報を確認することが可能です。  </p><ul><li><strong>Event Viewer (Local) &gt; Windows Logs &gt; Application</strong> アプリケーションイベントログのイベント ID 12288 でライセンス認証先を確認する。</li><li>以下のコマンドを実行する。</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 設定されているライセンス認証先 KMS サーバーのドメインを確認</span></span><br><span class="line">reg query <span class="string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform&quot;</span> /v KeyManagementServiceName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定されているライセンス認証先 KMS サーバーのポート番号を確認</span></span><br><span class="line">reg query <span class="string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform&quot;</span> /v KeyManagementServicePort</span><br></pre></td></tr></table></figure><p>もしライセンス認証先 KMS サーバーを IP アドレスを固定で指定してしまっている場合など、KMS ライセンス認証先の修正が必要な場合は以下のコマンドで修正可能です。<br>なお、修正後に設定を反映させるために先述の手動のライセンス認証のコマンド実行も合わせてお願いいたします。  </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript c:\windows\system32\slmgr.vbs /skms azkms.core.windows.net:<span class="number">1688</span></span><br></pre></td></tr></table></figure><hr><h3 id="KMS-サーバーへの名前解決および疎通確認コマンドの実行"><a href="#KMS-サーバーへの名前解決および疎通確認コマンドの実行" class="headerlink" title="KMS サーバーへの名前解決および疎通確認コマンドの実行"></a>KMS サーバーへの名前解決および疎通確認コマンドの実行</h3><p>KMS ライセンス認証が失敗している原因として、名前解決ができていないといった事や、疎通が失敗している可能性がございます。<br>この点の原因切り分けのためには以下の PowerShell コマンドを実行します。</p><ul><li>DNS での名前解決の確認</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 古い情報での名前解決を抑止するため DNS キャッシュをクリア</span></span><br><span class="line">ipconfig /flushdns</span><br><span class="line"></span><br><span class="line"><span class="comment"># KMS サーバーの名前解決が可能か確認する</span></span><br><span class="line">nslookup kms.core.windows.net</span><br><span class="line">nslookup azkms.core.windows.net</span><br></pre></td></tr></table></figure><p>成功した場合は、以下のように KMS サーバーの IP アドレスが名前解決されます。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-11-43-58.png"></p><p>名前解決ができていない場合は、DNS サーバーの設定の見直しやポート 53 UDP での DNS の通信ができているかといった点を確認する必要がございます。</p><ul><li>KMS サーバーへのポート 1688 での疎通確認</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Test-NetConnection</span> <span class="literal">-ComputerName</span> kms.core.windows.net <span class="literal">-Port</span> <span class="number">1688</span></span><br><span class="line"><span class="built_in">Test-NetConnection</span> <span class="literal">-ComputerName</span> azkms.core.windows.net <span class="literal">-Port</span> <span class="number">1688</span></span><br></pre></td></tr></table></figure><p>成功した場合は、以下のような <strong>TcpTestSucceeded : True</strong> の結果が表示されます。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-11-43-05.png"></p><p>こちらの通信が成功しない場合は、OS 内部や経由しているファイアウォールでの通信がブロックされている等の原因が考えられますため、後述のトラブルシューティングなどでこの通信を成功させるように修正が必要です。</p><hr><h3 id="イベントログでライセンスログを見る"><a href="#イベントログでライセンスログを見る" class="headerlink" title="イベントログでライセンスログを見る"></a>イベントログでライセンスログを見る</h3><p>ライセンス認証の成功・失敗については Windows OS 内の Event Viewer を用いて、<br> <strong>Event Viewer (Local) &gt; Windows Logs &gt; Application</strong><br>よりアプリケーションイベントログよりご確認いただくことが可能でございます。<br>以下にトラブルシューティングで使われるイベント ID をご紹介させていただきます。</p><ul><li>12288：KMS クライアントから KMS サーバーに認証を要求した際のログ</li></ul><p>イベント ID 12288 は KMS クライアントが KMS サーバーに対してライセンス認証を要求した際のログとなります。<br>後述の「12289：ライセンス認証の結果表示」と対になるログでございますので、「12288：ライセンス認証開始」はあるが「12289：ライセンス認証の結果表示」が無いといった場合は、以下のいずれかの状況を意味します。  </p><ol><li>KMS クライアントが KMS サーバーに接続できなかったこと</li><li>KMS サーバーが応答しなかったこと</li><li>KMS クライアントが KMS サーバーからの応答を受信しなかったこと</li></ol><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-13-40-29.png"></p><ul><li>12289：ライセンス認証の結果表示</li></ul><p>イベント ID 12289 は KMS ライセンス認証の結果を表示します。<br>以下の図の通り Info に表示されている 3 個目のフラグが「1」の場合はライセンス認証成功です。<br>「0」となっとる場合はライセンス認証失敗となります。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-13-40-57.png"></p><p>■ご参考：便利な KMS クライアント イベント<br><a href="https://learn.microsoft.com/ja-jp/windows-server/get-started/activation-troubleshoot-kms-general#useful-kms-client-events">https://learn.microsoft.com/ja-jp/windows-server/get-started/activation-troubleshoot-kms-general#useful-kms-client-events</a></p><ul><li>8198, 8200：ライセンス認証の失敗</li></ul><p>イベント ID 8198, 8200 は KMS ライセンス認証の失敗時に表示されることのあるログとなります。  </p><p>後述の<a href="./#KMS-%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%81%AE%E4%B8%80%E6%99%82%E7%9A%84%E3%81%AA%E8%B2%A0%E8%8D%B7">「KMS サーバーの一時的な負荷」</a>のセクションに記載の通り、一時的な KMS サーバーの負荷の問題で表示される可能性がございますが、「12289：ライセンス認証の結果表示」にて正常にライセンス認証がされている場合は無視可能となります。<br>そのため、「8198, 8200：ライセンス認証の失敗」は常に発生しておらず単発的な場合は、無視いただいて問題ございません。</p><hr><h2 id="よくあるトラブルのパターン"><a href="#よくあるトラブルのパターン" class="headerlink" title="よくあるトラブルのパターン"></a>よくあるトラブルのパターン</h2><p>お客様から「ライセンス認証が失敗する」といった場合に、よくあるトラブルのパターンおよびその対処方法についてご案内をさせていただきます。  </p><hr><h3 id="KMS-サーバーの一時的な負荷"><a href="#KMS-サーバーの一時的な負荷" class="headerlink" title="KMS サーバーの一時的な負荷"></a>KMS サーバーの一時的な負荷</h3><p>Azure のKMS サーバーは全世界の Azure 上の Windows OS を認証している関係で、稀に負荷が集中するといったタイミングで応答ができない場合がございます。<br>一般的には、エラーイベントが数日に１回、といった頻度で記録されるに留まりますが、場合によっては丸 1 日継続するようなケースもあります。<br>Azure データセンターでも、随時 KMS の補強作業を行っていますが、常時 100 ％成功を目指しているものではございません。<br>この理由としては、先述の通り Windows のライセンス認証はその後リトライされ、ライセンス失効期間内で毎回失敗し続けなければライセンスが失効することはありません。<br>つまりライセンス認証失敗のエラーイベントが恒常的にではなく、一時的に記録されるだけである場合、無視可能です。  </p><p>他方、一時的ではなく常に毎回ライセンス認証失敗が失敗している場合は別の原因があるものと考えられますため、別途トラブルシューティングが必要でございます。</p><hr><h3 id="ファイアウォール製品で通信をブロックしている"><a href="#ファイアウォール製品で通信をブロックしている" class="headerlink" title="ファイアウォール製品で通信をブロックしている"></a>ファイアウォール製品で通信をブロックしている</h3><p>KMS の通信が Azure Firewall 等のファイアウォール製品を経由している場合、このファイアウォールでライセンス認証の通信がブロックされている可能性がございます。  </p><p><img src="/blog/vm/kms-troubleshooting/2023-08-04-16-25-28.png"></p><p>このような場合は以下のいずれかの方法でご対応をお願いいたします。  </p><ul><li>解決方法 1：UDR を用いてファイアウォールを経由しないルーティングを行う</li></ul><p>UDR を用いて KMS サーバーへのライセンス認証の通信についてファイアウォールを経由しないようなルーティングとする方法となります。<br>設定方法については、<a href="./#%E5%BC%B7%E5%88%B6%E3%83%88%E3%83%B3%E3%83%8D%E3%83%AA%E3%83%B3%E3%82%B0%E7%92%B0%E5%A2%83%EF%BC%88%E3%82%AA%E3%83%B3%E3%83%97%E3%83%AC%E3%83%9F%E3%82%B9%E7%AD%89%E3%82%92%E7%B5%8C%E7%94%B1%E3%81%97%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E3%81%A8%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%EF%BC%89">「強制トンネリング環境（オンプレミス等を経由し直接通信となっていない）」</a> セクションの解決方法と同じになりますので、そちらをご参照ください。  </p><p><img src="/blog/vm/kms-troubleshooting/2023-08-04-16-27-07.png"></p><ul><li>解決方法 2：ファイアウォール製品でライセンス認証の通信を許可する</li></ul><p>先述の通り、ライセンス認証には以下の通信要件が必要でございますので、お使いのファイアウォール製品で Azure VM からの以下の通信を許可する設定をお願いいたします。  </p><table><thead><tr><th>項目</th><th>通信要件</th></tr></thead><tbody><tr><td>ドメイン</td><td>kms.core.windows.net および azkms.core.windows.net</td></tr><tr><td>IP アドレス</td><td>20.118.99.224, 40.83.235.53, 23.102.135.246</td></tr><tr><td>ポート</td><td>1688</td></tr><tr><td>プロトコル</td><td>TCP</td></tr></tbody></table><p><img src="/blog/vm/kms-troubleshooting/2023-08-04-16-29-13.png"></p><p>上手く改善されない場合は原因切り分けのために「解決方法 1：UDR を用いてファイアウォールを経由しないルーティングを行う」の方を実施していただけますと幸いです。</p><hr><h3 id="強制トンネリング環境（オンプレミス等を経由し直接通信となっていない）"><a href="#強制トンネリング環境（オンプレミス等を経由し直接通信となっていない）" class="headerlink" title="強制トンネリング環境（オンプレミス等を経由し直接通信となっていない）"></a>強制トンネリング環境（オンプレミス等を経由し直接通信となっていない）</h3><p>KMS サーバーは Azure 上の VM からの直接通信のみを受け付ける動作となっております。<br>そのため、Azure VM から送信される通信を強制トンネリングを用いて VPN / ExpressRoute を通過し、オンプレミス環境を経由するような設定を頂いている場合は、ライセンス認証が失敗いたします。  </p><p><img src="/blog/vm/kms-troubleshooting/2023-08-07-09-11-09.png"></p><p>このオンプレミス環境で KMS サーバーに接続できるような設定をしたとしても、実際のライセンス認証実行にて認証ができない状況となりますので留意ください。</p><p>■ご参考：強制トンネリングを使用したライセンス認証の問題<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/custom-routes-enable-kms-activation">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/custom-routes-enable-kms-activation</a></p><ul><li>解決方法：UDR を用いてファイアウォールを経由しないルーティングを行う</li></ul><p>Azure 上の VNET に属する Subnet 単位で UDR（User Defined Route）を用いて、特定 IP アドレスへの通信のルーティングを変更することが可能です。<br>すなわち、KMS サーバー（20.118.99.224, 40.83.235.53, 23.102.135.246）への通信のみ、直接通信とするために Next Hop を Internet にします。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-07-09-13-02.png"></p><p>ポータルからこの設定を行う、具体的な手順をご紹介させていただきます。  </p><p>まずは対象の Azure VM の画面にて右側のメニューより「ネットワーク」を選択肢し、対象の仮想ネットワーク / サブネットのリンクを選択します。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-15-26-12.png"></p><p>対象の Subnet に設定されているルート テーブル名を選択します。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-16-26-20.png"></p><p>左側のメニューより「ルート」を選択し「追加」より、KMS サーバーへの通信のみ、直接通信とするために Next Hop を Internet とするルートを 3 つそれぞれ作成します。<br>アドレス プレフィックスには、それぞれ以下の値をご入力ください。  </p><table><thead><tr><th>アドレス プレフィックス</th></tr></thead><tbody><tr><td>20.118.99.224/32</td></tr><tr><td>40.83.235.53/32</td></tr><tr><td>23.102.135.246/32</td></tr></tbody></table><p><img src="/blog/vm/kms-troubleshooting/2023-08-03-11-26-51.png"></p><p>これで、KMS ライセンス認証の通信を直接 KMS サーバーと通信するルーティングテーブルの設定ができました。</p><hr><h3 id="Standard-SKU-の-Azure-Load-Balancer-配下の-VM-で外部接続ができない"><a href="#Standard-SKU-の-Azure-Load-Balancer-配下の-VM-で外部接続ができない" class="headerlink" title="Standard SKU の Azure Load Balancer 配下の VM で外部接続ができない"></a>Standard SKU の Azure Load Balancer 配下の VM で外部接続ができない</h3><p>Standard SKU の Azure Load Balancer 配下の VM の場合、外部接続ができない状態となっていることに伴い KMS ライセンス認証の通信ができない場合がございます。<br>また、可用性セットの VM の場合、同一可用性セット内の別の VM が Standard SKU の Azure Load Balancer 配下にあると、同じく外部通信ができない状況が発生します。  </p><p>このような Standard SKU の Azure Load Balancer 配下の VM の場合は、KMS サーバーへの通信ができるように明示的に外部接続のポリシーを構成する必要がございます。<br>こちらのシナリオについては別途解説を行っているブログ記事がございますので、こちらをご参照くださいませ。</p><p>■ご参考：Azure VM の外部接続 (SNAT) オプション まとめ<br><a href="https://jpaztech.github.io/blog/network/snat-options-for-azure-vm/">https://jpaztech.github.io/blog/network/snat-options-for-azure-vm/</a></p><hr><h3 id="Tokens-dat-ファイルの破損"><a href="#Tokens-dat-ファイルの破損" class="headerlink" title="Tokens.dat ファイルの破損"></a>Tokens.dat ファイルの破損</h3><p>ライセンス認証を行ったところ以下のように「エラー コード: 0xC004E015 / 0xC004D301 / 0xC004E002」といったエラーが表示される場合がございます。  </p><p><img src="/blog/vm/kms-troubleshooting/2023-08-07-09-13-40.png" alt="現在 Windows のライセンス認証を行えません。後でもう一度実行してください。問題が解決しない場合は、システム管理者にお問い合わせください。 エラー コード: 0xC004E015"></p><p>この場合は Tokens.dat ファイルの破損が発生している可能性がございます。<br>以下の公開情報の手順で、Tokens.dat ファイルの再構築を行った後に、手動のライセンス認証が成功するかお試しいただけますと幸いです。</p><p>■ご参考：Tokens.dat ファイルの再構築<br><a href="https://learn.microsoft.com/ja-jp/windows-server/get-started/activation-rebuild-tokens-dat-file">https://learn.microsoft.com/ja-jp/windows-server/get-started/activation-rebuild-tokens-dat-file</a></p><hr><h2 id="さいごに（その他の要因等について）"><a href="#さいごに（その他の要因等について）" class="headerlink" title="さいごに（その他の要因等について）"></a>さいごに（その他の要因等について）</h2><p>以上がトラブルシューティングおよび、よくあるトラブルのパターンとなりますが、稀に上記以外の要因でもライセンス認証の失敗の可能性もございます。  </p><p>【例】</p><ul><li>OS 内部のファイアウォールでの KMS ライセンス認証通信のブロック</li><li>ライセンスキーが正常に登録されていない</li></ul><p>これらのシナリオに該当しない可能性もございますので、上記のトラブルシューティングで改善しない場合は、実施したトラブルシューティングの内容や対象の VM の情報などを添えて弊社の技術サポート窓口にお問い合わせをいただけますと幸いでございます。<br>上述の内容が皆様のお役に立つことを願っております。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;Azure 上で稼働する Windows VM のライセンス認証のためにマイクロソフトが KMS サーバー（KMS ホスト サーバー）を提供しております。&lt;br&gt;KMS サーバーへのライセンス認証要求は</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
    <category term="KMS" scheme="https://jpaztech.github.io/blog/tags/KMS/"/>
    
  </entry>
  
</feed>
